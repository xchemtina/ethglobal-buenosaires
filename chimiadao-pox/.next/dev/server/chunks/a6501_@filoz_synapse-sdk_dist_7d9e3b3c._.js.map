{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/utils/constants.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/utils/constants.ts"],"sourcesContent":["/**\n * Constants for the Synapse SDK\n */\n\nimport * as Abis from '@filoz/synapse-core/abis'\nimport { MAX_UPLOAD_SIZE as CORE_MAX_UPLOAD_SIZE } from '@filoz/synapse-core/piece'\nimport { erc20Abi, multicall3Abi } from 'viem'\nimport type { FilecoinNetworkType } from '../types.ts'\n\n/**\n * Token identifiers\n */\nexport const TOKENS = {\n  USDFC: 'USDFC' as const,\n  FIL: 'FIL' as const,\n} as const\n\n/**\n * Network chain IDs\n */\nexport const CHAIN_IDS: Record<FilecoinNetworkType, number> = {\n  mainnet: 314,\n  calibration: 314159,\n} as const\n\n/**\n * Contract ABIs\n */\nexport const CONTRACT_ABIS = {\n  /**\n   * ERC20 ABI - minimal interface needed for balance and approval operations\n   */\n  ERC20: erc20Abi,\n\n  /**\n   * Minimal ERC20Permit ABI - for reading nonces() and version()\n   */\n  ERC20_PERMIT: Abis.erc20WithPermit,\n\n  /**\n   * Payments contract ABI - based on fws-payments contract\n   */\n  PAYMENTS: Abis.payments,\n\n  /**\n   * PDPVerifier contract ABI - core PDP verification functions\n   */\n  PDP_VERIFIER: Abis.pdp,\n\n  /**\n   * Warm Storage ABI - write functions and service provider management\n   * View methods are in the WARM_STORAGE_VIEW contract\n   */\n  WARM_STORAGE: Abis.storage,\n\n  /**\n   * Warm Storage View contract ABI - read-only view methods separated from main contract\n   * These methods were moved from the main Warm Storage contract to reduce contract size\n   */\n  WARM_STORAGE_VIEW: Abis.storageView,\n\n  /**\n   * Multicall3 ABI - for batching multiple contract calls into a single RPC request\n   */\n  MULTICALL3: multicall3Abi,\n\n  /**\n   * ServiceProviderRegistry ABI - for provider management\n   */\n  SERVICE_PROVIDER_REGISTRY: Abis.serviceProviderRegistry,\n\n  /**\n   * SessionKeyRegistry ABI - for session key management\n   */\n  SESSION_KEY_REGISTRY: Abis.sessionKeyRegistry,\n} as const\n\n/**\n * EIP-2612 typed data schema (Permit)\n */\nexport const EIP2612_PERMIT_TYPES: Record<string, { name: string; type: string }[]> = {\n  Permit: [\n    { name: 'owner', type: 'address' },\n    { name: 'spender', type: 'address' },\n    { name: 'value', type: 'uint256' },\n    { name: 'nonce', type: 'uint256' },\n    { name: 'deadline', type: 'uint256' },\n  ],\n}\n\n/**\n * Time and size constants\n */\nexport const TIME_CONSTANTS = {\n  /**\n   * Duration of each epoch in seconds on Filecoin\n   */\n  EPOCH_DURATION: 30,\n\n  /**\n   * Number of epochs in a day (24 hours * 60 minutes * 2 epochs per minute)\n   */\n  EPOCHS_PER_DAY: 2880n,\n\n  /**\n   * Number of epochs in a month (30 days)\n   */\n  EPOCHS_PER_MONTH: 86400n, // 30 * 2880\n\n  /**\n   * Number of days in a month (used for pricing calculations)\n   */\n  DAYS_PER_MONTH: 30n,\n\n  /**\n   * Default lockup period in days\n   */\n  DEFAULT_LOCKUP_DAYS: 30n,\n} as const\n\n/**\n * Genesis timestamps for Filecoin networks (Unix timestamp in seconds)\n */\nexport const GENESIS_TIMESTAMPS: Record<FilecoinNetworkType, number> = {\n  /**\n   * Mainnet genesis: August 24, 2020 22:00:00 UTC\n   */\n  mainnet: 1598306400,\n  /**\n   * Calibration testnet genesis: November 1, 2022 18:13:00 UTC\n   */\n  calibration: 1667326380,\n} as const\n\n/**\n * Data size constants\n */\nexport const SIZE_CONSTANTS = {\n  /**\n   * Bytes in 1 KiB\n   */\n  KiB: 1024n,\n\n  /**\n   * Bytes in 1 MiB\n   */\n  MiB: 1n << 20n,\n\n  /**\n   * Bytes in 1 GiB\n   */\n  GiB: 1n << 30n,\n\n  /**\n   * Bytes in 1 TiB\n   */\n  TiB: 1n << 40n,\n\n  /**\n   * Bytes in 1 PiB\n   */\n  PiB: 1n << 50n,\n\n  /**\n   * Maximum upload size supported by Curio PDP servers: 1 GiB adjusted for fr32 expansion.\n   *\n   * 1 GiB * (127/128) = 1,065,353,216 bytes\n   *\n   * Fr32 encoding adds 2 bits of padding per 254 bits of data, resulting in 128 bytes\n   * of padded data for every 127 bytes of raw data.\n   *\n   * Note: While it's technically possible to upload pieces this large as Uint8Array\n   * (even in browsers), streaming via AsyncIterable is strongly recommended for\n   * non-trivial sizes. In-memory operations with large byte arrays can:\n   * - Cause memory pressure and garbage collection issues\n   * - Block the JavaScript event loop during allocation/copying\n   * - Trigger browser tab slowdowns or \"unresponsive script\" warnings\n   *\n   * For optimal performance and resource utilization, prefer streaming for pieces\n   * larger than a few megabytes, especially in browser environments.\n   *\n   * Imported from @filoz/synapse-core/piece\n   */\n  MAX_UPLOAD_SIZE: CORE_MAX_UPLOAD_SIZE,\n\n  /**\n   * Minimum upload size (127 bytes)\n   * PieceCIDv2 calculation requires at least 127 bytes payload\n   */\n  MIN_UPLOAD_SIZE: 127,\n\n  /**\n   * Default number of uploads to batch together in a single addPieces transaction\n   * This balances gas efficiency with reasonable transaction sizes\n   */\n  DEFAULT_UPLOAD_BATCH_SIZE: 32,\n} as const\n\n/**\n * Common metadata keys\n */\nexport const METADATA_KEYS = {\n  /**\n   * Key used to request that CDN services should be enabled for a data set. The presence of this\n   * key does not strictly guarantee that CDN services will be provided, but the Warm Storage\n   * contract will attempt to enable payment for CDN services if this key is present.\n   *\n   * The value for this key is always an empty string.\n   *\n   * Only valid for *data set* metadata.\n   */\n  WITH_CDN: 'withCDN',\n\n  /**\n   * Key used to request that a PDP server perform IPFS indexing and announcing to IPNI should be\n   * enabled for all pieces in a data set. The contents of the associated data sets are assumed to\n   * be indexable (i.e. a CAR or a PoDSI container) and the PDP server will be requested to perform\n   * best-effort indexing. The presence of this key does not guarantee that indexing will be\n   * performed or succeed.\n   *\n   * The value for this key is always an empty string.\n   *\n   * Only valid for *data set* metadata.\n   */\n  WITH_IPFS_INDEXING: 'withIPFSIndexing',\n\n  /**\n   * Key used to indicate a root CID of an IPLD DAG contained within the associated piece.\n   * Advisory only: do not treat as proof that the CID is valid, that IPLD blocks are present, or\n   * that the referenced DAG is fully present or retrievable. Intended as a secondary identifier\n   * provided by the data producer; not interpreted by contracts.\n   *\n   * The value for this key should be a valid CID string.\n   *\n   * Only valid for *piece* metadata.\n   */\n  IPFS_ROOT_CID: 'ipfsRootCID',\n} as const\n\n/**\n * Timing constants for blockchain operations\n */\nexport const TIMING_CONSTANTS = {\n  /**\n   * How long to wait for a transaction to appear on the network\n   * This is used when we have a transaction hash but need to fetch the transaction object\n   * Filecoin has 30-second epochs, so this gives six full epochs for propagation\n   * Matches viem's standard timeout for transaction receipt (180s)\n   */\n  TRANSACTION_PROPAGATION_TIMEOUT_MS: 180000, // 180 seconds (3 minutes, 6 epochs)\n\n  /**\n   * How often to poll when waiting for a transaction to appear\n   */\n  TRANSACTION_PROPAGATION_POLL_INTERVAL_MS: 2000, // 2 seconds\n\n  /**\n   * Maximum time to wait for a data set creation to complete\n   * This includes transaction mining and the data set becoming live on-chain\n   */\n  DATA_SET_CREATION_TIMEOUT_MS: 7 * 60 * 1000, // 7 minutes\n\n  /**\n   * How often to poll for data set creation status\n   */\n  DATA_SET_CREATION_POLL_INTERVAL_MS: 2000, // 2 seconds\n\n  /**\n   * Maximum time to wait for a piece to be parked (uploaded) to storage\n   * This is typically slower than blockchain operations as it involves data transfer\n   */\n  PIECE_PARKING_TIMEOUT_MS: 7 * 60 * 1000, // 7 minutes\n\n  /**\n   * How often to poll for piece parking status\n   * Less frequent than blockchain polling as uploads take longer\n   */\n  PIECE_PARKING_POLL_INTERVAL_MS: 5000, // 5 seconds\n\n  /**\n   * Number of confirmations to wait for when calling transaction.wait()\n   * Set to 1 by default to ensure the transaction is mined, could be increased\n   * in the future, or aligned to F3 expectations\n   */\n  TRANSACTION_CONFIRMATIONS: 1,\n\n  /**\n   * Default expiry time for EIP-2612 permit signatures (in seconds)\n   * Permits are time-limited approvals that expire after this duration\n   */\n  PERMIT_DEADLINE_DURATION: 3600, // 1 hour\n\n  /**\n   * Maximum time to wait for a piece addition to be confirmed and acknowledged\n   * This includes transaction confirmation and server verification\n   */\n  PIECE_ADDITION_TIMEOUT_MS: 7 * 60 * 1000, // 7 minutes\n\n  /**\n   * How often to poll for piece addition status\n   */\n  PIECE_ADDITION_POLL_INTERVAL_MS: 1000, // 1 second\n} as const\n\n/**\n * Settlement fee required for rail settlement operations\n * This is the NETWORK_FEE constant in the Payments contract that gets burned to the Filecoin network\n * Value: 0.0013 FIL (1300000000000000 attoFIL)\n *\n * IMPORTANT: This value must be kept in sync with the Payments contract's NETWORK_FEE constant.\n * If the contract is upgraded with a different fee, this constant must be updated accordingly.\n */\nexport const SETTLEMENT_FEE = 1300000000000000n // 0.0013 FIL in attoFIL\n\n/**\n * Recommended RPC endpoints for Filecoin networks\n */\nexport const RPC_URLS: Record<FilecoinNetworkType, { http: string; websocket: string }> = {\n  mainnet: {\n    http: 'https://api.node.glif.io/rpc/v1',\n    websocket: 'wss://wss.node.glif.io/apigw/lotus/rpc/v1',\n  },\n  calibration: {\n    http: 'https://api.calibration.node.glif.io/rpc/v1',\n    websocket: 'wss://wss.calibration.node.glif.io/apigw/lotus/rpc/v1',\n  },\n} as const\n\n/**\n * Contract addresses\n */\nexport const CONTRACT_ADDRESSES = {\n  /**\n   * Warm Storage service contract addresses - the only address needed for SDK initialization\n   * All other contract addresses are discovered from this contract\n   */\n  WARM_STORAGE: {\n    mainnet: '0x8408502033C418E1bbC97cE9ac48E5528F371A9f',\n    calibration: '0x02925630df557F957f70E112bA06e50965417CA0',\n  } as const satisfies Record<FilecoinNetworkType, string>,\n\n  /**\n   * Multicall3 contract addresses - used for batching multiple contract calls\n   * Same address across most EVM chains including Filecoin\n   */\n  MULTICALL3: {\n    mainnet: '0xcA11bde05977b3631167028862bE2a173976CA11',\n    calibration: '0xcA11bde05977b3631167028862bE2a173976CA11',\n  } as const satisfies Record<FilecoinNetworkType, string>,\n\n  USDFC: {\n    mainnet: '0x80B98d3aa09ffff255c3ba4A241111Ff1262F045',\n    calibration: '0xb3042734b608a1B16e9e86B374A3f3e389B4cDf0',\n  } as const satisfies Record<FilecoinNetworkType, string>,\n} as const\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 152, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/utils/eip712.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/utils/eip712.ts"],"sourcesContent":["import { TypedData } from 'ox'\nimport { keccak256, stringToHex } from 'viem'\n\n/**\n * EIP-712 Type definitions for PDP operations verified by WarmStorage.\n */\nexport const EIP712_TYPES = {\n  MetadataEntry: [\n    { name: 'key', type: 'string' },\n    { name: 'value', type: 'string' },\n  ],\n  CreateDataSet: [\n    { name: 'clientDataSetId', type: 'uint256' },\n    { name: 'payee', type: 'address' },\n    { name: 'metadata', type: 'MetadataEntry[]' },\n  ],\n  Cid: [{ name: 'data', type: 'bytes' }],\n  PieceMetadata: [\n    { name: 'pieceIndex', type: 'uint256' },\n    { name: 'metadata', type: 'MetadataEntry[]' },\n  ],\n  AddPieces: [\n    { name: 'clientDataSetId', type: 'uint256' },\n    { name: 'nonce', type: 'uint256' },\n    { name: 'pieceData', type: 'Cid[]' },\n    { name: 'pieceMetadata', type: 'PieceMetadata[]' },\n  ],\n  SchedulePieceRemovals: [\n    { name: 'clientDataSetId', type: 'uint256' },\n    { name: 'pieceIds', type: 'uint256[]' },\n  ],\n  DeleteDataSet: [{ name: 'clientDataSetId', type: 'uint256' }],\n}\n\nexport const EIP712_ENCODED_TYPES: Record<string, string> = {}\nexport const EIP712_TYPE_HASHES: Record<string, string> = {}\n\nfor (const typeName in EIP712_TYPES) {\n  const encodedType = TypedData.encodeType({\n    types: EIP712_TYPES,\n    primaryType: typeName,\n  })\n  EIP712_ENCODED_TYPES[typeName] = encodedType\n  EIP712_TYPE_HASHES[typeName] = keccak256(stringToHex(encodedType))\n}\n"],"names":[],"mappings":";;;;;;;;AAAA,OAAO,EAAE,SAAS,EAAE,MAAM,IAAI,CAAA;;AAC9B,OAAO,EAAE,SAAS,EAAE,WAAW,EAAE,MAAM,MAAM,CAAA;;;AAKtC,MAAM,YAAY,GAAG;IAC1B,aAAa,EAAE;QACb;YAAE,IAAI,EAAE,KAAK;YAAE,IAAI,EAAE,QAAQ;QAAA,CAAE;QAC/B;YAAE,IAAI,EAAE,OAAO;YAAE,IAAI,EAAE,QAAQ;QAAA,CAAE;KAClC;IACD,aAAa,EAAE;QACb;YAAE,IAAI,EAAE,iBAAiB;YAAE,IAAI,EAAE,SAAS;QAAA,CAAE;QAC5C;YAAE,IAAI,EAAE,OAAO;YAAE,IAAI,EAAE,SAAS;QAAA,CAAE;QAClC;YAAE,IAAI,EAAE,UAAU;YAAE,IAAI,EAAE,iBAAiB;QAAA,CAAE;KAC9C;IACD,GAAG,EAAE;QAAC;YAAE,IAAI,EAAE,MAAM;YAAE,IAAI,EAAE,OAAO;QAAA,CAAE;KAAC;IACtC,aAAa,EAAE;QACb;YAAE,IAAI,EAAE,YAAY;YAAE,IAAI,EAAE,SAAS;QAAA,CAAE;QACvC;YAAE,IAAI,EAAE,UAAU;YAAE,IAAI,EAAE,iBAAiB;QAAA,CAAE;KAC9C;IACD,SAAS,EAAE;QACT;YAAE,IAAI,EAAE,iBAAiB;YAAE,IAAI,EAAE,SAAS;QAAA,CAAE;QAC5C;YAAE,IAAI,EAAE,OAAO;YAAE,IAAI,EAAE,SAAS;QAAA,CAAE;QAClC;YAAE,IAAI,EAAE,WAAW;YAAE,IAAI,EAAE,OAAO;QAAA,CAAE;QACpC;YAAE,IAAI,EAAE,eAAe;YAAE,IAAI,EAAE,iBAAiB;QAAA,CAAE;KACnD;IACD,qBAAqB,EAAE;QACrB;YAAE,IAAI,EAAE,iBAAiB;YAAE,IAAI,EAAE,SAAS;QAAA,CAAE;QAC5C;YAAE,IAAI,EAAE,UAAU;YAAE,IAAI,EAAE,WAAW;QAAA,CAAE;KACxC;IACD,aAAa,EAAE;QAAC;YAAE,IAAI,EAAE,iBAAiB;YAAE,IAAI,EAAE,SAAS;QAAA,CAAE;KAAC;CAC9D,CAAA;AAEM,MAAM,oBAAoB,GAA2B,CAAA,CAAE,CAAA;AACvD,MAAM,kBAAkB,GAA2B,CAAA,CAAE,CAAA;AAE5D,IAAK,MAAM,QAAQ,IAAI,YAAY,CAAE,CAAC;IACpC,MAAM,WAAW,GAAG,2NAAS,CAAC,UAAU,CAAC;QACvC,KAAK,EAAE,YAAY;QACnB,WAAW,EAAE,QAAQ;KACtB,CAAC,CAAA;IACF,oBAAoB,CAAC,QAAQ,CAAC,GAAG,WAAW,CAAA;IAC5C,kBAAkB,CAAC,QAAQ,CAAC,OAAG,iMAAS,MAAC,mMAAW,EAAC,WAAW,CAAC,CAAC,CAAA;AACpE,CAAC"}},
    {"offset": {"line": 254, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/package.json"],"sourcesContent":["{\"name\":\"@filoz/synapse-sdk\",\"version\":\"0.36.0\",\"description\":\"JavaScript SDK for Filecoin Onchain Cloud\",\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/FilOzone/synapse-sdk.git\"},\"keywords\":[\"filecoin\",\"synapse\",\"filecoin pay\",\"filecoin onchain cloud\",\"web3\"],\"author\":\"Rod Vagg <rod@vagg.org>\",\"license\":\"Apache-2.0 OR MIT\",\"bugs\":{\"url\":\"https://github.com/FilOzone/synapse-sdk/issues\"},\"homepage\":\"https://github.com/FilOzone/synapse-sdk/tree/main/packages/synapse-sdk\",\"type\":\"module\",\"main\":\"dist/src/index.js\",\"types\":\"dist/src/index.d.ts\",\"exports\":{\".\":{\"import\":\"./dist/src/index.js\",\"types\":\"./dist/src/index.d.ts\"},\"./pdp\":{\"import\":\"./dist/src/pdp/index.js\",\"types\":\"./dist/src/pdp/index.d.ts\"},\"./payments\":{\"import\":\"./dist/src/payments/index.js\",\"types\":\"./dist/src/payments/index.d.ts\"},\"./warm-storage\":{\"import\":\"./dist/src/warm-storage/index.js\",\"types\":\"./dist/src/warm-storage/index.d.ts\"},\"./subgraph\":{\"import\":\"./dist/src/subgraph/index.js\",\"types\":\"./dist/src/subgraph/index.d.ts\"},\"./sp-registry\":{\"import\":\"./dist/src/sp-registry/index.js\",\"types\":\"./dist/src/sp-registry/index.d.ts\"}},\"scripts\":{\"build\":\"wireit\",\"lint\":\"wireit\",\"lint:fix\":\"biome check --no-errors-on-unmatched --files-ignore-unknown=true --fix .\",\"test\":\"wireit\",\"test:node\":\"wireit\",\"test:browser\":\"wireit\",\"clean\":\"rm -rf dist\",\"prepublishOnly\":\"pnpm run clean && pnpm run build\"},\"wireit\":{\"build\":{\"command\":\"tsc --build --pretty\",\"clean\":\"if-file-deleted\",\"files\":[\"src/**/*.ts\",\"tsconfig.json\"],\"output\":[\"dist/**\"],\"dependencies\":[\"../synapse-core:build\"]},\"lint\":{\"command\":\"biome check --no-errors-on-unmatched --files-ignore-unknown=true .\",\"files\":[\"src/**/*.ts\",\"../../biome.json\"],\"output\":[],\"dependencies\":[\"build\"]},\"test\":{\"command\":\"pnpm run test:node && pnpm run test:browser\",\"files\":[\"src/**/*.ts\"],\"output\":[],\"dependencies\":[\"lint\"]},\"test:node\":{\"command\":\"playwright-test \\\"src/test/**/*.test.ts\\\" --mode node\",\"files\":[\"src/**/*.ts\"],\"output\":[],\"dependencies\":[\"../synapse-core:build\"]},\"test:browser\":{\"command\":\"playwright-test \\\"src/test/**/*.test.ts\\\" --assets ./src/test/mocks\",\"files\":[\"src/**/*.ts\"],\"output\":[],\"dependencies\":[\"../synapse-core:build\"]}},\"dependencies\":{\"@filoz/synapse-core\":\"workspace:^\",\"@web3-storage/data-segment\":\"^5.3.0\",\"ethers\":\"^6.15.0\",\"multiformats\":\"^13.4.1\",\"ox\":\"^0.9.12\",\"viem\":\"^2.38.3\"},\"optionalDependencies\":{\"@sentry/browser\":\"^10.21.0\",\"@sentry/node\":\"^10.21.0\"},\"devDependencies\":{\"@biomejs/biome\":\"2.3.5\",\"@types/chai\":\"^5.2.3\",\"@types/mocha\":\"^10.0.10\",\"@types/node\":\"^24.9.1\",\"@wagmi/cli\":\"^2.7.0\",\"abitype\":\"^1.1.1\",\"chai\":\"^6.2.0\",\"iso-web\":\"^1.4.3\",\"mocha\":\"^11.7.4\",\"msw\":\"~2.10.5\",\"p-defer\":\"^4.0.1\",\"playwright-test\":\"^14.1.12\",\"type-fest\":\"^5.1.0\",\"typescript\":\"5.9.3\"},\"publishConfig\":{\"access\":\"public\"},\"msw\":{\"workerDirectory\":[\"src/test/mocks\"]},\"browser\":{\"@sentry/node\":\"@sentry/browser\"}}"],"names":[],"mappings":"AAAA"}},
    {"offset": {"line": 254, "column": 2913}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 258, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/utils/sdk-version.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/utils/sdk-version.ts"],"sourcesContent":["import packageJson from '../../package.json' with { type: 'json' }\n\n/**\n * Export the current SDK version from package.json so runtime code can stay in sync\n * without hardcoding the value in multiple places.\n */\nexport const SDK_VERSION = packageJson.version\n"],"names":[],"mappings":";;;;AAAA,OAAO,WAAW,MAAM,oBAAoB,CAAC,OAAO,IAAI,EAAE,MAAM,EAAE,CAAA;;AAM3D,MAAM,WAAW,GAAG,uKAAW,CAAC,OAAO,CAAA"}},
    {"offset": {"line": 269, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/telemetry/utils.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/telemetry/utils.ts"],"sourcesContent":["import type * as SentryBrowser from '@sentry/browser'\nimport type * as SentryNode from '@sentry/node'\n\n/**\n * The telemetry module here and elsewhere needs to know whether we're running in a browser context or not.\n * We determine this once here and export.\n * This presumably should be done somewhere more broadly scoped within Synapse,\n * but we're doing it here for now.\n */\nexport const isBrowser =\n  typeof (globalThis as any).window !== 'undefined' && typeof (globalThis as any).document !== 'undefined'\n\nexport type SentryBrowserType = typeof SentryBrowser.default\nexport type SentryNodeType = typeof SentryNode.default\nexport type SentryType = SentryNodeType | SentryBrowserType\n\n/**\n * Dynamically import the correct Sentry package for whether we're running in a browser or Node.\n * Returns null if the Sentry dependencies are not available (optional peer dependencies).\n */\nexport async function getSentry(): Promise<SentryType | null> {\n  try {\n    if (isBrowser) {\n      return (await import('@sentry/browser')) satisfies typeof SentryBrowser\n    }\n    return (await import('@sentry/node')) satisfies typeof SentryNode\n  } catch {\n    // Sentry dependencies not available (optional peer dependencies)\n    return null\n  }\n}\n\n/**\n * Map of regex patterns to their replacement strings for URL sanitization.\n * Order matters: more specific patterns should come before more general ones.\n */\nconst URL_SANITIZATION_PATTERNS: Array<[RegExp, string]> = [\n  // Remove query parameters to reduce cardinality\n  [/\\?.+/, ''],\n\n  // Replace UUIDs (format: 8-4-4-4-12 hex digits)\n  [/\\/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}/gi, '/<UUID>'],\n\n  // Replace CIDs (Content Identifiers - bafk, bafy, etc.)\n  [/\\/baf[a-z0-9]{50,}/g, '/<CID>'],\n\n  // Replace transaction hashes (0x followed by 16+ hex chars)\n  [/\\/0x[a-f0-9]{16,}/gi, '/<txHash>'],\n\n  // Replace numeric IDs in paths (e.g., dataset IDs)\n  [/\\/[0-9]+\\b/g, '/<ID>'],\n]\n\n/**\n * Sanitizes a string representing a URL, METHOD + URL, or path for use in span names by replacing variable parts with placeholders.\n * This improves span grouping and reduces cardinality in telemetry data.\n *\n * Replacements:\n * - Query parameters → removed entirely\n * - UUIDs (8-4-4-4-12 format) → /<UUID>\n * - CIDs (bafk..., bafy...) → /<CID>\n * - Transaction hashes (0x + 16+ hex chars) → /<txHash>\n * - Numeric IDs → /<ID>\n *\n * @param url - The URL to sanitize\n * @returns Sanitized URL string suitable for span naming\n *\n * @example\n * sanitizeUrlForSpan('GET https://pdp.com/pdp/piece/bafkzcibf7pc.../status?foo=bar')\n * // Returns: 'GET https://pdp.com/pdp/piece/<CID>/status'\n *\n * @example\n * sanitizeUrlForSpan('POST https://pdp.com/pdp/data-sets/27/pieces/added/0xabc123...')\n * // Returns: 'POST https://pdp.com/pdp/data-sets/<ID>/pieces/added/<txHash>'\n */\nexport function sanitizeUrlForSpan(urlOrPath: string): string {\n  let sanitized = urlOrPath\n\n  for (const [pattern, replacement] of URL_SANITIZATION_PATTERNS) {\n    sanitized = sanitized.replace(pattern, replacement)\n  }\n\n  return sanitized\n}\n"],"names":[],"mappings":";;;;;;;;AASO,MAAM,SAAS,GACpB,OAAQ,UAAkB,CAAC,MAAM,KAAK,WAAW,IAAI,OAAQ,UAAkB,CAAC,QAAQ,KAAK,WAAW,CAAA;AAUnG,KAAK,UAAU,SAAS;IAC7B,IAAI,CAAC;QACH,IAAI,SAAS,EAAE,CAAC;YACd,OAAO,AAAC,MAAM,MAAM,CAAC,iBAAiB,CAAC,CAAgC,CAAA;QACzE,CAAC;QACD,OAAO,AAAC,MAAM,MAAM,CAAC,cAAc,CAAC,CAA6B,CAAA;IACnE,CAAC,CAAC,OAAM,CAAC;QAEP,OAAO,IAAI,CAAA;IACb,CAAC;AACH,CAAC;AAMD,MAAM,yBAAyB,GAA4B;IAEzD;QAAC,MAAM;QAAE,EAAE;KAAC;IAGZ;QAAC,kEAAkE;QAAE,SAAS;KAAC;IAG/E;QAAC,qBAAqB;QAAE,QAAQ;KAAC;IAGjC;QAAC,qBAAqB;QAAE,WAAW;KAAC;IAGpC;QAAC,aAAa;QAAE,OAAO;KAAC;CACzB,CAAA;AAwBK,SAAU,kBAAkB,CAAC,SAAiB;IAClD,IAAI,SAAS,GAAG,SAAS,CAAA;IAEzB,KAAK,MAAM,CAAC,OAAO,EAAE,WAAW,CAAC,IAAI,yBAAyB,CAAE,CAAC;QAC/D,SAAS,GAAG,SAAS,CAAC,OAAO,CAAC,OAAO,EAAE,WAAW,CAAC,CAAA;IACrD,CAAC;IAED,OAAO,SAAS,CAAA;AAClB,CAAC"}},
    {"offset": {"line": 321, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/telemetry/service.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/telemetry/service.ts"],"sourcesContent":["/**\n * TelemetryService - Main telemetry service for Synapse SDK.\n * Per [issue #328](https://github.com/FilOzone/synapse-sdk/issues/328) this is primarily a thin wrapper around sentry.io.\n * It allows a caller to pass through [Sentry configuration options](https://docs.sentry.io/platforms/javascript/guides/nextjs/configuration/options/), where Synapse will apply some defaults if they aren't otherwise set.\n * (See the constructor for more information.)\n * The underlying Sentry instance can be accessed via `.sentry` for invoking any other [Sentry APIs](https://docs.sentry.io/platforms/javascript/apis/).\n *\n * In addition, to help with support tickets, the TelemetryService can be queried to get recent events:\n *\n * ```typescript\n * const dump = synapse.telemetry.debugDump()\n * console.log(JSON.stringify(dump, null, 2))\n * ```\n */\n\nimport type { BrowserOptions, ErrorEvent, EventHint } from '@sentry/browser'\nimport type { NodeOptions } from '@sentry/node'\nimport type { FilecoinNetworkType } from '../types.ts'\nimport { SDK_VERSION } from '../utils/sdk-version.ts'\nimport {\n  getSentry,\n  isBrowser,\n  type SentryBrowserType,\n  type SentryNodeType,\n  type SentryType,\n  sanitizeUrlForSpan,\n} from './utils.ts'\n\ntype SentryInitOptions = BrowserOptions | NodeOptions\ntype SentrySetTags = Parameters<SentryType['setTags']>[0]\n\ntype SentryBeforeSendFunction = (event: ErrorEvent, hint: EventHint) => Promise<ErrorEvent | null>\n\n/**\n * Extract the beforeSendSpan function type from both BrowserOptions and NodeOptions.\n * This ensures we match Sentry's expected signature exactly.\n */\ntype SentryBeforeSendSpanFunction = NonNullable<SentryInitOptions['beforeSendSpan']>\n\nexport interface TelemetryConfig {\n  /**\n   * Additional options to pass to the Sentry SDK's init method.\n   * See https://docs.sentry.io/platforms/javascript/configuration/options/\n   */\n  sentryInitOptions?: SentryInitOptions\n  /**\n   * Additional tags to set on the Sentry SDK.\n   * See https://docs.sentry.io/platforms/javascript/apis/#setTags\n   */\n  sentrySetTags?: SentrySetTags\n}\n\n/**\n * Configuration about the \"runtime environment\" for Synapse that needs Synapse-specific knowledge.\n * This isn't to be confused with [Sentry's Runtime context](https://develop.sentry.dev/sdk/data-model/event-payloads/contexts/#runtime-context).\n */\nexport interface TelemetryRuntimeContext {\n  filecoinNetwork: FilecoinNetworkType\n}\n\nexport interface DebugDump {\n  events: any[]\n}\n\n/**\n * Main telemetry service that manages the adapter and provides high-level APIs\n */\nexport class TelemetryService {\n  private eventBuffer: any[] = []\n  private readonly maxBufferSize = 15\n\n  sentry: SentryType | null = null\n\n  /**\n   * This is a separate function rather than being in the constructor because it is async. This is called by initGlobalTelemetry in singleton.ts, which is called by Synapse.create in synapse.ts.\n   * Default values that make sense for synapse-sdk will be set for some [Sentry configuration options](https://docs.sentry.io/platforms/javascript/guides/nextjs/configuration/options/) if they aren't otherwise specified.\n   * See the source for the specific defaults.\n   */\n  public async initSentry(config: TelemetryConfig, context: TelemetryRuntimeContext): Promise<void> {\n    const Sentry = await getSentry()\n    if (!Sentry) {\n      // Sentry dependencies not available, telemetry will be disabled\n      return\n    }\n    this.sentry = Sentry\n\n    // sentry attempts to dedupe some duplicate errors, see https://docs.sentry.io/platforms/javascript/configuration/integrations/dedupe/\n    const integrations = [Sentry.dedupeIntegration()]\n    let runtime: 'browser' | 'node'\n    if (isBrowser) {\n      runtime = 'browser'\n      integrations.push(\n        // only error-handling integrations\n        (Sentry as SentryBrowserType).globalHandlersIntegration({ onerror: true, onunhandledrejection: true })\n      )\n    } else {\n      runtime = 'node'\n      integrations.push(\n        // only error-handling integrations\n        (Sentry as SentryNodeType).onUncaughtExceptionIntegration(),\n        (Sentry as SentryNodeType).onUnhandledRejectionIntegration()\n      )\n    }\n\n    const globalTags = {\n      ...config.sentrySetTags, // get any tags consumers want to set\n\n      // things that consumers should not need, nor be able, to override\n      filecoinNetwork: context.filecoinNetwork, // The network (mainnet/calibration) that the synapse-sdk is being used in.\n      synapseSdkVersion: `@filoz/synapse-sdk@v${SDK_VERSION}`, // The version of the synapse-sdk that is being used.\n    }\n\n    this.sentry.init({\n      // Maps to Sentry project \"synapse-sdk-2\" on the backend.\n      dsn: 'https://7a07cc9e3b5bf5a8fada2f25dc76cd49@o4510235322023936.ingest.us.sentry.io/4510308233445376',\n      // Setting this option to false will prevent the SDK from sending default PII data to Sentry.\n      // For example, automatic IP address collection on events\n      sendDefaultPii: false,\n      // Enable tracing/performance monitoring\n      tracesSampleRate: 1.0, // Capture 100% of transactions for development (adjust in production)\n      integrations,\n      defaultIntegrations: false,\n      ...config.sentryInitOptions,\n      beforeSend: this.createBeforeSend(config),\n      beforeSendSpan: this.createBeforeSendSpan(config, globalTags),\n      release: `@filoz/synapse-sdk@v${SDK_VERSION}`,\n    })\n\n    // Things that we don't need to search for in sentry UI, but may be useful for debugging should be set as context.\n    // See https://docs.sentry.io/platforms/javascript/guides/nextjs/apis/#setContext\n    // In this case, we're using the \"common context\" of \"runtime\" as its the closest match.\n    // See https://develop.sentry.dev/sdk/data-model/event-payloads/contexts/#runtime-context\n    this.sentry.setContext('runtime', {\n      type: runtime,\n      // userAgent may not be useful for searching, but will be useful for debugging\n      userAgent: isBrowser && 'navigator' in globalThis ? (globalThis as any).navigator.userAgent : undefined,\n    })\n\n    // Things that we can search in the sentry UI (i.e. not millions of unique potential values, like userAgent would have) should be set as tags\n    this.sentry.setTags(globalTags)\n  }\n\n  /**\n   * Create a function that stores any events before Sentry sends to help with local debugging via `debugDump`.\n   * This function is intended to be set to [Sentry's `beforeSend` option](https://docs.sentry.io/platforms/javascript/guides/nextjs/configuration/options/#beforeSend).\n   * If the TelemetryConfig specified a `beforeSend` function, that function will be called after storing the event locally.\n   * The created `beforeSend` function is not [currently doing any filtering](https://docs.sentry.io/platforms/javascript/configuration/filtering/#using-before-send).\n   * @param config\n   * @returns Function that can be set for `beforeSend` Sentry option.\n   */\n  protected createBeforeSend(config: TelemetryConfig): SentryBeforeSendFunction {\n    return (async (event, hint) => {\n      this.addToEventBuffer(event)\n\n      if (config.sentryInitOptions?.beforeSend != null) {\n        return await config.sentryInitOptions.beforeSend(event, hint)\n      }\n\n      return event\n    }) satisfies SentryBeforeSendFunction\n  }\n\n  /**\n   * Create a function that sanitizes span descriptions before sending to Sentry.\n   * This function is intended to be set to [Sentry's `beforeSendSpan` option](https://docs.sentry.io/platforms/javascript/configuration/options/#beforeSendSpan).\n   * If the TelemetryConfig specified a `beforeSendSpan` function, that function will be called first, then sanitization will be applied.\n   * The sanitization replaces variable parts (UUIDs, CIDs, transaction hashes, numeric IDs) with placeholders to improve span grouping and reduce cardinality.\n   * Only applies to spans with descriptions that start with HTTP verbs (GET, POST, PUT, etc.).\n   *\n   * In addition, we ensure `op=http.client` spans get the tags that were set  with `sentry.setTags`.\n   * Without this, `op=http.client` spans will miss tags like `synapseSdkVersion`.\n   * We don't know why  `op=http.client` doesn't otherwise get \"global tags\", but this is our workaround.\n   * We want this so we can group by `<server.address,url.sanitizedPath,http.response.status_code>` and still filter by `synapseSdkVersion`.\n   * @param config\n   * @returns Function that can be set for `beforeSendSpan` Sentry option.\n   */\n  protected createBeforeSendSpan(\n    config: TelemetryConfig,\n    globalTags: Record<string, string>\n  ): SentryBeforeSendSpanFunction {\n    const httpVerbPattern = /^(GET|POST|PUT|PATCH|DELETE|HEAD|OPTIONS|TRACE|CONNECT)\\s/i\n\n    return ((span) => {\n      // Call user-provided beforeSendSpan first, if it exists\n      let modifiedSpan = span\n      if (config.sentryInitOptions?.beforeSendSpan != null) {\n        const userModifiedSpan = config.sentryInitOptions.beforeSendSpan(span)\n        if (userModifiedSpan != null) {\n          modifiedSpan = userModifiedSpan\n        }\n      }\n\n      // Sanitize the span description to reduce cardinality (only for HTTP verb spans)\n      // beforeSendSpan receives a plain JSON object with a description property\n      if (modifiedSpan.description && httpVerbPattern.test(modifiedSpan.description)) {\n        modifiedSpan.description = sanitizeUrlForSpan(modifiedSpan.description)\n\n        // Ensure the url.* tags have a sanitized path as well\n        if (modifiedSpan.op === 'http.client' || modifiedSpan.data['sentry.op'] === 'http.client') {\n          modifiedSpan.data = {\n            // Apply the \"global tags\" since `op=http.client` spans don't otherwise have them.\n            ...globalTags,\n            ...modifiedSpan.data,\n            // We call sanitizeUrlForSpan again here because modifiedSpan.description has a HTTP verb and a domain name before the path.\n            // The alternative is to remove the HTTP verb and domain name entirely.\n            'url.sanitizedPath': sanitizeUrlForSpan(modifiedSpan.data?.['url.path']?.toString() ?? ''),\n          }\n        }\n      }\n\n      return modifiedSpan\n    }) satisfies SentryBeforeSendSpanFunction\n  }\n\n  /**\n   * Get debug dump for support tickets\n   *\n   * Returns enough information for devs to dive into the data on filoz.sentry.io\n   *\n   * @example\n   * ```typescript\n   * const dump = synapse.telemetry.debugDump()\n   * console.log(JSON.stringify(dump, null, 2))\n   * ```\n   */\n  debugDump(limit = 50): DebugDump {\n    return {\n      events: this.eventBuffer.slice(-limit),\n    }\n  }\n\n  /**\n   * Add event to circular buffer\n   * @internal\n   */\n  private addToEventBuffer(event: any): void {\n    this.eventBuffer.push(event)\n    if (this.eventBuffer.length > this.maxBufferSize) {\n      this.eventBuffer.shift()\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 423, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/telemetry/singleton.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/telemetry/singleton.ts"],"sourcesContent":["/**\n * TelemetryService singleton manager used within Synapse SDK.\n * Sets up and provides a single global TelemetryService instance.\n * #initGlobalTelemetry is the entry point.\n * #getGlobalTelemetry is the expected access point within Synapse.\n * (Consumers outside of Synapse should use `synapse.telemetry`.)\n *\n * This class handles:\n * - Instantiating the TelemetryService instance.\n * - Hooking telemetry into `fetch` by wrapping it.\n * - Flushing/closing telemetry at shutdown or loss of browser focus.\n *\n * Notes:\n * - The underlying Sentry instance handles uncaught exceptions and unhandled promise rejections.\n *   No special setup is done here.\n *   See https://docs.sentry.io/platforms/javascript/troubleshooting/#third-party-promise-libraries\n * - Synapse-special error handling done in `src/utils/index.ts` is made \"telemetry aware\" by exporting `src/telemetry/utils.ts#createError()`,\n *   which wraps `src/utils/errors.ts`.\n *   `src/telemetry/utils.ts` accesses the global TelemetryService instance.\n * - A TelemetryService instance is managed as a singleton with static accessors\n *   rather than as an instance of the Synapse class,\n *   because there are cases where telemetry is needed but there is no Synapse instance available.\n *   `src/utils/errors.ts` is one such case.\n */\n\nimport { type TelemetryConfig, type TelemetryRuntimeContext, TelemetryService } from './service.ts'\nimport { isBrowser } from './utils.ts'\n\n// Global telemetry instance\nlet telemetryInstance: TelemetryService | null = null\n\n/**\n * @returns The global TelemetryService instance or null if not initialized\n */\nexport function getGlobalTelemetry(): TelemetryService | null {\n  return telemetryInstance\n}\n\n/**\n * Initialize the global TelemetryService instance if telemetry isn't disabled.\n * @param telemetryContext\n * @param telemetryConfig\n */\nexport async function initGlobalTelemetry(\n  telemetryConfig: TelemetryConfig,\n  telemetryContext: TelemetryRuntimeContext\n): Promise<void> {\n  if (!shouldEnableTelemetry(telemetryConfig, telemetryContext)) {\n    return\n  }\n\n  telemetryInstance = new TelemetryService()\n  await telemetryInstance.initSentry(telemetryConfig, telemetryContext)\n  wrapFetch()\n  setupShutdownHooks()\n}\n\n/**\n * Remove the global telemetry instance\n * This should handle all cleanup of telemetry resources.\n */\nexport function removeGlobalTelemetry(flush: boolean = true): void {\n  if (telemetryInstance == null) {\n    return\n  }\n  if (flush) {\n    void telemetryInstance?.sentry?.flush().catch(() => {\n      // Silently ignore telemetry flush errors\n    })\n  }\n  unwrapFetch()\n  telemetryInstance = null\n}\n\n/**\n * Determine if telemetry should be enabled based on configuration and environment settings.\n * Disablement takes precedence over enablement.\n * The ways to disable include setting any of the following:\n * - synapseConfig.telemetry.sentryInitOptions.enabled = false\n * - global.SYNAPSE_TELEMETRY_DISABLED = true\n * - process.env.SYNAPSE_TELEMETRY_DISABLED = true\n * We also disable if process.env.NODE_ENV == 'test', unless enablement was explicitly requested in config.\n * We only enable by default if not otherwise disabled above AND we're on the calibration network.\n * @param telemetryConfig - User-provided telemetry configuration\n * @param telemetryContext - Runtime context for telemetry, including network info.\n * @returns True if telemetry should be enabled\n */\nfunction shouldEnableTelemetry(telemetryConfig: TelemetryConfig, telemetryContext: TelemetryRuntimeContext): boolean {\n  // If explicitly disabled by user config, respect that\n  if (telemetryConfig?.sentryInitOptions?.enabled === false) {\n    return false\n  }\n\n  // If disabled by `SYNAPSE_TELEMETRY_DISABLED` environment/global variable, respect that\n  if (isTelemetryDisabledByEnv()) {\n    return false\n  }\n\n  // If in test environment, disable telemetry unless explicitly enabled by user config\n  if (telemetryConfig?.sentryInitOptions?.enabled === undefined) {\n    // we use playwright-test, which sets globalThis.PW_TEST in browser, and NODE_ENV in node\n    if (globalThis.process?.env?.NODE_ENV === 'test' || (globalThis as any).PW_TEST != null) {\n      return false\n    }\n  }\n\n  // If explicitly enabled by user config, respect that\n  if (telemetryConfig?.sentryInitOptions?.enabled === true) {\n    return true\n  }\n\n  // At this point we haven't been given a clear signal to enable or disable.\n  // In this case, we enable telemetry if we're on the calibration network.\n  return telemetryContext.filecoinNetwork === 'calibration'\n}\n\n/**\n * Check if telemetry is explicitly disabled via global variable or environment\n * Uses globalThis for consistent cross-platform access\n */\nfunction isTelemetryDisabledByEnv(): boolean {\n  // Check for global disable flag (universal)\n  if (typeof globalThis !== 'undefined') {\n    // Check for explicit disable flag\n    if ((globalThis as any).SYNAPSE_TELEMETRY_DISABLED === true) {\n      return true\n    }\n\n    // Check environment variable in Node.js\n    if ('process' in globalThis) {\n      const process = (globalThis as any).process\n      if (process?.env) {\n        const disabled = process.env.SYNAPSE_TELEMETRY_DISABLED\n        if (typeof disabled === 'string' && disabled.trim().toLowerCase() === 'true') {\n          return true\n        }\n      }\n    }\n  }\n\n  return false\n}\n\nfunction setupShutdownHooks(opts: { timeoutMs?: number } = {}) {\n  const g = globalThis as any\n  const timeout = opts.timeoutMs ?? 2000\n  let shuttingDown = false\n\n  if (isBrowser) {\n    /**\n     * We `flush` in the browser instead of `close` because users might come back to this page later, and we don't want to add\n     * \"pageShow\" event handlers and re-instantiation logic.\n     */\n    const flush = () => {\n      // Don't block; Sentry will use sendBeacon/fetch keepalive under the hood.\n      void telemetryInstance?.sentry?.flush(timeout).catch(() => {\n        // Silently ignore telemetry flush errors\n      })\n    }\n\n    // Most reliable on modern browsers & iOS Safari:\n    g.window.addEventListener('pagehide', flush, { capture: true })\n    g.document.addEventListener(\n      'visibilitychange',\n      () => {\n        if (g.document.visibilityState === 'hidden') flush()\n      },\n      { capture: true }\n    )\n\n    // Fallbacks for older browsers:\n    g.window.addEventListener('beforeunload', flush, { capture: true })\n    g.window.addEventListener('unload', flush, { capture: true })\n  } else {\n    // Node runtime\n    /**\n     * For Node.js, we only handle explicit termination signals.\n     * We `close` in Node.js instead of `flush` because the process is actually exiting and we don't need to worry about handling the \"users coming back\" situation like we do in the browser.\n     */\n    const handleSignal = () => {\n      if (shuttingDown) return\n      shuttingDown = true\n\n      // Close the sentry to release resources\n      void telemetryInstance?.sentry\n        ?.close(timeout)\n        .finally(() => {\n          shuttingDown = false\n          removeGlobalTelemetry(false) // Remove the global telemetry instance to prevent further telemetry\n        })\n        .catch(() => {\n          // silently ignore error\n        })\n    }\n\n    process.on('exit', handleSignal)\n    process.on('beforeExit', handleSignal)\n    process.on('SIGINT', handleSignal)\n    process.on('SIGTERM', handleSignal)\n    process.on('SIGQUIT', handleSignal)\n  }\n}\n\nconst originalFetch = (globalThis as any).fetch as typeof fetch\nlet isFetchWrapped = false\n/**\n * Patches `globalThis.fetch` to add manual telemetry tracking for all HTTP requests.\n * This wrapper is safe to call multiple times as it will only wrap once.\n *\n * Implementation: This function explicitly creates a [Sentry span](https://docs.sentry.io/platforms/javascript/tracing/span-metrics/)\n * for every `fetch` call by wrapping each request in `sentry.startSpan()`. The span captures HTTP metadata\n * including method, URL, status code, and content length.\n *\n * Behavior:\n * - If telemetry is disabled or not initialized, the wrapper immediately delegates to the original `fetch`\n * - If telemetry is enabled, creates a new span with op=\"http.client\" and name=\"${METHOD} ${URL}\"\n * - Captures request attributes (URL, method, hostname, port) before the fetch\n * - Captures response attributes (status code, content length) after the fetch\n * - Returns the original fetch response unchanged\n *\n * Why this is needed: We have explicitly disabled Sentry's automatic fetch instrumentation\n * (by limiting enabled integrations in service.ts). This manual wrapper gives us full control\n * over which HTTP requests are tracked and what attributes are captured for each span.\n *\n * See: https://docs.sentry.io/platforms/javascript/tracing/instrumentation/requests-module/#wrap-http-requests-in-a-span\n * See: https://docs.sentry.io/platforms/javascript/guides/node/tracing/instrumentation/requests-module/#wrap-http-requests-in-a-span\n */\nfunction wrapFetch(): void {\n  if (isFetchWrapped) {\n    return // Already wrapped\n  }\n\n  isFetchWrapped = true\n\n  ;(globalThis as any).fetch = async function wrappedFetch(\n    input: string | URL | Request,\n    init?: RequestInit\n  ): Promise<Response> {\n    // Short circuit to the original fetch if telemetry is disabled\n    const sentry = getGlobalTelemetry()?.sentry\n    if (!sentry) {\n      return originalFetch(input, init)\n    }\n    const url = input instanceof Request ? new URL(input.url) : new URL(input.toString())\n    const method = input instanceof Request ? input.method : init?.method || 'GET'\n    return await sentry.startSpan({ op: 'http.client', name: `${method} ${url}` }, async (span) => {\n      span.setAttributes({\n        'url.path': url.pathname,\n        'url.full': url.toString(),\n        'server.address': url.hostname,\n        'http.request.method': method,\n        'server.port': url.port || undefined,\n        'location.origin': isBrowser ? (globalThis as any).location?.origin : undefined,\n      })\n      const response = await originalFetch(input, init)\n      span.setAttributes({\n        'http.response.status_code': response.status,\n        'http.response_content_length': response.headers.get('content-length')\n          ? Number(response.headers.get('content-length'))\n          : undefined,\n      })\n      return response\n    })\n  }\n}\n\n/**\n * Unwrap what was done in `wrapFetch()`.\n * Useful for testing or when telemetry should be disabled.\n */\nfunction unwrapFetch(): void {\n  if (!isFetchWrapped) {\n    return\n  }\n\n  ;(globalThis as any).fetch = originalFetch\n  isFetchWrapped = false\n}\n"],"names":[],"mappings":";;;;;;;;AAyBA,OAAO,EAAsD,gBAAgB,EAAE,MAAM,cAAc,CAAA;AACnG,OAAO,EAAE,SAAS,EAAE,MAAM,YAAY,CAAA;;;AAGtC,IAAI,iBAAiB,GAA4B,IAAI,CAAA;AAK/C,SAAU,kBAAkB;IAChC,OAAO,iBAAiB,CAAA;AAC1B,CAAC;AAOM,KAAK,UAAU,mBAAmB,CACvC,eAAgC,EAChC,gBAAyC;IAEzC,IAAI,CAAC,qBAAqB,CAAC,eAAe,EAAE,gBAAgB,CAAC,EAAE,CAAC;QAC9D,OAAM;IACR,CAAC;IAED,iBAAiB,GAAG,IAAI,8NAAgB,EAAE,CAAA;IAC1C,MAAM,iBAAiB,CAAC,UAAU,CAAC,eAAe,EAAE,gBAAgB,CAAC,CAAA;IACrE,SAAS,EAAE,CAAA;IACX,kBAAkB,EAAE,CAAA;AACtB,CAAC;AAMK,SAAU,qBAAqB,CAAC,QAAiB,IAAI;IACzD,IAAI,iBAAiB,IAAI,IAAI,EAAE,CAAC;QAC9B,OAAM;IACR,CAAC;IACD,IAAI,KAAK,EAAE,CAAC;QACV,KAAK,iBAAiB,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,KAAK,CAAC,GAAG,EAAE,AAEnD,CAAC,CAAC,CAAA;IACJ,CAAC;IACD,WAAW,EAAE,CAAA;IACb,iBAAiB,GAAG,IAAI,CAAA;AAC1B,CAAC;AAeD,SAAS,qBAAqB,CAAC,eAAgC,EAAE,gBAAyC;IAExG,IAAI,eAAe,EAAE,iBAAiB,EAAE,OAAO,KAAK,KAAK,EAAE,CAAC;QAC1D,OAAO,KAAK,CAAA;IACd,CAAC;IAGD,IAAI,wBAAwB,EAAE,EAAE,CAAC;QAC/B,OAAO,KAAK,CAAA;IACd,CAAC;IAGD,IAAI,eAAe,EAAE,iBAAiB,EAAE,OAAO,KAAK,SAAS,EAAE,CAAC;QAE9D,IAAI,UAAU,CAAC,OAAO,EAAE,GAAG,EAAE,QAAQ,KAAK,MAAM,IAAK,UAAkB,CAAC,OAAO,IAAI,IAAI,EAAE,CAAC;YACxF,OAAO,KAAK,CAAA;QACd,CAAC;IACH,CAAC;IAGD,IAAI,eAAe,EAAE,iBAAiB,EAAE,OAAO,KAAK,IAAI,EAAE,CAAC;QACzD,OAAO,IAAI,CAAA;IACb,CAAC;IAID,OAAO,gBAAgB,CAAC,eAAe,KAAK,aAAa,CAAA;AAC3D,CAAC;AAMD,SAAS,wBAAwB;IAE/B,IAAI,OAAO,UAAU,KAAK,WAAW,EAAE,CAAC;QAEtC,IAAK,UAAkB,CAAC,0BAA0B,KAAK,IAAI,EAAE,CAAC;YAC5D,OAAO,IAAI,CAAA;QACb,CAAC;QAGD,IAAI,SAAS,IAAI,UAAU,EAAE,CAAC;YAC5B,MAAM,OAAO,IAAI,UAAkB,CAAC,OAAO,CAAA;YAC3C,IAAI,OAAO,GAAE,GAAG,EAAE,CAAC;gBACjB,MAAM,QAAQ,GAAG,OAAO,EAAC,GAAG,CAAC,0BAA0B,CAAA;gBACvD,IAAI,OAAO,QAAQ,KAAK,QAAQ,IAAI,QAAQ,CAAC,IAAI,EAAE,CAAC,WAAW,EAAE,KAAK,MAAM,EAAE,CAAC;oBAC7E,OAAO,IAAI,CAAA;gBACb,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IAED,OAAO,KAAK,CAAA;AACd,CAAC;AAED,SAAS,kBAAkB,CAAC,OAA+B,CAAA,CAAE;IAC3D,MAAM,CAAC,GAAG,UAAiB,CAAA;IAC3B,MAAM,OAAO,GAAG,IAAI,CAAC,SAAS,IAAI,IAAI,CAAA;IACtC,IAAI,YAAY,GAAG,KAAK,CAAA;IAExB,IAAI,qNAAS,EAAE,CAAC;QAKd,MAAM,KAAK,GAAG,GAAG,EAAE;YAEjB,KAAK,iBAAiB,EAAE,MAAM,EAAE,KAAK,CAAC,OAAO,CAAC,CAAC,KAAK,CAAC,GAAG,EAAE,AAE1D,CAAC,CAAC,CAAA;QACJ,CAAC,CAAA;QAGD,CAAC,CAAC,MAAM,CAAC,gBAAgB,CAAC,UAAU,EAAE,KAAK,EAAE;YAAE,OAAO,EAAE,IAAI;QAAA,CAAE,CAAC,CAAA;QAC/D,CAAC,CAAC,QAAQ,CAAC,gBAAgB,CACzB,kBAAkB,EAClB,GAAG,EAAE;YACH,IAAI,CAAC,CAAC,QAAQ,CAAC,eAAe,KAAK,QAAQ,EAAE,KAAK,EAAE,CAAA;QACtD,CAAC,EACD;YAAE,OAAO,EAAE,IAAI;QAAA,CAAE,CAClB,CAAA;QAGD,CAAC,CAAC,MAAM,CAAC,gBAAgB,CAAC,cAAc,EAAE,KAAK,EAAE;YAAE,OAAO,EAAE,IAAI;QAAA,CAAE,CAAC,CAAA;QACnE,CAAC,CAAC,MAAM,CAAC,gBAAgB,CAAC,QAAQ,EAAE,KAAK,EAAE;YAAE,OAAO,EAAE,IAAI;QAAA,CAAE,CAAC,CAAA;IAC/D,CAAC,MAAM,CAAC;QAMN,MAAM,YAAY,GAAG,GAAG,EAAE;YACxB,IAAI,YAAY,EAAE,OAAM;YACxB,YAAY,GAAG,IAAI,CAAA;YAGnB,KAAK,iBAAiB,EAAE,MAAM,EAC1B,KAAK,CAAC,OAAO,CAAC,CACf,OAAO,CAAC,GAAG,EAAE;gBACZ,YAAY,GAAG,KAAK,CAAA;gBACpB,qBAAqB,CAAC,KAAK,CAAC,CAAA;YAC9B,CAAC,CAAC,CACD,KAAK,CAAC,GAAG,EAAE,AAEZ,CAAC,CAAC,CAAA;QACN,CAAC,CAAA;QAED,OAAO,CAAC,EAAE,CAAC,MAAM,EAAE,YAAY,CAAC,CAAA;QAChC,OAAO,CAAC,EAAE,CAAC,YAAY,EAAE,YAAY,CAAC,CAAA;QACtC,OAAO,CAAC,EAAE,CAAC,QAAQ,EAAE,YAAY,CAAC,CAAA;QAClC,OAAO,CAAC,EAAE,CAAC,SAAS,EAAE,YAAY,CAAC,CAAA;QACnC,OAAO,CAAC,EAAE,CAAC,SAAS,EAAE,YAAY,CAAC,CAAA;IACrC,CAAC;AACH,CAAC;AAED,MAAM,aAAa,GAAI,UAAkB,CAAC,KAAqB,CAAA;AAC/D,IAAI,cAAc,GAAG,KAAK,CAAA;AAuB1B,SAAS,SAAS;IAChB,IAAI,cAAc,EAAE,CAAC;QACnB,OAAM;IACR,CAAC;IAED,cAAc,GAAG,IAAI,CAEpB;IAAC,UAAkB,CAAC,KAAK,GAAG,KAAK,UAAU,YAAY,CACtD,KAA6B,EAC7B,IAAkB;QAGlB,MAAM,MAAM,GAAG,kBAAkB,EAAE,EAAE,MAAM,CAAA;QAC3C,IAAI,CAAC,MAAM,EAAE,CAAC;YACZ,OAAO,aAAa,CAAC,KAAK,EAAE,IAAI,CAAC,CAAA;QACnC,CAAC;QACD,MAAM,GAAG,GAAG,KAAK,YAAY,OAAO,CAAC,CAAC,CAAC,IAAI,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,GAAG,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC,CAAA;QACrF,MAAM,MAAM,GAAG,KAAK,YAAY,OAAO,CAAC,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,EAAE,MAAM,IAAI,KAAK,CAAA;QAC9E,OAAO,MAAM,MAAM,CAAC,SAAS,CAAC;YAAE,EAAE,EAAE,aAAa;YAAE,IAAI,EAAE,GAAG,MAAM,CAAA,CAAA,EAAI,GAAG,EAAE;QAAA,CAAE,EAAE,KAAK,EAAE,IAAI,EAAE,EAAE;YAC5F,IAAI,CAAC,aAAa,CAAC;gBACjB,UAAU,EAAE,GAAG,CAAC,QAAQ;gBACxB,UAAU,EAAE,GAAG,CAAC,QAAQ,EAAE;gBAC1B,gBAAgB,EAAE,GAAG,CAAC,QAAQ;gBAC9B,qBAAqB,EAAE,MAAM;gBAC7B,aAAa,EAAE,GAAG,CAAC,IAAI,IAAI,SAAS;gBACpC,iBAAiB,EAAE,qNAAS,CAAC,CAAC,CAAE,UAAkB,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC,CAAC,SAAS;aAChF,CAAC,CAAA;YACF,MAAM,QAAQ,GAAG,MAAM,aAAa,CAAC,KAAK,EAAE,IAAI,CAAC,CAAA;YACjD,IAAI,CAAC,aAAa,CAAC;gBACjB,2BAA2B,EAAE,QAAQ,CAAC,MAAM;gBAC5C,8BAA8B,EAAE,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,gBAAgB,CAAC,GAClE,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,gBAAgB,CAAC,CAAC,GAC9C,SAAS;aACd,CAAC,CAAA;YACF,OAAO,QAAQ,CAAA;QACjB,CAAC,CAAC,CAAA;IACJ,CAAC,CAAA;AACH,CAAC;AAMD,SAAS,WAAW;IAClB,IAAI,CAAC,cAAc,EAAE,CAAC;QACpB,OAAM;IACR,CAAC;;IAEC,UAAkB,CAAC,KAAK,GAAG,aAAa,CAAA;IAC1C,cAAc,GAAG,KAAK,CAAA;AACxB,CAAC"}},
    {"offset": {"line": 577, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/utils/errors.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/utils/errors.ts"],"sourcesContent":["import { getGlobalTelemetry } from '../telemetry/singleton.ts'\n\n/**\n * Utility function to create descriptive errors with context\n */\nexport function createError(prefix: string, operation: string, details: string, originalError?: unknown): Error {\n  let baseMessage = `${prefix} ${operation} failed: ${details}`\n\n  // If there's an original error, append its message to provide full context\n  if (originalError != null && originalError instanceof Error) {\n    baseMessage = `${baseMessage} - ${originalError.message}`\n  }\n  let finalError: Error\n  if (originalError != null) {\n    finalError = new Error(baseMessage, { cause: originalError })\n  } else {\n    finalError = new Error(baseMessage)\n  }\n\n  // Capture to telemetry if enabled\n  // Generic error handling of uncaught errors is [configured automatically by Sentry](https://docs.sentry.io/platforms/javascript/troubleshooting/#third-party-promise-libraries).\n  getGlobalTelemetry()?.sentry?.captureException(finalError, {\n    tags: { operation: `${prefix}.${operation}` },\n    extra: {\n      synapseErrorPrefix: prefix,\n      synapseErrorOperation: operation,\n      synapseErrorDetails: details,\n      originalError,\n    },\n  })\n\n  return finalError\n}\n"],"names":[],"mappings":";;;;AAAA,OAAO,EAAE,kBAAkB,EAAE,MAAM,2BAA2B,CAAA;;AAKxD,SAAU,WAAW,CAAC,MAAc,EAAE,SAAiB,EAAE,OAAe,EAAE,aAAuB;IACrG,IAAI,WAAW,GAAG,GAAG,MAAM,CAAA,CAAA,EAAI,SAAS,CAAA,SAAA,EAAY,OAAO,EAAE,CAAA;IAG7D,IAAI,aAAa,IAAI,IAAI,IAAI,aAAa,YAAY,KAAK,EAAE,CAAC;QAC5D,WAAW,GAAG,GAAG,WAAW,CAAA,GAAA,EAAM,aAAa,CAAC,OAAO,EAAE,CAAA;IAC3D,CAAC;IACD,IAAI,UAAiB,CAAA;IACrB,IAAI,aAAa,IAAI,IAAI,EAAE,CAAC;QAC1B,UAAU,GAAG,IAAI,KAAK,CAAC,WAAW,EAAE;YAAE,KAAK,EAAE,aAAa;QAAA,CAAE,CAAC,CAAA;IAC/D,CAAC,MAAM,CAAC;QACN,UAAU,GAAG,IAAI,KAAK,CAAC,WAAW,CAAC,CAAA;IACrC,CAAC;QAID,kOAAkB,EAAE,GAAE,MAAM,EAAE,gBAAgB,CAAC,UAAU,EAAE;QACzD,IAAI,EAAE;YAAE,SAAS,EAAE,GAAG,MAAM,CAAA,CAAA,EAAI,SAAS,EAAE;QAAA,CAAE;QAC7C,KAAK,EAAE;YACL,kBAAkB,EAAE,MAAM;YAC1B,qBAAqB,EAAE,SAAS;YAChC,mBAAmB,EAAE,OAAO;YAC5B,aAAa;SACd;KACF,CAAC,CAAA;IAEF,OAAO,UAAU,CAAA;AACnB,CAAC"}},
    {"offset": {"line": 613, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/utils/epoch.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/utils/epoch.ts"],"sourcesContent":["/**\n * Epoch to date conversion utilities for Filecoin networks\n */\n\nimport type { ethers } from 'ethers'\nimport type { FilecoinNetworkType } from '../types.ts'\nimport { GENESIS_TIMESTAMPS, TIME_CONSTANTS } from './constants.ts'\nimport { createError } from './index.ts'\n\n/**\n * Convert a Filecoin epoch to a JavaScript Date\n * @param epoch - The epoch number to convert\n * @param network - The Filecoin network (mainnet or calibration)\n * @returns Date object representing the epoch time\n */\nexport function epochToDate(epoch: number, network: FilecoinNetworkType): Date {\n  const genesisTimestamp = GENESIS_TIMESTAMPS[network]\n  const epochDuration = TIME_CONSTANTS.EPOCH_DURATION\n  const timestampSeconds = genesisTimestamp + epoch * epochDuration\n  return new Date(timestampSeconds * 1000) // Convert to milliseconds\n}\n\n/**\n * Convert a JavaScript Date to a Filecoin epoch\n * @param date - The date to convert\n * @param network - The Filecoin network (mainnet or calibration)\n * @returns The epoch number (rounded down to nearest epoch)\n */\nexport function dateToEpoch(date: Date, network: FilecoinNetworkType): number {\n  const genesisTimestamp = GENESIS_TIMESTAMPS[network]\n  const epochDuration = TIME_CONSTANTS.EPOCH_DURATION\n  const timestampSeconds = Math.floor(date.getTime() / 1000)\n  const secondsSinceGenesis = timestampSeconds - genesisTimestamp\n  return Math.floor(secondsSinceGenesis / epochDuration)\n}\n\n/**\n * Get the genesis timestamp for a network\n * @param network - The Filecoin network\n * @returns Genesis timestamp in seconds (Unix timestamp)\n */\nexport function getGenesisTimestamp(network: FilecoinNetworkType): number {\n  return GENESIS_TIMESTAMPS[network]\n}\n\n/**\n * Calculate the time until a future epoch\n * @param futureEpoch - The future epoch number\n * @param currentEpoch - The current epoch number\n * @returns Object with time until the epoch in various units\n */\nexport function timeUntilEpoch(\n  futureEpoch: number,\n  currentEpoch: number\n): {\n  epochs: number\n  seconds: number\n  minutes: number\n  hours: number\n  days: number\n} {\n  const epochDifference = futureEpoch - currentEpoch\n  const seconds = epochDifference * TIME_CONSTANTS.EPOCH_DURATION\n\n  return {\n    epochs: epochDifference,\n    seconds,\n    minutes: seconds / 60,\n    hours: seconds / 3600,\n    days: seconds / 86400,\n  }\n}\n\n/**\n * Calculate when the last proof should have been submitted based on current time\n * @param nextChallengeEpoch - The next challenge epoch from the data set\n * @param maxProvingPeriod - The maximum proving period in epochs\n * @param network - The Filecoin network\n * @returns Date when the last proof should have been submitted, or null if no proof submitted yet\n */\nexport function calculateLastProofDate(\n  nextChallengeEpoch: number,\n  maxProvingPeriod: number,\n  network: FilecoinNetworkType\n): Date | null {\n  // If nextChallengeEpoch is 0, no proofs scheduled\n  if (nextChallengeEpoch === 0) {\n    return null\n  }\n\n  // The last proof should have been submitted before the current proving period started\n  // Current proving period starts at nextChallengeEpoch - maxProvingPeriod\n  const lastProofEpoch = nextChallengeEpoch - maxProvingPeriod\n\n  // If this is negative, we're in the first proving period\n  if (lastProofEpoch <= 0) {\n    return null\n  }\n\n  return epochToDate(lastProofEpoch, network)\n}\n\n/**\n * Get the current epoch from the blockchain\n * @internal This is an internal utility, not part of the public API\n * @param provider - The ethers provider to query\n * @returns The current epoch as a bigint\n */\nexport async function getCurrentEpoch(provider: ethers.Provider): Promise<bigint> {\n  const blockNumber: number = await provider.getBlockNumber()\n  if (blockNumber == null) {\n    throw createError('epoch', 'getCurrentEpoch', 'Failed to get latest block number')\n  }\n  // In Filecoin, the block number is the epoch\n  return BigInt(blockNumber)\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAMA,OAAO,EAAE,kBAAkB,EAAE,cAAc,EAAE,MAAM,gBAAgB,CAAA;;AACnE,OAAO,EAAE,WAAW,EAAE,MAAM,YAAY,CAAA;;;AAQlC,SAAU,WAAW,CAAC,KAAa,EAAE,OAA4B;IACrE,MAAM,gBAAgB,GAAG,8NAAkB,CAAC,OAAO,CAAC,CAAA;IACpD,MAAM,aAAa,GAAG,0NAAc,CAAC,cAAc,CAAA;IACnD,MAAM,gBAAgB,GAAG,gBAAgB,GAAG,KAAK,GAAG,aAAa,CAAA;IACjE,OAAO,IAAI,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,CAAA;AAC1C,CAAC;AAQK,SAAU,WAAW,CAAC,IAAU,EAAE,OAA4B;IAClE,MAAM,gBAAgB,GAAG,8NAAkB,CAAC,OAAO,CAAC,CAAA;IACpD,MAAM,aAAa,GAAG,0NAAc,CAAC,cAAc,CAAA;IACnD,MAAM,gBAAgB,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,EAAE,GAAG,IAAI,CAAC,CAAA;IAC1D,MAAM,mBAAmB,GAAG,gBAAgB,GAAG,gBAAgB,CAAA;IAC/D,OAAO,IAAI,CAAC,KAAK,CAAC,mBAAmB,GAAG,aAAa,CAAC,CAAA;AACxD,CAAC;AAOK,SAAU,mBAAmB,CAAC,OAA4B;IAC9D,OAAO,8NAAkB,CAAC,OAAO,CAAC,CAAA;AACpC,CAAC;AAQK,SAAU,cAAc,CAC5B,WAAmB,EACnB,YAAoB;IAQpB,MAAM,eAAe,GAAG,WAAW,GAAG,YAAY,CAAA;IAClD,MAAM,OAAO,GAAG,eAAe,GAAG,0NAAc,CAAC,cAAc,CAAA;IAE/D,OAAO;QACL,MAAM,EAAE,eAAe;QACvB,OAAO;QACP,OAAO,EAAE,OAAO,GAAG,EAAE;QACrB,KAAK,EAAE,OAAO,GAAG,IAAI;QACrB,IAAI,EAAE,OAAO,GAAG,KAAK;KACtB,CAAA;AACH,CAAC;AASK,SAAU,sBAAsB,CACpC,kBAA0B,EAC1B,gBAAwB,EACxB,OAA4B;IAG5B,IAAI,kBAAkB,KAAK,CAAC,EAAE,CAAC;QAC7B,OAAO,IAAI,CAAA;IACb,CAAC;IAID,MAAM,cAAc,GAAG,kBAAkB,GAAG,gBAAgB,CAAA;IAG5D,IAAI,cAAc,IAAI,CAAC,EAAE,CAAC;QACxB,OAAO,IAAI,CAAA;IACb,CAAC;IAED,OAAO,WAAW,CAAC,cAAc,EAAE,OAAO,CAAC,CAAA;AAC7C,CAAC;AAQM,KAAK,UAAU,eAAe,CAAC,QAAyB;IAC7D,MAAM,WAAW,GAAW,MAAM,QAAQ,CAAC,cAAc,EAAE,CAAA;IAC3D,IAAI,WAAW,IAAI,IAAI,EAAE,CAAC;QACxB,UAAM,oNAAW,EAAC,OAAO,EAAE,iBAAiB,EAAE,mCAAmC,CAAC,CAAA;IACpF,CAAC;IAED,OAAO,MAAM,CAAC,WAAW,CAAC,CAAA;AAC5B,CAAC"}},
    {"offset": {"line": 680, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/utils/metadata.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/utils/metadata.ts"],"sourcesContent":["import type { MetadataEntry } from '../types.ts'\nimport { METADATA_KEYS } from './constants.ts'\n\n// Metadata size and count limits from the contract\nexport const METADATA_LIMITS = {\n  MAX_KEY_LENGTH: 32,\n  MAX_VALUE_LENGTH: 128,\n  MAX_KEYS_PER_DATASET: 10,\n  MAX_KEYS_PER_PIECE: 5,\n}\n\n/**\n * Converts a metadata object to an ordered array of MetadataEntry objects.\n * Keys are sorted alphabetically for deterministic ordering.\n *\n * @param metadata - The metadata object to convert\n * @returns Array of MetadataEntry objects with sorted keys\n */\nexport function objectToEntries(metadata: Record<string, string>): MetadataEntry[] {\n  return Object.entries(metadata)\n    .sort(([a], [b]) => a.localeCompare(b)) // Deterministic ordering for signing\n    .map(([key, value]) => ({ key, value }))\n}\n\n/**\n * Converts an array of MetadataEntry objects to a prototype-safe object.\n * Uses Object.create(null) to avoid prototype pollution risks.\n *\n * @param entries - Array of MetadataEntry objects\n * @returns A prototype-safe Record<string, string>\n */\nexport function entriesToObject(entries: MetadataEntry[]): Record<string, string> {\n  const obj: Record<string, string> = Object.create(null)\n  for (const { key, value } of entries) {\n    obj[key] = value\n  }\n  return obj\n}\n\n/**\n * Validates metadata for data set creation against contract limits.\n * Accepts both MetadataEntry[] and Record<string, string> formats.\n * Throws descriptive errors if validation fails.\n *\n * @param metadata - The metadata to validate (array or object)\n * @throws Error if metadata exceeds contract limits\n */\nexport function validateDataSetMetadata(metadata: MetadataEntry[] | Record<string, string>): void {\n  // Convert to array format for validation\n  const metadataArray = Array.isArray(metadata) ? metadata : objectToEntries(metadata)\n  if (metadataArray.length > METADATA_LIMITS.MAX_KEYS_PER_DATASET) {\n    throw new Error(\n      `Too many metadata keys for data set: ${metadataArray.length} (max: ${METADATA_LIMITS.MAX_KEYS_PER_DATASET})`\n    )\n  }\n\n  for (const { key, value } of metadataArray) {\n    if (key.length > METADATA_LIMITS.MAX_KEY_LENGTH) {\n      throw new Error(\n        `Metadata key \"${key}\" exceeds max length: ${key.length} bytes (max: ${METADATA_LIMITS.MAX_KEY_LENGTH})`\n      )\n    }\n    if (value.length > METADATA_LIMITS.MAX_VALUE_LENGTH) {\n      throw new Error(\n        `Metadata value for key \"${key}\" exceeds max length: ${value.length} bytes (max: ${METADATA_LIMITS.MAX_VALUE_LENGTH})`\n      )\n    }\n  }\n}\n\n/**\n * Validates metadata for piece addition against contract limits.\n * Accepts both MetadataEntry[] and Record<string, string> formats.\n * Throws descriptive errors if validation fails.\n *\n * @param metadata - The metadata to validate (array or object)\n * @throws Error if metadata exceeds contract limits\n */\nexport function validatePieceMetadata(metadata: MetadataEntry[] | Record<string, string>): void {\n  // Convert to array format for validation\n  const metadataArray = Array.isArray(metadata) ? metadata : objectToEntries(metadata)\n  if (metadataArray.length > METADATA_LIMITS.MAX_KEYS_PER_PIECE) {\n    throw new Error(\n      `Too many metadata keys for piece: ${metadataArray.length} (max: ${METADATA_LIMITS.MAX_KEYS_PER_PIECE})`\n    )\n  }\n\n  for (const { key, value } of metadataArray) {\n    if (key.length > METADATA_LIMITS.MAX_KEY_LENGTH) {\n      throw new Error(\n        `Metadata key \"${key}\" exceeds max length: ${key.length} bytes (max: ${METADATA_LIMITS.MAX_KEY_LENGTH})`\n      )\n    }\n    if (value.length > METADATA_LIMITS.MAX_VALUE_LENGTH) {\n      throw new Error(\n        `Metadata value for key \"${key}\" exceeds max length: ${value.length} bytes (max: ${METADATA_LIMITS.MAX_VALUE_LENGTH})`\n      )\n    }\n  }\n}\n\n/**\n * Checks if a data set's metadata exactly matches the requested metadata.\n *\n * The data set must contain exactly the same keys and values as requested.\n * Order doesn't matter, but the sets must be identical.\n *\n * @param dataSetMetadata - The metadata from the data set\n * @param requestedMetadata - The metadata requirements to match\n * @returns true if metadata sets are exactly equal (same keys and values)\n */\nexport function metadataMatches(\n  dataSetMetadata: Record<string, string>,\n  requestedMetadata: Record<string, string>\n): boolean {\n  const dataSetKeys = Object.keys(dataSetMetadata)\n  const requestedKeys = Object.keys(requestedMetadata)\n\n  if (dataSetKeys.length !== requestedKeys.length) {\n    return false\n  }\n\n  if (requestedKeys.length === 0) {\n    return true\n  }\n\n  for (const key of requestedKeys) {\n    if (dataSetMetadata[key] !== requestedMetadata[key]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * Combines metadata object with withCDN flag, ensuring consistent behavior.\n * If withCDN is true, adds the withCDN key only if not already present.\n * If withCDN is false or undefined, returns metadata unchanged.\n *\n * @param metadata - Base metadata object (can be empty)\n * @param withCDN - Whether to include CDN flag\n * @returns Combined metadata object\n */\nexport function combineMetadata(metadata: Record<string, string> = {}, withCDN?: boolean): Record<string, string> {\n  // If no CDN preference or already has withCDN key, return as-is\n  if (withCDN == null || METADATA_KEYS.WITH_CDN in metadata) {\n    return metadata\n  }\n\n  // Add withCDN key only if explicitly requested\n  if (withCDN) {\n    return { ...metadata, [METADATA_KEYS.WITH_CDN]: '' }\n  }\n\n  return metadata\n}\n\n/**\n * Converts a boolean withCDN flag to metadata format for backward compatibility.\n *\n * @param withCDN - Whether to request CDN support\n * @returns MetadataEntry array with withCDN key if true, empty array if false\n */\nexport function withCDNToMetadata(withCDN: boolean): MetadataEntry[] {\n  if (withCDN) {\n    return [{ key: METADATA_KEYS.WITH_CDN, value: '' }]\n  }\n  return []\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 790, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/utils/network.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/utils/network.ts"],"sourcesContent":["/**\n * Network utilities for Filecoin network detection and validation\n */\n\nimport type { ethers } from 'ethers'\nimport type { FilecoinNetworkType } from '../types.ts'\nimport { CHAIN_IDS } from './constants.ts'\nimport { createError } from './index.ts'\n\n/**\n * Extract and validate FilecoinNetworkType from an ethers Provider\n *\n * Uses chainId for network detection since the actual network name from ethers\n * will be something like \"Filecoin Calibration Testnet\" rather than just \"calibration\".\n *\n * @param provider - Ethers provider to get network from\n * @returns Promise resolving to validated FilecoinNetworkType\n * @throws Error if the network is not supported\n */\nexport async function getFilecoinNetworkType(provider: ethers.Provider): Promise<FilecoinNetworkType> {\n  try {\n    const network = await provider.getNetwork()\n    const chainId = Number(network.chainId)\n\n    if (chainId === CHAIN_IDS.mainnet) {\n      return 'mainnet'\n    } else if (chainId === CHAIN_IDS.calibration) {\n      return 'calibration'\n    } else {\n      throw createError(\n        'NetworkUtils',\n        'getFilecoinNetworkType',\n        `Unsupported network: chain ID ${chainId}. Only Filecoin mainnet (${CHAIN_IDS.mainnet}) and calibration (${CHAIN_IDS.calibration}) are supported.`\n      )\n    }\n  } catch (error) {\n    if (error instanceof Error && error.message.includes('Unsupported network')) {\n      throw error // Re-throw our own error\n    }\n    throw createError(\n      'NetworkUtils',\n      'getFilecoinNetworkType',\n      `Failed to detect network: ${error instanceof Error ? error.message : String(error)}`\n    )\n  }\n}\n"],"names":[],"mappings":";;;;AAMA,OAAO,EAAE,SAAS,EAAE,MAAM,gBAAgB,CAAA;;AAC1C,OAAO,EAAE,WAAW,EAAE,MAAM,YAAY,CAAA;;;AAYjC,KAAK,UAAU,sBAAsB,CAAC,QAAyB;IACpE,IAAI,CAAC;QACH,MAAM,OAAO,GAAG,MAAM,QAAQ,CAAC,UAAU,EAAE,CAAA;QAC3C,MAAM,OAAO,GAAG,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,CAAA;QAEvC,IAAI,OAAO,KAAK,qNAAS,CAAC,OAAO,EAAE,CAAC;YAClC,OAAO,SAAS,CAAA;QAClB,CAAC,MAAM,IAAI,OAAO,KAAK,qNAAS,CAAC,WAAW,EAAE,CAAC;YAC7C,OAAO,aAAa,CAAA;QACtB,CAAC,MAAM,CAAC;YACN,UAAM,oNAAW,EACf,cAAc,EACd,wBAAwB,EACxB,CAAA,8BAAA,EAAiC,OAAO,CAAA,yBAAA,EAA4B,qNAAS,CAAC,OAAO,CAAA,mBAAA,EAAsB,qNAAS,CAAC,WAAW,CAAA,gBAAA,CAAkB,CACnJ,CAAA;QACH,CAAC;IACH,CAAC,CAAC,OAAO,KAAK,EAAE,CAAC;QACf,IAAI,KAAK,YAAY,KAAK,IAAI,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,qBAAqB,CAAC,EAAE,CAAC;YAC5E,MAAM,KAAK,CAAA;QACb,CAAC;QACD,UAAM,oNAAW,EACf,cAAc,EACd,wBAAwB,EACxB,CAAA,0BAAA,EAA6B,KAAK,YAAY,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,CACtF,CAAA;IACH,CAAC;AACH,CAAC"}},
    {"offset": {"line": 821, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/utils/piece.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/utils/piece.ts"],"sourcesContent":["/**\n * Piece URL construction utilities\n *\n * These utilities help construct URLs for interacting with PDP servers\n * for piece discovery and retrieval operations.\n */\n\nimport type { PieceCID } from '../types.ts'\n\n/**\n * Construct a piece retrieval URL\n * @param retrievalEndpoint - The base retrieval endpoint URL\n * @param pieceCid - The PieceCID identifier\n * @returns Full URL for retrieving the piece\n */\nexport function constructPieceUrl(retrievalEndpoint: string, pieceCid: PieceCID): string {\n  const endpoint = retrievalEndpoint.replace(/\\/$/, '')\n  return `${endpoint}/piece/${pieceCid.toString()}`\n}\n\n/**\n * Construct a piece discovery (findPiece) URL\n * @param apiEndpoint - The base API endpoint URL\n * @param pieceCid - The PieceCID identifier\n * @returns Full URL for finding the piece\n */\nexport function constructFindPieceUrl(apiEndpoint: string, pieceCid: PieceCID): string {\n  const endpoint = apiEndpoint.replace(/\\/$/, '')\n  const params = new URLSearchParams({ pieceCid: pieceCid.toString() })\n  return `${endpoint}/pdp/piece?${params.toString()}`\n}\n"],"names":[],"mappings":";;;;;;AAeM,SAAU,iBAAiB,CAAC,iBAAyB,EAAE,QAAkB;IAC7E,MAAM,QAAQ,GAAG,iBAAiB,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAA;IACrD,OAAO,GAAG,QAAQ,CAAA,OAAA,EAAU,QAAQ,CAAC,QAAQ,EAAE,EAAE,CAAA;AACnD,CAAC;AAQK,SAAU,qBAAqB,CAAC,WAAmB,EAAE,QAAkB;IAC3E,MAAM,QAAQ,GAAG,WAAW,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAA;IAC/C,MAAM,MAAM,GAAG,IAAI,eAAe,CAAC;QAAE,QAAQ,EAAE,QAAQ,CAAC,QAAQ,EAAE;IAAA,CAAE,CAAC,CAAA;IACrE,OAAO,GAAG,QAAQ,CAAA,WAAA,EAAc,MAAM,CAAC,QAAQ,EAAE,EAAE,CAAA;AACrD,CAAC"}},
    {"offset": {"line": 842, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/utils/index.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/utils/index.ts"],"sourcesContent":["export * from './constants.ts'\nexport { EIP712_ENCODED_TYPES, EIP712_TYPE_HASHES, EIP712_TYPES } from './eip712.ts'\nexport * from './epoch.ts'\nexport { createError } from './errors.ts'\nexport { combineMetadata, metadataMatches } from './metadata.ts'\nexport { getFilecoinNetworkType } from './network.ts'\nexport { constructFindPieceUrl, constructPieceUrl } from './piece.ts'\n"],"names":[],"mappings":";AAAA,cAAc,gBAAgB,CAAA;AAC9B,OAAO,EAAE,oBAAoB,EAAE,kBAAkB,EAAE,YAAY,EAAE,MAAM,aAAa,CAAA;AACpF,cAAc,YAAY,CAAA;AAC1B,OAAO,EAAE,WAAW,EAAE,MAAM,aAAa,CAAA;AACzC,OAAO,EAAE,eAAe,EAAE,eAAe,EAAE,MAAM,eAAe,CAAA;AAChE,OAAO,EAAE,sBAAsB,EAAE,MAAM,cAAc,CAAA;AACrD,OAAO,EAAE,qBAAqB,EAAE,iBAAiB,EAAE,MAAM,YAAY,CAAA"}},
    {"offset": {"line": 861, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/payments/service.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/payments/service.ts"],"sourcesContent":["/**\n * PaymentsService - Consolidated interface for all Payments contract operations\n * along with some additional token related utilities.\n */\n\nimport { ethers } from 'ethers'\nimport type { RailInfo, SettlementResult, TokenAmount, TokenIdentifier } from '../types.ts'\nimport {\n  CHAIN_IDS,\n  CONTRACT_ABIS,\n  CONTRACT_ADDRESSES,\n  createError,\n  EIP2612_PERMIT_TYPES,\n  getCurrentEpoch,\n  getFilecoinNetworkType,\n  SETTLEMENT_FEE,\n  TIMING_CONSTANTS,\n  TOKENS,\n} from '../utils/index.ts'\n\n/**\n * Options for deposit operation\n */\nexport interface DepositOptions {\n  /** Optional recipient address (defaults to signer address if not provided) */\n  to?: string\n  /** Called when checking current allowance */\n  onAllowanceCheck?: (current: bigint, required: bigint) => void\n  /** Called when approval transaction is sent */\n  onApprovalTransaction?: (tx: ethers.TransactionResponse) => void\n  /** Called when approval is confirmed */\n  onApprovalConfirmed?: (receipt: ethers.TransactionReceipt) => void\n  /** Called before deposit transaction is sent */\n  onDepositStarting?: () => void\n}\n\nexport class PaymentsService {\n  private readonly _provider: ethers.Provider\n  private readonly _signer: ethers.Signer\n  private readonly _paymentsAddress: string\n  private readonly _usdfcAddress: string\n  private readonly _disableNonceManager: boolean\n  // Cached contract instances\n  private _usdfcContract: ethers.Contract | null = null\n  private _paymentsContract: ethers.Contract | null = null\n\n  /**\n   * @param provider - Direct provider instance for balance checks, nonce management, and epoch calculations\n   * @param signer - Signer instance for transaction signing (may be wrapped in NonceManager)\n   * @param paymentsAddress - Address of the Payments contract\n   * @param usdfcAddress - Address of the USDFC token contract\n   * @param disableNonceManager - When true, manually manages nonces using provider.getTransactionCount()\n   *\n   * Note: Both provider and signer are required for NonceManager compatibility. When NonceManager\n   * is disabled, we need direct provider access for reliable nonce management. Using signer.provider\n   * could interfere with NonceManager's internal state or behave differently with MetaMask/hardware wallets.\n   */\n  constructor(\n    provider: ethers.Provider,\n    signer: ethers.Signer,\n    paymentsAddress: string,\n    usdfcAddress: string,\n    disableNonceManager: boolean\n  ) {\n    this._provider = provider\n    this._signer = signer\n    this._paymentsAddress = paymentsAddress\n    this._usdfcAddress = usdfcAddress\n    this._disableNonceManager = disableNonceManager\n  }\n\n  /**\n   * Get cached USDFC contract instance or create new one\n   */\n  private _getUsdfcContract(): ethers.Contract {\n    if (this._usdfcContract == null) {\n      this._usdfcContract = new ethers.Contract(this._usdfcAddress, CONTRACT_ABIS.ERC20, this._signer)\n    }\n    return this._usdfcContract\n  }\n\n  /**\n   * Get cached payments contract instance or create new one\n   */\n  private _getPaymentsContract(): ethers.Contract {\n    if (this._paymentsContract == null) {\n      this._paymentsContract = new ethers.Contract(this._paymentsAddress, CONTRACT_ABIS.PAYMENTS, this._signer)\n    }\n    return this._paymentsContract\n  }\n\n  /**\n   * Generate EIP-2612 permit signature for USDFC token\n   * Handles balance check, domain creation, nonce retrieval, and signature generation\n   * Uses Multicall3 to batch RPC calls for efficiency\n   * @param amount - Amount to permit\n   * @param deadline - Unix timestamp (seconds) when the permit expires\n   * @param contextName - Context name for error messages (e.g., 'depositWithPermit')\n   * @returns Signature object\n   */\n  private async _getPermitSignature(amount: bigint, deadline: bigint, contextName: string): Promise<ethers.Signature> {\n    const signerAddress = await this._signer.getAddress()\n\n    // Get network type (validates network and makes single getNetwork() call internally)\n    const networkType = await getFilecoinNetworkType(this._provider)\n\n    // Derive chainId from network type\n    const chainId = CHAIN_IDS[networkType]\n\n    // Setup Multicall3 for batched RPC calls\n    const multicall3Address = CONTRACT_ADDRESSES.MULTICALL3[networkType]\n    const multicall = new ethers.Contract(multicall3Address, CONTRACT_ABIS.MULTICALL3, this._provider)\n\n    // Create interfaces for encoding/decoding\n    const erc20Interface = new ethers.Interface(CONTRACT_ABIS.ERC20)\n    const permitInterface = new ethers.Interface(CONTRACT_ABIS.ERC20_PERMIT)\n\n    // Prepare multicall batch: balanceOf, name, version (with fallback), nonces\n    const calls = [\n      {\n        target: this._usdfcAddress,\n        allowFailure: false,\n        callData: erc20Interface.encodeFunctionData('balanceOf', [signerAddress]),\n      },\n      {\n        target: this._usdfcAddress,\n        allowFailure: false,\n        callData: erc20Interface.encodeFunctionData('name'),\n      },\n      {\n        target: this._usdfcAddress,\n        allowFailure: true, // Allow failure for version, we'll fallback to '1'\n        callData: permitInterface.encodeFunctionData('version'),\n      },\n      {\n        target: this._usdfcAddress,\n        allowFailure: false,\n        callData: permitInterface.encodeFunctionData('nonces', [signerAddress]),\n      },\n    ]\n\n    // Execute multicall\n    let results: any[]\n    try {\n      results = await multicall.aggregate3.staticCall(calls)\n    } catch (error) {\n      throw createError(\n        'PaymentsService',\n        contextName,\n        'Failed to fetch token information for permit. Ensure token contract is reachable.',\n        error\n      )\n    }\n\n    // Decode results\n    // Result 0: balanceOf\n    let usdfcBalance: bigint\n    try {\n      const decoded = erc20Interface.decodeFunctionResult('balanceOf', results[0].returnData)\n      usdfcBalance = decoded[0]\n    } catch (error) {\n      throw createError('PaymentsService', contextName, 'Failed to decode token balance.', error)\n    }\n\n    // Check balance\n    if (usdfcBalance < amount) {\n      throw createError(\n        'PaymentsService',\n        contextName,\n        `Insufficient USDFC: have ${usdfcBalance.toString()}, need ${amount.toString()}`\n      )\n    }\n\n    // Result 1: name\n    let tokenName: string\n    try {\n      const decoded = erc20Interface.decodeFunctionResult('name', results[1].returnData)\n      tokenName = decoded[0]\n    } catch (error) {\n      throw createError(\n        'PaymentsService',\n        contextName,\n        'Failed to read token name for permit domain. Ensure token contract is reachable.',\n        error\n      )\n    }\n\n    // Result 2: version (with fallback)\n    let domainVersion = '1'\n    if (results[2].success) {\n      try {\n        const decoded = permitInterface.decodeFunctionResult('version', results[2].returnData)\n        const maybeVersion = decoded[0]\n        if (typeof maybeVersion === 'string' && maybeVersion.length > 0) {\n          domainVersion = maybeVersion\n        }\n      } catch {\n        // silently fallback to '1'\n      }\n    }\n\n    // Result 3: nonces\n    let nonce: bigint\n    try {\n      const decoded = permitInterface.decodeFunctionResult('nonces', results[3].returnData)\n      nonce = decoded[0]\n    } catch (error) {\n      throw createError(\n        'PaymentsService',\n        contextName,\n        'Token does not appear to support EIP-2612 permit (nonces() unavailable).',\n        error\n      )\n    }\n\n    // Build EIP-2612 permit domain\n    const domain = {\n      name: tokenName,\n      version: domainVersion,\n      chainId,\n      verifyingContract: this._usdfcAddress,\n    }\n\n    // Create permit value\n    const value = {\n      owner: signerAddress,\n      spender: this._paymentsAddress,\n      value: amount,\n      nonce,\n      deadline,\n    }\n\n    // Sign typed data\n    let signatureHex: string\n    try {\n      signatureHex = await this._signer.signTypedData(domain, EIP2612_PERMIT_TYPES, value)\n    } catch (error) {\n      throw createError(\n        'PaymentsService',\n        contextName,\n        'Failed to sign EIP-2612 permit. Ensure your wallet supports typed data signing.',\n        error\n      )\n    }\n\n    return ethers.Signature.from(signatureHex)\n  }\n\n  async balance(token: TokenIdentifier = TOKENS.USDFC): Promise<bigint> {\n    // For now, only support USDFC balance\n    if (token !== TOKENS.USDFC) {\n      throw createError(\n        'PaymentsService',\n        'payments contract balance check',\n        `Token \"${token}\" is not supported. Currently only USDFC token is supported for payments contract balance queries.`\n      )\n    }\n\n    const accountInfo = await this.accountInfo(token)\n    return accountInfo.availableFunds\n  }\n\n  /**\n   * Get detailed account information from the payments contract\n   * @param token - The token to get account info for (defaults to USDFC)\n   * @returns Account information including funds, lockup details, and available balance\n   */\n  async accountInfo(token: TokenIdentifier = TOKENS.USDFC): Promise<{\n    funds: bigint\n    lockupCurrent: bigint\n    lockupRate: bigint\n    lockupLastSettledAt: bigint\n    availableFunds: bigint\n  }> {\n    if (token !== TOKENS.USDFC) {\n      throw createError(\n        'PaymentsService',\n        'account info',\n        `Token \"${token}\" is not supported. Currently only USDFC token is supported.`\n      )\n    }\n\n    const signerAddress = await this._signer.getAddress()\n    const paymentsContract = this._getPaymentsContract()\n\n    let accountData: any[]\n\n    try {\n      // Get account info from payments contract\n      accountData = await paymentsContract.accounts(this._usdfcAddress, signerAddress)\n    } catch (contractCallError) {\n      throw createError(\n        'PaymentsService',\n        'account info',\n        'Failed to read account information from payments contract. This could indicate the contract is not properly deployed, the ABI is incorrect, or there are network connectivity issues.',\n        contractCallError\n      )\n    }\n\n    // accountData returns: (uint256 funds, uint256 lockupCurrent, uint256 lockupRate, uint256 lockupLastSettledAt)\n    const [funds, lockupCurrent, lockupRate, lockupLastSettledAt] = accountData\n\n    // Calculate time-based lockup\n    const currentEpoch = await getCurrentEpoch(this._provider)\n    const epochsSinceSettlement = currentEpoch - BigInt(lockupLastSettledAt)\n    const actualLockup = BigInt(lockupCurrent) + BigInt(lockupRate) * epochsSinceSettlement\n\n    // Calculate available funds\n    const availableFunds = BigInt(funds) - actualLockup\n\n    return {\n      funds: BigInt(funds),\n      lockupCurrent: BigInt(lockupCurrent),\n      lockupRate: BigInt(lockupRate),\n      lockupLastSettledAt: BigInt(lockupLastSettledAt),\n      availableFunds: availableFunds > 0n ? availableFunds : 0n,\n    }\n  }\n\n  async walletBalance(token?: TokenIdentifier): Promise<bigint> {\n    // If no token specified or FIL is requested, return native wallet balance\n    if (token == null || token === TOKENS.FIL) {\n      try {\n        const address = await this._signer.getAddress()\n        const balance = await this._provider.getBalance(address)\n        return balance\n      } catch (error) {\n        throw createError(\n          'PaymentsService',\n          'wallet FIL balance check',\n          'Unable to retrieve FIL balance from wallet. This could be due to network connectivity issues, RPC endpoint problems, or wallet connection issues.',\n          error\n        )\n      }\n    }\n\n    // Handle ERC20 token balance\n    if (token === TOKENS.USDFC) {\n      try {\n        const address = await this._signer.getAddress()\n        const usdfcContract = this._getUsdfcContract()\n        const balance = await usdfcContract.balanceOf(address)\n        return balance\n      } catch (error) {\n        throw createError(\n          'PaymentsService',\n          'wallet USDFC balance check',\n          'Unexpected error while checking USDFC token balance in wallet.',\n          error\n        )\n      }\n    }\n\n    // For other tokens, throw error\n    throw createError(\n      'PaymentsService',\n      'wallet balance',\n      `Token \"${token}\" is not supported. Currently only FIL and USDFC tokens are supported.`\n    )\n  }\n\n  decimals(_token: TokenIdentifier = TOKENS.USDFC): number {\n    // Both FIL and USDFC use 18 decimals\n    return 18\n  }\n\n  /**\n   * Check the current ERC20 token allowance for a spender\n   * @param spender - The address to check allowance for\n   * @param token - The token to check allowance for (defaults to USDFC)\n   * @returns The current allowance amount as bigint\n   */\n  async allowance(spender: string, token: TokenIdentifier = TOKENS.USDFC): Promise<bigint> {\n    if (token !== TOKENS.USDFC) {\n      throw createError(\n        'PaymentsService',\n        'allowance',\n        `Token \"${token}\" is not supported. Currently only USDFC token is supported.`\n      )\n    }\n\n    const signerAddress = await this._signer.getAddress()\n    const usdfcContract = this._getUsdfcContract()\n\n    try {\n      const currentAllowance = await usdfcContract.allowance(signerAddress, spender)\n      return currentAllowance\n    } catch (error) {\n      throw createError(\n        'PaymentsService',\n        'allowance check',\n        'Failed to check token allowance. This could indicate network connectivity issues or an invalid spender address.',\n        error\n      )\n    }\n  }\n\n  /**\n   * Approve an ERC20 token spender\n   * @param spender - The address to approve as spender\n   * @param amount - The amount to approve\n   * @param token - The token to approve spending for (defaults to USDFC)\n   * @returns Transaction response object\n   */\n  async approve(\n    spender: string,\n    amount: TokenAmount,\n    token: TokenIdentifier = TOKENS.USDFC\n  ): Promise<ethers.TransactionResponse> {\n    if (token !== TOKENS.USDFC) {\n      throw createError(\n        'PaymentsService',\n        'approve',\n        `Token \"${token}\" is not supported. Currently only USDFC token is supported.`\n      )\n    }\n\n    const approveAmount = typeof amount === 'bigint' ? amount : BigInt(amount)\n    if (approveAmount < 0n) {\n      throw createError('PaymentsService', 'approve', 'Approval amount cannot be negative')\n    }\n\n    const signerAddress = await this._signer.getAddress()\n    const usdfcContract = this._getUsdfcContract()\n\n    // Only set explicit nonce if NonceManager is disabled\n    const txOptions: any = {}\n    if (this._disableNonceManager) {\n      const approvalNonce = await this._provider.getTransactionCount(signerAddress, 'pending')\n      txOptions.nonce = approvalNonce\n    }\n\n    try {\n      const approveTx = await usdfcContract.approve(spender, approveAmount, txOptions)\n      return approveTx\n    } catch (error) {\n      throw createError(\n        'PaymentsService',\n        'approve',\n        `Failed to approve ${spender} to spend ${approveAmount.toString()} ${token}`,\n        error\n      )\n    }\n  }\n\n  /**\n   * Approve a service contract to act as an operator for payment rails\n   * This allows the service contract (such as Warm Storage) to create and manage payment rails on behalf\n   * of the client\n   * @param service - The service contract address to approve\n   * @param rateAllowance - Maximum payment rate per epoch the operator can set\n   * @param lockupAllowance - Maximum lockup amount the operator can set\n   * @param maxLockupPeriod - Maximum lockup period in epochs the operator can set\n   * @param token - The token to approve for (defaults to USDFC)\n   * @returns Transaction response object\n   */\n  async approveService(\n    service: string,\n    rateAllowance: TokenAmount,\n    lockupAllowance: TokenAmount,\n    maxLockupPeriod: TokenAmount,\n    token: TokenIdentifier = TOKENS.USDFC\n  ): Promise<ethers.TransactionResponse> {\n    if (token !== TOKENS.USDFC) {\n      throw createError(\n        'PaymentsService',\n        'approveService',\n        `Token \"${token}\" is not supported. Currently only USDFC token is supported.`\n      )\n    }\n\n    const rateAllowanceBigint = typeof rateAllowance === 'bigint' ? rateAllowance : BigInt(rateAllowance)\n    const lockupAllowanceBigint = typeof lockupAllowance === 'bigint' ? lockupAllowance : BigInt(lockupAllowance)\n    const maxLockupPeriodBigint = typeof maxLockupPeriod === 'bigint' ? maxLockupPeriod : BigInt(maxLockupPeriod)\n\n    if (rateAllowanceBigint < 0n || lockupAllowanceBigint < 0n || maxLockupPeriodBigint < 0n) {\n      throw createError('PaymentsService', 'approveService', 'Allowance values cannot be negative')\n    }\n\n    const signerAddress = await this._signer.getAddress()\n    const paymentsContract = this._getPaymentsContract()\n\n    // Only set explicit nonce if NonceManager is disabled\n    const txOptions: any = {}\n    if (this._disableNonceManager) {\n      const currentNonce = await this._provider.getTransactionCount(signerAddress, 'pending')\n      txOptions.nonce = currentNonce\n    }\n\n    try {\n      const approveTx = await paymentsContract.setOperatorApproval(\n        this._usdfcAddress,\n        service,\n        true, // approved\n        rateAllowanceBigint,\n        lockupAllowanceBigint,\n        maxLockupPeriodBigint,\n        txOptions\n      )\n      return approveTx\n    } catch (error) {\n      throw createError(\n        'PaymentsService',\n        'approveService',\n        `Failed to approve service ${service} as operator for ${token}`,\n        error\n      )\n    }\n  }\n\n  /**\n   * Revoke a service contract's operator approval\n   * @param service - The service contract address to revoke\n   * @param token - The token to revoke approval for (defaults to USDFC)\n   * @returns Transaction response object\n   */\n  async revokeService(service: string, token: TokenIdentifier = TOKENS.USDFC): Promise<ethers.TransactionResponse> {\n    if (token !== TOKENS.USDFC) {\n      throw createError(\n        'PaymentsService',\n        'revokeService',\n        `Token \"${token}\" is not supported. Currently only USDFC token is supported.`\n      )\n    }\n\n    const signerAddress = await this._signer.getAddress()\n    const paymentsContract = this._getPaymentsContract()\n\n    // Only set explicit nonce if NonceManager is disabled\n    const txOptions: any = {}\n    if (this._disableNonceManager) {\n      const currentNonce = await this._provider.getTransactionCount(signerAddress, 'pending')\n      txOptions.nonce = currentNonce\n    }\n\n    try {\n      const revokeTx = await paymentsContract.setOperatorApproval(\n        this._usdfcAddress,\n        service,\n        false, // not approved\n        0n, // zero rate allowance\n        0n, // zero lockup allowance\n        0n, // zero max lockup period\n        txOptions\n      )\n      return revokeTx\n    } catch (error) {\n      throw createError(\n        'PaymentsService',\n        'revokeService',\n        `Failed to revoke service ${service} as operator for ${token}`,\n        error\n      )\n    }\n  }\n\n  /**\n   * Get the operator approval status and allowances for a service\n   * @param service - The service contract address to check\n   * @param token - The token to check approval for (defaults to USDFC)\n   * @returns Approval status and allowances\n   */\n  async serviceApproval(\n    service: string,\n    token: TokenIdentifier = TOKENS.USDFC\n  ): Promise<{\n    isApproved: boolean\n    rateAllowance: bigint\n    rateUsed: bigint\n    lockupAllowance: bigint\n    lockupUsed: bigint\n    maxLockupPeriod: bigint\n  }> {\n    if (token !== TOKENS.USDFC) {\n      throw createError(\n        'PaymentsService',\n        'serviceApproval',\n        `Token \"${token}\" is not supported. Currently only USDFC token is supported.`\n      )\n    }\n\n    const signerAddress = await this._signer.getAddress()\n    const paymentsContract = this._getPaymentsContract()\n\n    try {\n      const approval = await paymentsContract.operatorApprovals(this._usdfcAddress, signerAddress, service)\n      return {\n        isApproved: approval[0],\n        rateAllowance: approval[1],\n        lockupAllowance: approval[2],\n        rateUsed: approval[3],\n        lockupUsed: approval[4],\n        maxLockupPeriod: approval[5],\n      }\n    } catch (error) {\n      throw createError(\n        'PaymentsService',\n        'serviceApproval',\n        `Failed to check service approval status for ${service}`,\n        error\n      )\n    }\n  }\n\n  async deposit(\n    amount: TokenAmount,\n    token: TokenIdentifier = TOKENS.USDFC,\n    options?: DepositOptions\n  ): Promise<ethers.TransactionResponse> {\n    // Only support USDFC for now\n    if (token !== TOKENS.USDFC) {\n      throw createError('PaymentsService', 'deposit', `Unsupported token: ${token}`)\n    }\n\n    const depositAmountBigint = typeof amount === 'bigint' ? amount : BigInt(amount)\n    if (depositAmountBigint <= 0n) {\n      throw createError('PaymentsService', 'deposit', 'Invalid amount')\n    }\n\n    const signerAddress = await this._signer.getAddress()\n    const depositTo = options?.to ?? signerAddress\n    const usdfcContract = this._getUsdfcContract()\n    const paymentsContract = this._getPaymentsContract()\n\n    // Check balance\n    const usdfcBalance = await usdfcContract.balanceOf(signerAddress)\n\n    if (usdfcBalance < depositAmountBigint) {\n      throw createError(\n        'PaymentsService',\n        'deposit',\n        `Insufficient USDFC: have ${BigInt(usdfcBalance).toString()}, need ${depositAmountBigint.toString()}`\n      )\n    }\n\n    // Check and update allowance if needed\n    const currentAllowance = await this.allowance(this._paymentsAddress, token)\n    options?.onAllowanceCheck?.(currentAllowance, depositAmountBigint)\n\n    if (currentAllowance < depositAmountBigint) {\n      // Golden path: automatically approve the exact amount needed\n      const approveTx = await this.approve(this._paymentsAddress, depositAmountBigint, token)\n      options?.onApprovalTransaction?.(approveTx)\n\n      // Wait for approval to be mined before proceeding\n      const approvalReceipt = await approveTx.wait(TIMING_CONSTANTS.TRANSACTION_CONFIRMATIONS)\n      if (approvalReceipt != null) {\n        options?.onApprovalConfirmed?.(approvalReceipt)\n      }\n    }\n\n    // Check if account has sufficient available balance (no frozen account check needed for deposits)\n\n    // Notify that deposit is starting\n    options?.onDepositStarting?.()\n\n    // Only set explicit nonce if NonceManager is disabled\n    const txOptions: any = {}\n    if (this._disableNonceManager) {\n      const currentNonce = await this._provider.getTransactionCount(signerAddress, 'pending')\n      txOptions.nonce = currentNonce\n    }\n\n    const depositTx = await paymentsContract.deposit(this._usdfcAddress, depositTo, depositAmountBigint, txOptions)\n\n    return depositTx\n  }\n\n  /**\n   * Deposit funds using ERC-2612 permit to approve and deposit in a single transaction\n   * This method creates an EIP-712 typed-data signature for the USDFC token's permit,\n   * then calls the Payments contract `depositWithPermit` to pull funds and credit the account.\n   *\n   * @param amount - Amount of USDFC to deposit (in base units)\n   * @param token - Token identifier (currently only USDFC is supported)\n   * @param deadline - Unix timestamp (seconds) when the permit expires. Defaults to now + 1 hour.\n   * @returns Transaction response object\n   */\n  async depositWithPermit(\n    amount: TokenAmount,\n    token: TokenIdentifier = TOKENS.USDFC,\n    deadline?: number | bigint\n  ): Promise<ethers.TransactionResponse> {\n    // Only support USDFC for now\n    if (token !== TOKENS.USDFC) {\n      throw createError('PaymentsService', 'depositWithPermit', `Unsupported token: ${token}`)\n    }\n\n    const depositAmountBigint = typeof amount === 'bigint' ? amount : BigInt(amount)\n    if (depositAmountBigint <= 0n) {\n      throw createError('PaymentsService', 'depositWithPermit', 'Invalid amount')\n    }\n\n    const signerAddress = await this._signer.getAddress()\n    const paymentsContract = this._getPaymentsContract()\n\n    // Calculate deadline\n    const permitDeadline: bigint =\n      deadline == null\n        ? BigInt(Math.floor(Date.now() / 1000) + TIMING_CONSTANTS.PERMIT_DEADLINE_DURATION)\n        : BigInt(deadline)\n\n    // Get permit signature (includes balance check, domain, nonce, signing)\n    const signature = await this._getPermitSignature(depositAmountBigint, permitDeadline, 'depositWithPermit')\n\n    // Only set explicit nonce if NonceManager is disabled\n    const txOptions: any = {}\n    if (this._disableNonceManager) {\n      const currentNonce = await this._provider.getTransactionCount(signerAddress, 'pending')\n      txOptions.nonce = currentNonce\n    }\n\n    try {\n      const tx = await paymentsContract.depositWithPermit(\n        this._usdfcAddress,\n        signerAddress,\n        depositAmountBigint,\n        permitDeadline,\n        signature.v,\n        signature.r,\n        signature.s,\n        txOptions\n      )\n      return tx\n    } catch (error) {\n      throw createError(\n        'PaymentsService',\n        'depositWithPermit',\n        'Failed to execute depositWithPermit on Payments contract.',\n        error\n      )\n    }\n  }\n\n  /**\n   * Deposit funds using ERC-2612 permit and approve an operator in a single transaction\n   * This signs an EIP-712 permit for the USDFC token and calls the Payments contract\n   * function `depositWithPermitAndApproveOperator` which both deposits and sets operator approval.\n   *\n   * @param amount - Amount of USDFC to deposit (in base units)\n   * @param operator - Service/operator address to approve\n   * @param rateAllowance - Max payment rate per epoch operator can set\n   * @param lockupAllowance - Max lockup amount operator can set\n   * @param maxLockupPeriod - Max lockup period in epochs operator can set\n   * @param token - Token identifier (currently only USDFC supported)\n   * @param deadline - Unix timestamp (seconds) when the permit expires. Defaults to now + 1 hour.\n   * @returns Transaction response object\n   */\n  async depositWithPermitAndApproveOperator(\n    amount: TokenAmount,\n    operator: string,\n    rateAllowance: TokenAmount,\n    lockupAllowance: TokenAmount,\n    maxLockupPeriod: bigint,\n    token: TokenIdentifier = TOKENS.USDFC,\n    deadline?: number | bigint\n  ): Promise<ethers.TransactionResponse> {\n    // Only support USDFC for now\n    if (token !== TOKENS.USDFC) {\n      throw createError('PaymentsService', 'depositWithPermitAndApproveOperator', `Unsupported token: ${token}`)\n    }\n\n    const depositAmountBigint = typeof amount === 'bigint' ? amount : BigInt(amount)\n    if (depositAmountBigint <= 0n) {\n      throw createError('PaymentsService', 'depositWithPermitAndApproveOperator', 'Invalid amount')\n    }\n\n    const rateAllowanceBigint = typeof rateAllowance === 'bigint' ? rateAllowance : BigInt(rateAllowance)\n    const lockupAllowanceBigint = typeof lockupAllowance === 'bigint' ? lockupAllowance : BigInt(lockupAllowance)\n    const maxLockupPeriodBigint = typeof maxLockupPeriod === 'bigint' ? maxLockupPeriod : BigInt(maxLockupPeriod)\n    if (rateAllowanceBigint < 0n || lockupAllowanceBigint < 0n || maxLockupPeriodBigint < 0n) {\n      throw createError('PaymentsService', 'depositWithPermitAndApproveOperator', 'Allowance values cannot be negative')\n    }\n\n    const signerAddress = await this._signer.getAddress()\n    const paymentsContract = this._getPaymentsContract()\n\n    // Calculate deadline\n    const permitDeadline: bigint =\n      deadline == null\n        ? BigInt(Math.floor(Date.now() / 1000) + TIMING_CONSTANTS.PERMIT_DEADLINE_DURATION)\n        : BigInt(deadline)\n\n    // Get permit signature (includes balance check, domain, nonce, signing)\n    const signature = await this._getPermitSignature(\n      depositAmountBigint,\n      permitDeadline,\n      'depositWithPermitAndApproveOperator'\n    )\n\n    // Only set explicit nonce if NonceManager is disabled\n    const txOptions: any = {}\n    if (this._disableNonceManager) {\n      const currentNonce = await this._provider.getTransactionCount(signerAddress, 'pending')\n      txOptions.nonce = currentNonce\n    }\n\n    try {\n      const tx = await paymentsContract.depositWithPermitAndApproveOperator(\n        this._usdfcAddress,\n        signerAddress,\n        depositAmountBigint,\n        permitDeadline,\n        signature.v,\n        signature.r,\n        signature.s,\n        operator,\n        rateAllowanceBigint,\n        lockupAllowanceBigint,\n        maxLockupPeriodBigint,\n        txOptions\n      )\n      return tx\n    } catch (error) {\n      throw createError(\n        'PaymentsService',\n        'depositWithPermitAndApproveOperator',\n        'Failed to execute depositWithPermitAndApproveOperator on Payments contract.',\n        error\n      )\n    }\n  }\n\n  async withdraw(amount: TokenAmount, token: TokenIdentifier = TOKENS.USDFC): Promise<ethers.TransactionResponse> {\n    // Only support USDFC for now\n    if (token !== TOKENS.USDFC) {\n      throw createError('PaymentsService', 'withdraw', `Unsupported token: ${token}`)\n    }\n\n    const withdrawAmountBigint = typeof amount === 'bigint' ? amount : BigInt(amount)\n\n    if (withdrawAmountBigint <= 0n) {\n      throw createError('PaymentsService', 'withdraw', 'Invalid amount')\n    }\n\n    const signerAddress = await this._signer.getAddress()\n    const paymentsContract = this._getPaymentsContract()\n\n    // Check balance using the corrected accountInfo method\n    const accountInfo = await this.accountInfo(token)\n\n    if (accountInfo.availableFunds < withdrawAmountBigint) {\n      throw createError(\n        'PaymentsService',\n        'withdraw',\n        `Insufficient available balance: have ${accountInfo.availableFunds.toString()}, need ${withdrawAmountBigint.toString()}`\n      )\n    }\n\n    // Only set explicit nonce if NonceManager is disabled\n    const txOptions: any = {}\n    if (this._disableNonceManager) {\n      const currentNonce = await this._provider.getTransactionCount(signerAddress, 'pending')\n      txOptions.nonce = currentNonce\n    }\n\n    const tx = await paymentsContract.withdraw(this._usdfcAddress, withdrawAmountBigint, txOptions)\n\n    return tx\n  }\n\n  /**\n   * Settle a payment rail up to a specific epoch (sends a transaction)\n   * Note: This method automatically includes the required network fee (FIL) for burning\n   * @param railId - The rail ID to settle\n   * @param untilEpoch - The epoch to settle up to (must be <= current epoch; defaults to current).\n   *                     Can be used for partial settlements to a past epoch.\n   * @returns Transaction response object\n   * @throws Error if untilEpoch is in the future (contract reverts with CannotSettleFutureEpochs)\n   */\n  async settle(railId: number | bigint, untilEpoch?: number | bigint): Promise<ethers.TransactionResponse> {\n    const railIdBigint = typeof railId === 'bigint' ? railId : BigInt(railId)\n\n    const [signerAddress, currentEpoch] = await Promise.all([\n      this._signer.getAddress(),\n      untilEpoch == null ? getCurrentEpoch(this._provider) : Promise.resolve(null),\n    ])\n\n    const untilEpochBigint = untilEpoch == null ? (currentEpoch as bigint) : BigInt(untilEpoch)\n\n    const paymentsContract = this._getPaymentsContract()\n\n    // Only set explicit nonce if NonceManager is disabled\n    const txOptions: any = {\n      value: SETTLEMENT_FEE, // Include the settlement fee (NETWORK_FEE in contract) as msg.value\n    }\n    if (this._disableNonceManager) {\n      const currentNonce = await this._provider.getTransactionCount(signerAddress, 'pending')\n      txOptions.nonce = currentNonce\n    }\n\n    try {\n      const tx = await paymentsContract.settleRail(railIdBigint, untilEpochBigint, txOptions)\n      return tx\n    } catch (error) {\n      throw createError(\n        'PaymentsService',\n        'settle',\n        `Failed to settle rail ${railIdBigint.toString()} up to epoch ${untilEpochBigint.toString()}`,\n        error\n      )\n    }\n  }\n\n  /**\n   * Get the expected settlement amounts for a rail (read-only simulation)\n   * Note: The actual settlement will require a network fee (FIL) to be sent with the transaction\n   * @param railId - The rail ID to check\n   * @param untilEpoch - The epoch to settle up to (must be <= current epoch; defaults to current).\n   *                     Can be used to preview partial settlements to a past epoch.\n   * @returns Settlement result with amounts and details\n   */\n  async getSettlementAmounts(railId: number | bigint, untilEpoch?: number | bigint): Promise<SettlementResult> {\n    const railIdBigint = typeof railId === 'bigint' ? railId : BigInt(railId)\n\n    const currentEpoch = untilEpoch == null ? await getCurrentEpoch(this._provider) : null\n\n    const untilEpochBigint = untilEpoch == null ? (currentEpoch as bigint) : BigInt(untilEpoch)\n\n    const paymentsContract = this._getPaymentsContract()\n\n    try {\n      // Use staticCall to simulate the transaction and get the return values\n      // Include the settlement fee (NETWORK_FEE in contract) in the simulation\n      const result = await paymentsContract.settleRail.staticCall(railIdBigint, untilEpochBigint)\n\n      return {\n        totalSettledAmount: result[0],\n        totalNetPayeeAmount: result[1],\n        totalOperatorCommission: result[2],\n        totalNetworkFee: result[3],\n        finalSettledEpoch: result[4],\n        note: result[5],\n      }\n    } catch (error) {\n      throw createError(\n        'PaymentsService',\n        'getSettlementAmounts',\n        `Failed to get settlement amounts for rail ${railIdBigint.toString()} up to epoch ${untilEpochBigint.toString()}`,\n        error\n      )\n    }\n  }\n\n  /**\n   * Emergency settlement for terminated rails only - bypasses service contract validation\n   * This ensures payment even if the validator contract is buggy or unresponsive (pays in full)\n   * Can only be called by the client after the max settlement epoch has passed\n   * @param railId - The rail ID to settle\n   * @returns Transaction response object\n   */\n  async settleTerminatedRail(railId: number | bigint): Promise<ethers.TransactionResponse> {\n    const railIdBigint = typeof railId === 'bigint' ? railId : BigInt(railId)\n    const signerAddress = await this._signer.getAddress()\n    const paymentsContract = this._getPaymentsContract()\n\n    // Only set explicit nonce if NonceManager is disabled\n    const txOptions: any = {}\n    if (this._disableNonceManager) {\n      const currentNonce = await this._provider.getTransactionCount(signerAddress, 'pending')\n      txOptions.nonce = currentNonce\n    }\n\n    try {\n      const tx = await paymentsContract.settleTerminatedRailWithoutValidation(railIdBigint, txOptions)\n      return tx\n    } catch (error) {\n      throw createError(\n        'PaymentsService',\n        'settleTerminatedRail',\n        `Failed to settle terminated rail ${railIdBigint.toString()}`,\n        error\n      )\n    }\n  }\n\n  /**\n   * Get detailed information about a specific rail\n   * @param railId - The rail ID to query\n   * @returns Rail information including all parameters and current state\n   * @throws Error if the rail doesn't exist or is inactive (contract reverts with RailInactiveOrSettled)\n   */\n  async getRail(railId: number | bigint): Promise<{\n    token: string\n    from: string\n    to: string\n    operator: string\n    validator: string\n    paymentRate: bigint\n    lockupPeriod: bigint\n    lockupFixed: bigint\n    settledUpTo: bigint\n    endEpoch: bigint\n    commissionRateBps: bigint\n    serviceFeeRecipient: string\n  }> {\n    const railIdBigint = typeof railId === 'bigint' ? railId : BigInt(railId)\n    const paymentsContract = this._getPaymentsContract()\n\n    try {\n      const rail = await paymentsContract.getRail(railIdBigint)\n      return {\n        token: rail.token,\n        from: rail.from,\n        to: rail.to,\n        operator: rail.operator,\n        validator: rail.validator,\n        paymentRate: rail.paymentRate,\n        lockupPeriod: rail.lockupPeriod,\n        lockupFixed: rail.lockupFixed,\n        settledUpTo: rail.settledUpTo,\n        endEpoch: rail.endEpoch,\n        commissionRateBps: rail.commissionRateBps,\n        serviceFeeRecipient: rail.serviceFeeRecipient,\n      }\n    } catch (error: any) {\n      // Contract reverts with RailInactiveOrSettled error if rail doesn't exist\n      if (error.message?.includes('RailInactiveOrSettled')) {\n        throw createError('PaymentsService', 'getRail', `Rail ${railIdBigint.toString()} does not exist or is inactive`)\n      }\n      throw createError('PaymentsService', 'getRail', `Failed to get rail ${railIdBigint.toString()}`, error)\n    }\n  }\n\n  /**\n   * Automatically settle a rail, detecting whether it's terminated or active\n   * This method checks the rail status and calls the appropriate settlement method:\n   * - For terminated rails: calls settleTerminatedRail()\n   * - For active rails: calls settle() with optional untilEpoch (requires settlement fee)\n   *\n   * @param railId - The rail ID to settle\n   * @param untilEpoch - The epoch to settle up to (must be <= current epoch for active rails; ignored for terminated rails)\n   * @returns Transaction response object\n   * @throws Error if rail doesn't exist (contract reverts with RailInactiveOrSettled) or other settlement errors\n   *\n   * @example\n   * ```javascript\n   * // Automatically detect and settle appropriately\n   * const tx = await synapse.payments.settleAuto(railId)\n   * await tx.wait()\n   *\n   * // For active rails, can specify epoch\n   * const tx = await synapse.payments.settleAuto(railId, specificEpoch)\n   * ```\n   */\n  async settleAuto(railId: number | bigint, untilEpoch?: number | bigint): Promise<ethers.TransactionResponse> {\n    const railIdBigint = typeof railId === 'bigint' ? railId : BigInt(railId)\n\n    // Get rail information to check if terminated\n    const rail = await this.getRail(railIdBigint)\n\n    // Check if rail is terminated (endEpoch > 0 means terminated)\n    if (rail.endEpoch > 0n) {\n      // Rail is terminated, use settleTerminatedRail\n      return await this.settleTerminatedRail(railIdBigint)\n    } else {\n      // Rail is active, use regular settle (requires settlement fee)\n      return await this.settle(railIdBigint, untilEpoch)\n    }\n  }\n\n  /**\n   * Get all rails where the wallet is the payer\n   * @param token - The token to filter by (defaults to USDFC)\n   * @returns Array of rail information\n   */\n  async getRailsAsPayer(token: TokenIdentifier = TOKENS.USDFC): Promise<RailInfo[]> {\n    if (token !== TOKENS.USDFC) {\n      throw createError(\n        'PaymentsService',\n        'getRailsAsPayer',\n        `Token \"${token}\" is not supported. Currently only USDFC token is supported.`\n      )\n    }\n\n    const signerAddress = await this._signer.getAddress()\n    const paymentsContract = this._getPaymentsContract()\n\n    try {\n      const [rails] = await paymentsContract.getRailsForPayerAndToken(signerAddress, this._usdfcAddress, 0n, 0n)\n\n      return rails.map((rail: any) => ({\n        railId: Number(rail.railId),\n        isTerminated: rail.isTerminated,\n        endEpoch: Number(rail.endEpoch),\n      }))\n    } catch (error) {\n      throw createError('PaymentsService', 'getRailsAsPayer', 'Failed to get rails where wallet is payer', error)\n    }\n  }\n\n  /**\n   * Get all rails where the wallet is the payee\n   * @param token - The token to filter by (defaults to USDFC)\n   * @returns Array of rail information\n   */\n  async getRailsAsPayee(token: TokenIdentifier = TOKENS.USDFC): Promise<RailInfo[]> {\n    if (token !== TOKENS.USDFC) {\n      throw createError(\n        'PaymentsService',\n        'getRailsAsPayee',\n        `Token \"${token}\" is not supported. Currently only USDFC token is supported.`\n      )\n    }\n\n    const signerAddress = await this._signer.getAddress()\n    const paymentsContract = this._getPaymentsContract()\n\n    try {\n      const [rails] = await paymentsContract.getRailsForPayeeAndToken(signerAddress, this._usdfcAddress, 0n, 0n)\n\n      return rails.map((rail: any) => ({\n        railId: Number(rail.railId),\n        isTerminated: rail.isTerminated,\n        endEpoch: Number(rail.endEpoch),\n      }))\n    } catch (error) {\n      throw createError('PaymentsService', 'getRailsAsPayee', 'Failed to get rails where wallet is payee', error)\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1391, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/payments/index.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/payments/index.ts"],"sourcesContent":["/**\n * Exports the PaymentsService and DepositOptions types\n *\n * @module Payments\n * @example\n * ```ts\n * import { PaymentsService } from '@filoz/synapse-sdk/payments'\n * ```\n */\n\nexport type { DepositOptions } from './service.ts'\nexport { PaymentsService } from './service.ts'\n"],"names":[],"mappings":";AAWA,OAAO,EAAE,eAAe,EAAE,MAAM,cAAc,CAAA"}},
    {"offset": {"line": 1398, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/pdp/auth.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/pdp/auth.ts"],"sourcesContent":["/**\n * EIP-712 Authentication helpers for PDP operations\n */\n\nimport { asPieceCID, type PieceCID } from '@filoz/synapse-core/piece'\nimport { ethers } from 'ethers'\nimport type { AuthSignature, MetadataEntry } from '../types.ts'\nimport { METADATA_KEYS } from '../utils/constants.ts'\nimport { EIP712_TYPES } from '../utils/eip712.ts'\n\n// Declare window.ethereum for TypeScript\ndeclare global {\n  interface Window {\n    ethereum?: any\n  }\n}\n\n/**\n * Helper class for creating EIP-712 typed signatures for PDP operations\n *\n * This class provides methods to create cryptographic signatures required for\n * authenticating PDP (Proof of Data Possession) operations with service providers.\n * All signatures are EIP-712 compatible for improved security and UX.\n *\n * Can be used standalone or through the Synapse SDK.\n *\n * @example\n * ```typescript\n * // Direct instantiation with ethers signer\n * import { PDPAuthHelper } from '@filoz/synapse-sdk'\n * import { ethers } from 'ethers'\n *\n * const wallet = new ethers.Wallet(privateKey, provider)\n * const auth = new PDPAuthHelper(contractAddress, wallet, BigInt(chainId))\n *\n * // Or get from Synapse instance (convenience method)\n * const synapse = await Synapse.create({ privateKey, rpcURL })\n * const auth = synapse.getPDPAuthHelper()\n *\n * // Sign operations for PDP service authentication\n * const createSig = await auth.signCreateDataSet(0, providerAddress, false)\n * const addPiecesSig = await auth.signAddPieces(0, 1, pieceDataArray)\n * ```\n */\nexport class PDPAuthHelper {\n  private readonly signer: ethers.Signer\n  private readonly domain: ethers.TypedDataDomain\n  public readonly WITH_CDN_METADATA: MetadataEntry = { key: METADATA_KEYS.WITH_CDN, value: '' }\n\n  constructor(serviceContractAddress: string, signer: ethers.Signer, chainId: bigint) {\n    this.signer = signer\n\n    // EIP-712 domain\n    this.domain = {\n      name: 'FilecoinWarmStorageService',\n      version: '1',\n      chainId: Number(chainId),\n      verifyingContract: serviceContractAddress,\n    }\n  }\n\n  /**\n   * Get the actual signer, unwrapping NonceManager if needed\n   */\n  private getUnderlyingSigner(): ethers.Signer {\n    // Check if this is a NonceManager-wrapped signer\n    if ('signer' in this.signer && this.signer.constructor.name === 'NonceManager') {\n      // Access the underlying signer for signTypedData support\n      return (this.signer as any).signer\n    }\n    return this.signer\n  }\n\n  /**\n   * Check if the signer is a browser provider (MetaMask, etc)\n   */\n  private async isMetaMaskSigner(): Promise<boolean> {\n    try {\n      // Get the actual signer (unwrap NonceManager if needed)\n      const actualSigner = this.getUnderlyingSigner()\n\n      // If it's a Wallet, it can sign locally, so not a MetaMask signer\n      if (actualSigner.constructor.name === 'Wallet') {\n        return false\n      }\n\n      // Check if signer has a provider\n      const provider = actualSigner.provider\n      if (provider == null) {\n        return false\n      }\n\n      // Check for ethers v6 BrowserProvider\n      if ('_eip1193Provider' in provider) {\n        return true\n      }\n\n      // If it's a JsonRpcProvider or WebSocketProvider, it's not a browser provider\n      // These can sign locally with a wallet\n      if (provider instanceof ethers.JsonRpcProvider || provider instanceof ethers.WebSocketProvider) {\n        return false\n      }\n\n      // For any other provider with request method (potential EIP-1193 provider)\n      if ('request' in provider && typeof (provider as any).request === 'function') {\n        return true\n      }\n    } catch {\n      // Silently fail and return false\n    }\n    return false\n  }\n\n  /**\n   * Sign typed data with MetaMask-friendly display\n   * This bypasses ethers.js conversion to show human-readable values in MetaMask\n   */\n  private async signWithMetaMask(\n    types: Record<string, Array<{ name: string; type: string }>>,\n    value: any\n  ): Promise<string> {\n    const provider = this.signer.provider\n    if (provider == null) {\n      throw new Error('No provider available')\n    }\n\n    const signerAddress = await this.signer.getAddress()\n\n    // Determine the primary type (the first one that isn't a dependency)\n    let primaryType = ''\n    for (const typeName of Object.keys(types)) {\n      // Skip Cid and PieceData as they are dependencies\n      if (typeName !== 'Cid' && typeName !== 'PieceData') {\n        primaryType = typeName\n        break\n      }\n    }\n\n    // Construct the full typed data payload for MetaMask\n    const typedData = {\n      types: {\n        EIP712Domain: [\n          { name: 'name', type: 'string' },\n          { name: 'version', type: 'string' },\n          { name: 'chainId', type: 'uint256' },\n          { name: 'verifyingContract', type: 'address' },\n        ],\n        ...types,\n      },\n      primaryType,\n      domain: this.domain,\n      message: value,\n    }\n\n    // For ethers v6, we need to access the underlying EIP-1193 provider\n    let eip1193Provider: any\n    if ('_eip1193Provider' in provider) {\n      // BrowserProvider in ethers v6\n      eip1193Provider = (provider as any)._eip1193Provider\n    } else if ('request' in provider) {\n      // Already an EIP-1193 provider\n      eip1193Provider = provider\n    } else {\n      // Fallback to provider.send\n      eip1193Provider = provider\n    }\n\n    // Call MetaMask directly for better UX\n    let signature: string\n    if (eip1193Provider != null && 'request' in eip1193Provider) {\n      // Use EIP-1193 request method\n      signature = await eip1193Provider.request({\n        method: 'eth_signTypedData_v4',\n        params: [signerAddress, JSON.stringify(typedData)],\n      })\n    } else {\n      // Fallback to send method\n      signature = await (provider as any).send('eth_signTypedData_v4', [signerAddress, JSON.stringify(typedData)])\n    }\n\n    return signature\n  }\n\n  /**\n   * Create signature for data set creation\n   *\n   * This signature authorizes a service provider to create a new data set\n   * on behalf of the client. The signature includes the client's dataset ID,\n   * the service provider's payment address, and CDN preference.\n   *\n   * @param clientDataSetId - Unique dataset ID for the client (typically starts at 0 and increments)\n   * @param payee - Service provider's address that will receive payments\n   * @param metadata - Service parameters as key-value pairs\n   * @returns Promise resolving to authentication signature for data set creation\n   *\n   * @example\n   * ```typescript\n   * const auth = new PDPAuthHelper(contractAddress, signer, chainId)\n   * const signature = await auth.signCreateDataSet(\n   *   0,                                // First dataset for this client\n   *   '0x1234...abcd',                  // Service provider address\n   *   PDPAuthHelper.WITH_CDN_METADATA   // Enable CDN service\n   * )\n   * ```\n   */\n  async signCreateDataSet(\n    clientDataSetId: bigint,\n    payee: string,\n    metadata: MetadataEntry[] = []\n  ): Promise<AuthSignature> {\n    let signature: string\n    const types = { CreateDataSet: EIP712_TYPES.CreateDataSet, MetadataEntry: EIP712_TYPES.MetadataEntry }\n\n    // Check if we should use MetaMask-friendly signing\n    const useMetaMask = await this.isMetaMaskSigner()\n\n    if (useMetaMask) {\n      // Use MetaMask-friendly signing for better UX\n      const value = {\n        clientDataSetId: clientDataSetId.toString(), // Keep as string for MetaMask display\n        metadata,\n        payee,\n      }\n\n      signature = await this.signWithMetaMask(types, value)\n    } else {\n      // Use standard ethers.js signing (for private keys, etc)\n      const value = {\n        clientDataSetId,\n        metadata,\n        payee,\n      }\n\n      // Use underlying signer for typed data signing (handles NonceManager)\n      const actualSigner = this.getUnderlyingSigner()\n      signature = await actualSigner.signTypedData(this.domain, types, value)\n    }\n\n    // Return signature with components\n    const sig = ethers.Signature.from(signature)\n\n    // For EIP-712, signedData contains the actual message hash that was signed\n    const signedData = ethers.TypedDataEncoder.hash(this.domain, types, {\n      clientDataSetId,\n      metadata,\n      payee,\n    })\n\n    return {\n      signature,\n      v: sig.v,\n      r: sig.r,\n      s: sig.s,\n      signedData,\n    }\n  }\n\n  /**\n   * Create signature for adding pieces to a data set\n   *\n   * This signature authorizes a service provider to add new data pieces\n   * to an existing data set. Each piece represents aggregated data that\n   * will be proven using PDP challenges.\n   *\n   * @param clientDataSetId - Client's dataset ID (same as used in createDataSet)\n   * @param nonce - Random nonce for replay protection\n   * @param pieceDataArray - Array of piece data containing PieceCID CIDs and raw sizes\n   * @returns Promise resolving to authentication signature for adding pieces\n   *\n   * @example\n   * ```typescript\n   * const auth = new PDPAuthHelper(contractAddress, signer, chainId)\n   * const pieceData = [{\n   *   cid: 'bafkzcibc...', // PieceCID of aggregated data\n   *   rawSize: Number(SIZE_CONSTANTS.MiB)     // Raw size in bytes before padding\n   * }]\n   * const nonce = randU256() // Generate random nonce\n   * const signature = await auth.signAddPieces(\n   *   0,           // Same dataset ID as data set creation\n   *   nonce,       // Random nonce for replay protection\n   *   pieceData    // Array of pieces to add\n   * )\n   * ```\n   */\n  async signAddPieces(\n    clientDataSetId: bigint,\n    nonce: bigint,\n    pieceDataArray: PieceCID[] | string[],\n    metadata: MetadataEntry[][] = []\n  ): Promise<AuthSignature> {\n    if (metadata.length === 0) {\n      // make metadata array match length of pieceDataArray\n      metadata = Array(pieceDataArray.length).fill([])\n    } else if (metadata.length !== pieceDataArray.length) {\n      throw new Error('metadata length must match pieceDataArray length')\n    }\n\n    const pieceMetadata: { pieceIndex: number; metadata: MetadataEntry[] }[] = []\n\n    // Transform the piece data into the proper format for EIP-712\n    const formattedPieceData = []\n    for (let i = 0; i < pieceDataArray.length; i++) {\n      const piece = pieceDataArray[i]\n      const pieceCid = typeof piece === 'string' ? asPieceCID(piece) : piece\n      if (pieceCid == null) {\n        throw new Error(`Invalid PieceCID: ${String(pieceCid)}`)\n      }\n\n      // Format as nested structure matching Solidity's Cids.Cid struct\n      formattedPieceData.push({\n        data: pieceCid.bytes, // This will be a Uint8Array\n      })\n      pieceMetadata.push({\n        pieceIndex: i,\n        metadata: metadata[i],\n      })\n    }\n    const types = {\n      AddPieces: EIP712_TYPES.AddPieces,\n      Cid: EIP712_TYPES.Cid,\n      PieceMetadata: EIP712_TYPES.PieceMetadata,\n      MetadataEntry: EIP712_TYPES.MetadataEntry,\n    }\n\n    let signature: string\n\n    // Check if we should use MetaMask-friendly signing\n    const useMetaMask = await this.isMetaMaskSigner()\n\n    if (useMetaMask) {\n      // Use MetaMask-friendly signing with properly structured data\n      const value = {\n        clientDataSetId: clientDataSetId.toString(), // Keep as string for MetaMask display\n        nonce: nonce.toString(), // Keep as string for MetaMask display\n        pieceData: formattedPieceData.map((item) => ({\n          data: ethers.hexlify(item.data), // Convert Uint8Array to hex string for MetaMask\n        })),\n        pieceMetadata: pieceMetadata,\n      }\n\n      signature = await this.signWithMetaMask(types, value)\n    } else {\n      // Use standard ethers.js signing with bigint values\n      const value = {\n        clientDataSetId,\n        nonce,\n        pieceData: formattedPieceData,\n        pieceMetadata: pieceMetadata,\n      }\n\n      // Use underlying signer for typed data signing (handles NonceManager)\n      const actualSigner = this.getUnderlyingSigner()\n      signature = await actualSigner.signTypedData(this.domain, types, value)\n    }\n\n    // Return signature with components\n    const sig = ethers.Signature.from(signature)\n\n    // For EIP-712, signedData contains the actual message hash that was signed\n    const signedData = ethers.TypedDataEncoder.hash(this.domain, types, {\n      clientDataSetId,\n      nonce,\n      pieceData: formattedPieceData,\n      pieceMetadata: pieceMetadata,\n    })\n\n    return {\n      signature,\n      v: sig.v,\n      r: sig.r,\n      s: sig.s,\n      signedData,\n    }\n  }\n\n  /**\n   * Create signature for scheduling piece removals\n   *\n   * This signature authorizes a service provider to schedule specific pieces\n   * for removal from the data set. Pieces are typically removed after the\n   * next successful proof submission.\n   *\n   * @param clientDataSetId - Client's dataset ID\n   * @param pieceIds - Array of piece IDs to schedule for removal\n   * @returns Promise resolving to authentication signature for scheduling removals\n   *\n   * @example\n   * ```typescript\n   * const auth = new PDPAuthHelper(contractAddress, signer, chainId)\n   * const signature = await auth.signSchedulePieceRemovals(\n   *   0,           // Dataset ID\n   *   [1, 2, 3]    // Piece IDs to remove\n   * )\n   * ```\n   */\n  async signSchedulePieceRemovals(clientDataSetId: bigint, pieceIds: Array<bigint>): Promise<AuthSignature> {\n    let signature: string\n\n    // Check if we should use MetaMask-friendly signing\n    const useMetaMask = await this.isMetaMaskSigner()\n\n    if (useMetaMask) {\n      // Use MetaMask-friendly signing for better UX\n      const value = {\n        clientDataSetId: clientDataSetId.toString(), // Keep as string for MetaMask display\n        pieceIds: pieceIds.map((id) => id.toString()), // Convert to string array for display\n      }\n\n      signature = await this.signWithMetaMask({ SchedulePieceRemovals: EIP712_TYPES.SchedulePieceRemovals }, value)\n    } else {\n      // Use standard ethers.js signing with BigInt values\n      const value = { clientDataSetId, pieceIds }\n\n      // Use underlying signer for typed data signing (handles NonceManager)\n      const actualSigner = this.getUnderlyingSigner()\n      signature = await actualSigner.signTypedData(\n        this.domain,\n        { SchedulePieceRemovals: EIP712_TYPES.SchedulePieceRemovals },\n        value\n      )\n    }\n\n    const sig = ethers.Signature.from(signature)\n\n    // For EIP-712, signedData contains the actual message hash that was signed\n    const signedData = ethers.TypedDataEncoder.hash(\n      this.domain,\n      { SchedulePieceRemovals: EIP712_TYPES.SchedulePieceRemovals },\n      { clientDataSetId, pieceIds }\n    )\n\n    return {\n      signature,\n      v: sig.v,\n      r: sig.r,\n      s: sig.s,\n      signedData,\n    }\n  }\n\n  /**\n   * Create signature for data set deletion\n   *\n   * This signature authorizes complete deletion of a data set and all\n   * its associated data. This action is irreversible and will terminate\n   * the storage service for this dataset.\n   *\n   * @param clientDataSetId - Client's dataset ID to delete\n   * @returns Promise resolving to authentication signature for data set deletion\n   *\n   * @example\n   * ```typescript\n   * const auth = new PDPAuthHelper(contractAddress, signer, chainId)\n   * const signature = await auth.signDeleteDataSet(\n   *   0  // Dataset ID to delete\n   * )\n   * ```\n   */\n  async signDeleteDataSet(clientDataSetId: bigint): Promise<AuthSignature> {\n    let signature: string\n\n    // Check if we should use MetaMask-friendly signing\n    const useMetaMask = await this.isMetaMaskSigner()\n\n    if (useMetaMask) {\n      // Use MetaMask-friendly signing for better UX\n      const value = {\n        clientDataSetId: clientDataSetId.toString(), // Keep as string for MetaMask display\n      }\n\n      signature = await this.signWithMetaMask({ DeleteDataSet: EIP712_TYPES.DeleteDataSet }, value)\n    } else {\n      // Use standard ethers.js signing\n      const value = { clientDataSetId }\n\n      // Use underlying signer for typed data signing (handles NonceManager)\n      const actualSigner = this.getUnderlyingSigner()\n      signature = await actualSigner.signTypedData(this.domain, { DeleteDataSet: EIP712_TYPES.DeleteDataSet }, value)\n    }\n\n    const sig = ethers.Signature.from(signature)\n\n    // For EIP-712, signedData contains the actual message hash that was signed\n    const signedData = ethers.TypedDataEncoder.hash(\n      this.domain,\n      { DeleteDataSet: EIP712_TYPES.DeleteDataSet },\n      { clientDataSetId }\n    )\n\n    return {\n      signature,\n      v: sig.v,\n      r: sig.r,\n      s: sig.s,\n      signedData,\n    }\n  }\n\n  /**\n   * Get the address of the signer\n   * @returns Promise resolving to the signer's Ethereum address\n   */\n  async getSignerAddress(): Promise<string> {\n    return await this.signer.getAddress()\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1697, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/pdp/validation.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/pdp/validation.ts"],"sourcesContent":["/**\n * Type guards and validation utilities for PDP server responses\n *\n * These validators ensure that responses from untrusted PDP servers\n * match the expected format before using them in the SDK.\n */\n\nimport { asPieceCID } from '@filoz/synapse-core/piece'\nimport type { DataSetData, DataSetPieceData } from '../types.ts'\nimport type {\n  DataSetCreationStatusResponse,\n  FindPieceResponse,\n  PieceAdditionStatusResponse,\n  PieceStatusResponse,\n} from './server.ts'\n\n/**\n * Type guard for DataSetCreationStatusResponse\n * Validates the response from checking data set creation status\n *\n * @param value - The value to validate\n * @returns True if the value matches DataSetCreationStatusResponse interface\n */\nexport function isDataSetCreationStatusResponse(value: unknown): value is DataSetCreationStatusResponse {\n  if (typeof value !== 'object' || value == null) {\n    return false\n  }\n\n  const obj = value as Record<string, unknown>\n\n  // Required fields\n  if (typeof obj.createMessageHash !== 'string') {\n    return false\n  }\n  if (typeof obj.dataSetCreated !== 'boolean') {\n    return false\n  }\n  if (typeof obj.service !== 'string') {\n    return false\n  }\n  if (typeof obj.txStatus !== 'string') {\n    return false\n  }\n  if (obj.ok !== null && typeof obj.ok !== 'boolean') {\n    return false\n  }\n\n  // Optional field\n  if (obj.dataSetId !== undefined && typeof obj.dataSetId !== 'number') {\n    return false\n  }\n\n  return true\n}\n\n/**\n * Type guard for PieceAdditionStatusResponse\n * Validates the response from checking piece addition status\n *\n * @param value - The value to validate\n * @returns True if the value matches PieceAdditionStatusResponse interface\n */\nexport function isPieceAdditionStatusResponse(value: unknown): value is PieceAdditionStatusResponse {\n  if (typeof value !== 'object' || value == null) {\n    return false\n  }\n\n  const obj = value as Record<string, unknown>\n\n  // Required fields\n  if (typeof obj.txHash !== 'string') {\n    return false\n  }\n  if (typeof obj.txStatus !== 'string') {\n    return false\n  }\n  if (typeof obj.dataSetId !== 'number') {\n    return false\n  }\n  if (typeof obj.pieceCount !== 'number') {\n    return false\n  }\n  if (obj.addMessageOk !== null && typeof obj.addMessageOk !== 'boolean') {\n    return false\n  }\n\n  // Optional field - confirmedPieceIds\n  if (obj.confirmedPieceIds !== undefined) {\n    if (!Array.isArray(obj.confirmedPieceIds)) {\n      return false\n    }\n    // Check all elements are numbers\n    for (const id of obj.confirmedPieceIds) {\n      if (typeof id !== 'number') {\n        return false\n      }\n    }\n  }\n\n  return true\n}\n\n/**\n * Type guard for FindPieceResponse\n * Validates the response from finding a piece\n * Supports both pieceCid (new) and piece_cid (legacy) field names for backward compatibility\n *\n * @param value - The value to validate\n * @returns True if the value matches FindPieceResponse interface\n */\nexport function isFindPieceResponse(value: unknown): value is FindPieceResponse {\n  if (typeof value !== 'object' || value == null) {\n    return false\n  }\n\n  const obj = value as Record<string, unknown>\n\n  if (typeof obj.pieceCid !== 'string') {\n    return false\n  }\n\n  // Validate that the piece CID is a valid PieceCID\n  if (asPieceCID(obj.pieceCid) == null) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * Validates and returns a DataSetCreationStatusResponse\n * @param value - The value to validate\n * @throws Error if validation fails\n */\nexport function validateDataSetCreationStatusResponse(value: unknown): DataSetCreationStatusResponse {\n  if (!isDataSetCreationStatusResponse(value)) {\n    throw new Error('Invalid data set creation status response format')\n  }\n  return value\n}\n\nexport function validatePieceDeleteResponse(value: unknown): { txHash: string } {\n  if (typeof value !== 'object' || value == null) {\n    throw new Error('Invalid piece delete response format')\n  }\n\n  const obj = value as Record<string, unknown>\n\n  if (typeof obj.txHash !== 'string') {\n    throw new Error('Invalid piece delete response format')\n  }\n\n  return {\n    txHash: obj.txHash,\n  }\n}\n\n/**\n * Validates and returns a PieceAdditionStatusResponse\n * @param value - The value to validate\n * @throws Error if validation fails\n */\nexport function validatePieceAdditionStatusResponse(value: unknown): PieceAdditionStatusResponse {\n  if (!isPieceAdditionStatusResponse(value)) {\n    throw new Error('Invalid piece addition status response format')\n  }\n  return value\n}\n\n/**\n * Validates and returns a FindPieceResponse\n * Normalizes the response to always have pieceCid field as a PieceCID object\n * @param value - The value to validate\n * @throws Error if validation fails\n */\nexport function validateFindPieceResponse(value: unknown): FindPieceResponse {\n  if (!isFindPieceResponse(value)) {\n    // Check if it failed specifically due to invalid PieceCID\n    if (typeof value === 'object' && value != null) {\n      const obj = value as Record<string, unknown>\n      const cidStr = (obj.pieceCid ?? obj.piece_cid) as string | undefined\n      if (cidStr != null && asPieceCID(cidStr) == null) {\n        throw new Error('Invalid find piece response: pieceCid is not a valid PieceCID')\n      }\n    }\n    throw new Error('Invalid find piece response format')\n  }\n\n  const obj = value as any\n\n  // Get the CID string from either field\n  const cidStr = (obj.pieceCid ?? obj.piece_cid) as string\n\n  // Convert to PieceCID object (we know it's valid because isFindPieceResponse already checked)\n  const pieceCid = asPieceCID(cidStr)\n  if (pieceCid == null) {\n    // This should never happen since we validated above, but just in case\n    throw new Error('Invalid find piece response: pieceCid is not a valid PieceCID')\n  }\n\n  // Return normalized response with PieceCID object\n  return {\n    pieceCid,\n  }\n}\n\n/**\n * Type guard for PieceStatusResponse\n * Validates the response from checking piece indexing and IPNI status\n *\n * @param value - The value to validate\n * @returns True if the value matches PieceStatusResponse interface\n */\nexport function isPieceStatusResponse(value: unknown): value is PieceStatusResponse {\n  if (typeof value !== 'object' || value == null) {\n    return false\n  }\n\n  const obj = value as Record<string, unknown>\n\n  // Required fields\n  if (typeof obj.pieceCid !== 'string') {\n    return false\n  }\n  if (typeof obj.status !== 'string') {\n    return false\n  }\n  if (typeof obj.indexed !== 'boolean') {\n    return false\n  }\n  if (typeof obj.advertised !== 'boolean') {\n    return false\n  }\n  if (typeof obj.retrieved !== 'boolean') {\n    return false\n  }\n\n  // Optional field\n  if (obj.retrievedAt !== undefined && typeof obj.retrievedAt !== 'string') {\n    return false\n  }\n\n  return true\n}\n\n/**\n * Validates and returns a PieceStatusResponse\n * @param value - The value to validate\n * @throws Error if validation fails\n */\nexport function validatePieceStatusResponse(value: unknown): PieceStatusResponse {\n  if (!isPieceStatusResponse(value)) {\n    throw new Error('Invalid piece status response format')\n  }\n  return value\n}\n\n/**\n * Converts and validates individual data set piece data\n * Returns null if validation fails\n *\n * @param value - The value to validate and convert\n * @returns Converted DataSetPieceData or null if invalid\n */\nexport function asDataSetPieceData(value: unknown): DataSetPieceData | null {\n  if (typeof value !== 'object' || value == null) {\n    return null\n  }\n\n  const obj = value as Record<string, unknown>\n\n  // Required fields\n  if (typeof obj.pieceId !== 'number') {\n    return null\n  }\n  if (typeof obj.pieceCid !== 'string') {\n    return null\n  }\n  if (typeof obj.subPieceCid !== 'string') {\n    return null\n  }\n  if (typeof obj.subPieceOffset !== 'number') {\n    return null\n  }\n\n  // Convert CIDs to PieceCID objects\n  const pieceCid = asPieceCID(obj.pieceCid)\n  const subPieceCid = asPieceCID(obj.subPieceCid)\n  if (pieceCid == null || subPieceCid == null) {\n    return null\n  }\n\n  return {\n    pieceId: obj.pieceId,\n    pieceCid,\n    subPieceCid,\n    subPieceOffset: obj.subPieceOffset,\n  }\n}\n\n/**\n * Converts and validates data set data\n * Returns null if validation fails\n *\n * @param value - The value to validate and convert\n * @returns Converted DataSetData or null if invalid\n */\nexport function asDataSetData(value: unknown): DataSetData | null {\n  if (typeof value !== 'object' || value == null) {\n    return null\n  }\n\n  const obj = value as Record<string, unknown>\n\n  // Required field - id\n  if (typeof obj.id !== 'number') {\n    return null\n  }\n\n  // Required field - pieces (array of DataSetPieceData)\n  if (!Array.isArray(obj.pieces)) {\n    return null\n  }\n\n  const convertedPieces: DataSetPieceData[] = []\n  for (const piece of obj.pieces) {\n    const convertedPiece = asDataSetPieceData(piece)\n    if (convertedPiece == null) {\n      return null\n    }\n    convertedPieces.push(convertedPiece)\n  }\n\n  // Required field - nextChallengeEpoch\n  if (typeof obj.nextChallengeEpoch !== 'number') {\n    return null\n  }\n\n  return {\n    id: obj.id,\n    pieces: convertedPieces,\n    nextChallengeEpoch: obj.nextChallengeEpoch,\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1930, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/pdp/server.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/pdp/server.ts"],"sourcesContent":["/**\n * PDPServer - Consolidated interface for all PDP server (Curio) HTTP operations\n *\n * This combines functionality for:\n * - Data set management (create, add pieces, status checks)\n * - Piece uploads\n * - Piece downloads\n * - Piece discovery\n *\n * @example\n * ```typescript\n * import { PDPServer } from '@filoz/synapse-sdk/pdp'\n * import { PDPAuthHelper } from '@filoz/synapse-sdk/pdp'\n *\n * const authHelper = new PDPAuthHelper(warmStorageAddress, signer)\n * const pdpServer = new PDPServer(authHelper, 'https://pdp.provider.com')\n *\n * // Create a data set\n * const { txHash } = await pdpServer.createDataSet(serviceProvider, clientDataSetId)\n *\n * // Upload a piece\n * const { pieceCid, size } = await pdpServer.uploadPiece(data)\n *\n * // Download a piece\n * const data = await pdpServer.downloadPiece(pieceCid, size)\n * ```\n */\n\nimport * as Piece from '@filoz/synapse-core/piece'\nimport { asPieceCID, downloadAndValidate } from '@filoz/synapse-core/piece'\nimport * as SP from '@filoz/synapse-core/sp'\nimport { randU256 } from '@filoz/synapse-core/utils'\nimport { ethers } from 'ethers'\nimport type { Hex } from 'viem'\nimport type { DataSetData, MetadataEntry, PieceCID } from '../types.ts'\nimport { validateDataSetMetadata, validatePieceMetadata } from '../utils/metadata.ts'\nimport { constructPieceUrl } from '../utils/piece.ts'\nimport type { PDPAuthHelper } from './auth.ts'\nimport {\n  validateDataSetCreationStatusResponse,\n  validatePieceAdditionStatusResponse,\n  validatePieceStatusResponse,\n} from './validation.ts'\n\n/**\n * Response from creating a data set\n */\nexport interface CreateDataSetResponse {\n  /** Transaction hash for the data set creation */\n  txHash: string\n  /** URL to check creation status */\n  statusUrl: string\n}\n\n/**\n * Response from checking data set creation status\n */\nexport interface DataSetCreationStatusResponse {\n  /** Transaction hash that created the data set */\n  createMessageHash: string\n  /** Whether the data set has been created on-chain */\n  dataSetCreated: boolean\n  /** Service label that created the data set */\n  service: string\n  /** Transaction status (pending, confirmed, failed) */\n  txStatus: string\n  /** Whether the transaction was successful (null if still pending) */\n  ok: boolean | null\n  /** The server's reported ID for this data set (only available after creation) */\n  dataSetId?: number\n}\n\n/**\n * Response from adding pieces to a data set\n */\nexport interface AddPiecesResponse {\n  /** Success message from the server */\n  message: string\n  /** Transaction hash for the piece addition (optional - new servers only) */\n  txHash: string\n  /** URL to check piece addition status (optional - new servers only) */\n  statusUrl: string\n}\n\n/**\n * Response from finding a piece\n */\nexport interface FindPieceResponse {\n  /** The piece CID that was found */\n  pieceCid: PieceCID\n}\n\n/**\n * Response from checking piece indexing and IPNI status\n */\nexport interface PieceStatusResponse {\n  /** The piece CID */\n  pieceCid: string\n  /** Current processing status */\n  status: string\n  /** Whether the piece has been indexed */\n  indexed: boolean\n  /** Whether the piece has been advertised to IPNI */\n  advertised: boolean\n  /**\n   * Whether the piece has been retrieved\n   * This does not necessarily mean it was retrieved by a particular indexer,\n   * only that the PDP server witnessed a retrieval event. Care should be\n   * taken when interpreting this field.\n   */\n  retrieved: boolean\n  /** Timestamp when the piece was retrieved (optional) */\n  retrievedAt?: string\n}\n\n/**\n * Response from checking piece addition status\n */\nexport interface PieceAdditionStatusResponse {\n  /** Transaction hash for the piece addition */\n  txHash: string\n  /** Transaction status (pending, confirmed, failed) */\n  txStatus: string\n  /** The data set ID */\n  dataSetId: number\n  /** Number of pieces being added */\n  pieceCount: number\n  /** Whether the add message was successful (null if pending) */\n  addMessageOk: boolean | null\n  /** Piece IDs assigned after confirmation */\n  confirmedPieceIds?: number[]\n}\n\n/**\n * Options for uploading a piece\n */\nexport interface UploadPieceOptions {\n  /** Optional progress callback */\n  onProgress?: (bytesUploaded: number) => void\n  /** Optional pre-calculated PieceCID to skip CommP calculation (BYO PieceCID, it will be checked by the server) */\n  pieceCid?: PieceCID\n  /** Optional AbortSignal to cancel the upload */\n  signal?: AbortSignal\n}\n\n/**\n * Input for adding pieces to a data set\n */\nexport interface PDPAddPiecesInput {\n  pieces: PDPPieces[]\n  extraData: string\n}\n\nexport interface PDPPieces {\n  pieceCid: string\n  subPieces: {\n    subPieceCid: string\n  }[]\n}\n\nexport interface PDPCreateAndAddInput {\n  recordKeeper: string\n  pieces: PDPPieces[]\n  extraData: string\n}\n\nexport class PDPServer {\n  private readonly _serviceURL: string\n  private readonly _authHelper: PDPAuthHelper | null\n\n  /**\n   * Create a new PDPServer instance\n   * @param authHelper - PDPAuthHelper instance for signing operations\n   * @param serviceURL - The PDP service URL (e.g., https://pdp.provider.com)\n   */\n  constructor(authHelper: PDPAuthHelper | null, serviceURL: string) {\n    if (serviceURL.trim() === '') {\n      throw new Error('PDP service URL is required')\n    }\n    // Remove trailing slash from URL\n    this._serviceURL = serviceURL.replace(/\\/$/, '')\n    this._authHelper = authHelper\n  }\n\n  /**\n   * Create a new data set on the PDP server\n   * @param clientDataSetId - Unique ID for the client's dataset\n   * @param payee - Address that will receive payments (service provider)\n   * @param payer - Address that will pay for the storage (client)\n   * @param metadata - Metadata entries for the data set (key-value pairs)\n   * @param recordKeeper - Address of the Warm Storage contract\n   * @returns Promise that resolves with transaction hash and status URL\n   */\n  async createDataSet(\n    clientDataSetId: bigint,\n    payee: string,\n    payer: string,\n    metadata: MetadataEntry[],\n    recordKeeper: string\n  ): Promise<CreateDataSetResponse> {\n    // Validate metadata against contract limits\n    validateDataSetMetadata(metadata)\n\n    // Generate the EIP-712 signature for data set creation\n    const authData = await this.getAuthHelper().signCreateDataSet(clientDataSetId, payee, metadata)\n\n    // Prepare the extra data for the contract call\n    // This needs to match the DataSetCreateData struct in Warm Storage contract\n    const extraData = this._encodeDataSetCreateData({\n      payer,\n      clientDataSetId,\n      metadata,\n      signature: authData.signature,\n    })\n\n    return SP.createDataSet({\n      endpoint: this._serviceURL,\n      recordKeeper: recordKeeper as Hex,\n      extraData: `0x${extraData}`,\n    })\n  }\n\n  /**\n   * Creates a data set and adds pieces to it in a combined operation.\n   * Users can poll the status of the operation using the returned data set status URL.\n   * After which the user can use the returned transaction hash and data set ID to check the status of the piece addition.\n   * @param clientDataSetId  - Unique ID for the client's dataset\n   * @param payee - Address that will receive payments (service provider)\n   * @param payer - Address that will pay for the storage (client)\n   * @param recordKeeper - Address of the Warm Storage contract\n   * @param pieceDataArray - Array of piece data containing PieceCID CIDs and raw sizes\n   * @param metadata - Optional metadata for dataset and each of the pieces.\n   * @returns Promise that resolves with transaction hash and status URL\n   */\n  async createAndAddPieces(\n    clientDataSetId: bigint,\n    payee: string,\n    payer: string,\n    recordKeeper: string,\n    pieceDataArray: PieceCID[] | string[],\n    metadata: {\n      dataset?: MetadataEntry[]\n      pieces?: MetadataEntry[][]\n    }\n  ): Promise<CreateDataSetResponse> {\n    // Validate metadata against contract limits\n    if (metadata.dataset == null) {\n      metadata.dataset = []\n    }\n    validateDataSetMetadata(metadata.dataset)\n    metadata.pieces = PDPServer._processAddPiecesInputs(pieceDataArray, metadata.pieces)\n\n    // Generate the EIP-712 signature for data set creation\n    const createAuthData = await this.getAuthHelper().signCreateDataSet(clientDataSetId, payee, metadata.dataset)\n\n    // Prepare the extra data for the contract call\n    // This needs to match the DataSetCreateData struct in Warm Storage contract\n    const createExtraData = this._encodeDataSetCreateData({\n      payer,\n      clientDataSetId,\n      metadata: metadata.dataset,\n      signature: createAuthData.signature,\n    })\n\n    // Generate a random nonce for replay protection\n    const nonce = randU256()\n\n    const addAuthData = await this.getAuthHelper().signAddPieces(\n      clientDataSetId,\n      nonce,\n      pieceDataArray, // Pass PieceData[] directly to auth helper\n      metadata.pieces\n    )\n\n    const addExtraData = this._encodeAddPiecesExtraData({\n      nonce,\n      signature: addAuthData.signature,\n      metadata: metadata.pieces,\n    })\n\n    const abiCoder = ethers.AbiCoder.defaultAbiCoder()\n    const encoded = abiCoder.encode(['bytes', 'bytes'], [`0x${createExtraData}`, `0x${addExtraData}`])\n\n    return SP.createDataSetAndAddPieces({\n      endpoint: this._serviceURL,\n      recordKeeper: recordKeeper as Hex,\n      extraData: encoded as Hex,\n      pieces: pieceDataArray.map(asPieceCID).filter((t) => t != null),\n    })\n  }\n\n  private static _processAddPiecesInputs(\n    pieceDataArray: PieceCID[] | string[],\n    metadata?: MetadataEntry[][]\n  ): MetadataEntry[][] {\n    if (pieceDataArray.length === 0) {\n      throw new Error('At least one piece must be provided')\n    }\n\n    if (metadata != null) {\n      if (metadata.length !== pieceDataArray.length) {\n        throw new Error(`Metadata length (${metadata.length}) must match pieces length (${pieceDataArray.length})`)\n      }\n      for (let i = 0; i < metadata.length; i++) {\n        if (metadata[i] != null && metadata[i].length > 0) {\n          try {\n            validatePieceMetadata(metadata[i])\n          } catch (error: any) {\n            throw new Error(`Piece ${i} metadata validation failed: ${error.message}`)\n          }\n        }\n      }\n    }\n\n    // Validate all PieceCIDs\n    for (const pieceData of pieceDataArray) {\n      const pieceCid = asPieceCID(pieceData)\n      if (pieceCid == null) {\n        throw new Error(`Invalid PieceCID: ${String(pieceData)}`)\n      }\n    }\n    // If no metadata provided, create empty arrays for each piece\n    const finalMetadata = metadata ?? pieceDataArray.map(() => [])\n    return finalMetadata\n  }\n\n  /**\n   * Add pieces to an existing data set\n   * @param dataSetId - The ID of the data set to add pieces to\n   * @param clientDataSetId - The client's dataset ID used when creating the data set\n   * @param pieceDataArray - Array of piece data containing PieceCID CIDs and raw sizes\n   * @param metadata - Optional metadata for each piece (array of arrays, one per piece)\n   * @returns Promise that resolves when the pieces are added (201 Created)\n   * @throws Error if any CID is invalid\n   *\n   * @example\n   * ```typescript\n   * const pieceData = ['bafkzcibcd...']\n   * const metadata = [[{ key: 'snapshotDate', value: '20250711' }]]\n   * await pdpTool.addPieces(dataSetId, clientDataSetId, pieceData, metadata)\n   * ```\n   */\n  async addPieces(\n    dataSetId: number,\n    clientDataSetId: bigint,\n    pieceDataArray: PieceCID[] | string[],\n    metadata?: MetadataEntry[][]\n  ): Promise<AddPiecesResponse> {\n    const finalMetadata = PDPServer._processAddPiecesInputs(pieceDataArray, metadata)\n\n    // Generate a random nonce for replay protection\n    const nonce = randU256()\n\n    // Generate the EIP-712 signature for adding pieces\n    const authData = await this.getAuthHelper().signAddPieces(\n      clientDataSetId,\n      nonce,\n      pieceDataArray, // Pass PieceData[] directly to auth helper\n      finalMetadata\n    )\n\n    // Prepare the extra data for the contract call\n    // This needs to match what the Warm Storage contract expects for addPieces\n    const extraData = this._encodeAddPiecesExtraData({\n      nonce,\n      signature: authData.signature,\n      metadata: finalMetadata,\n    })\n\n    const { txHash, statusUrl } = await SP.addPieces({\n      endpoint: this._serviceURL,\n      dataSetId: BigInt(dataSetId),\n      pieces: pieceDataArray.map(asPieceCID).filter((t) => t != null),\n      extraData: `0x${extraData}`,\n    })\n    return {\n      message: `Pieces added to data set ID ${dataSetId} successfully`,\n      txHash,\n      statusUrl,\n    }\n  }\n\n  /**\n   * Check the status of a data set creation\n   * @param txHash - Transaction hash from createDataSet\n   * @returns Promise that resolves with the creation status\n   */\n  async getDataSetCreationStatus(txHash: string): Promise<DataSetCreationStatusResponse> {\n    const response = await fetch(`${this._serviceURL}/pdp/data-sets/created/${txHash}`, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    })\n\n    if (response.status === 404) {\n      throw new Error(`Data set creation not found for transaction hash: ${txHash}`)\n    }\n\n    if (response.status !== 200) {\n      const errorText = await response.text()\n      throw new Error(\n        `Failed to get data set creation status: ${response.status} ${response.statusText} - ${errorText}`\n      )\n    }\n\n    const data = await response.json()\n    return validateDataSetCreationStatusResponse(data)\n  }\n\n  /**\n   * Check the status of a piece addition transaction\n   * @param dataSetId - The data set ID\n   * @param txHash - Transaction hash from addPieces\n   * @returns Promise that resolves with the addition status\n   */\n  async getPieceAdditionStatus(dataSetId: number, txHash: string): Promise<PieceAdditionStatusResponse> {\n    const response = await fetch(`${this._serviceURL}/pdp/data-sets/${dataSetId}/pieces/added/${txHash}`, {\n      method: 'GET',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    })\n\n    if (response.status === 404) {\n      throw new Error(`Piece addition not found for transaction: ${txHash}`)\n    }\n\n    if (response.status !== 200) {\n      const errorText = await response.text()\n      throw new Error(`Failed to get piece addition status: ${response.status} ${response.statusText} - ${errorText}`)\n    }\n\n    const data = await response.json()\n    return validatePieceAdditionStatusResponse(data)\n  }\n\n  /**\n   * Find a piece by PieceCID and size\n   * @param pieceCid - The PieceCID CID (as string or PieceCID object)\n   * @returns Piece information if found\n   */\n  async findPiece(pieceCid: string | PieceCID): Promise<FindPieceResponse> {\n    const parsedPieceCid = asPieceCID(pieceCid)\n    if (parsedPieceCid == null) {\n      throw new Error(`Invalid PieceCID: ${String(pieceCid)}`)\n    }\n\n    const piece = await SP.findPiece({\n      endpoint: this._serviceURL,\n      pieceCid: parsedPieceCid,\n    })\n    return {\n      pieceCid: piece,\n    }\n  }\n\n  /**\n   * Get indexing and IPNI status for a piece\n   *\n   * TODO: not used anywhere, remove?\n   *\n   * @param pieceCid - The PieceCID CID (as string or PieceCID object)\n   * @returns Piece status information including indexing and IPNI advertisement status\n   * @throws Error if piece not found or doesn't belong to service (404)\n   */\n  async getPieceStatus(pieceCid: string | PieceCID): Promise<PieceStatusResponse> {\n    const parsedPieceCid = asPieceCID(pieceCid)\n    if (parsedPieceCid == null) {\n      throw new Error(`Invalid PieceCID: ${String(pieceCid)}`)\n    }\n\n    const response = await fetch(`${this._serviceURL}/pdp/piece/${parsedPieceCid.toString()}/status`, {\n      method: 'GET',\n      headers: {\n        Accept: 'application/json',\n      },\n    })\n\n    if (response.status === 404) {\n      const errorText = await response.text()\n      throw new Error(`Piece not found or does not belong to service: ${errorText}`)\n    }\n\n    if (!response.ok) {\n      const errorText = await response.text()\n      throw new Error(`Failed to get piece status: ${response.status} ${response.statusText} - ${errorText}`)\n    }\n\n    const data = await response.json()\n    return validatePieceStatusResponse(data)\n  }\n\n  /**\n   * Upload a piece to the PDP server using the commp-last protocol.\n   *\n   * Accepts data as Uint8Array, AsyncIterable<Uint8Array>, or ReadableStream<Uint8Array>.\n   * For optimal performance with non-trivial sizes, prefer streaming types (AsyncIterable or ReadableStream)\n   * to avoid memory pressure and blocking behavior. See SIZE_CONSTANTS.MAX_UPLOAD_SIZE\n   * documentation for detailed guidance.\n   *\n   * @param data - The data to upload (Uint8Array, AsyncIterable, or ReadableStream)\n   * @param options - Optional upload options\n   */\n  async uploadPiece(\n    data: Uint8Array | AsyncIterable<Uint8Array> | ReadableStream<Uint8Array>,\n    options?: UploadPieceOptions\n  ): Promise<SP.UploadPieceResponse> {\n    if (data instanceof Uint8Array) {\n      // Check hard limit\n      if (data.length > Piece.MAX_UPLOAD_SIZE) {\n        throw new Error(\n          `Upload size ${data.length} exceeds maximum ${Piece.MAX_UPLOAD_SIZE} bytes (1 GiB with fr32 expansion)`\n        )\n      }\n\n      // Convert to async iterable with chunking\n      const iterable = Piece.uint8ArrayToAsyncIterable(data)\n\n      return SP.uploadPieceStreaming({\n        endpoint: this._serviceURL,\n        data: iterable,\n        size: data.length, // Known size for Content-Length\n        onProgress: options?.onProgress,\n        pieceCid: options?.pieceCid,\n        signal: options?.signal,\n      })\n    } else {\n      // AsyncIterable or ReadableStream path - no size limit check here (checked during streaming)\n      return SP.uploadPieceStreaming({\n        endpoint: this._serviceURL,\n        data,\n        // size unknown for streams\n        onProgress: options?.onProgress,\n        pieceCid: options?.pieceCid,\n        signal: options?.signal,\n      })\n    }\n  }\n\n  /**\n   * Download a piece from a service provider\n   * @param pieceCid - The PieceCID CID of the piece\n   * @returns The downloaded data\n   */\n  async downloadPiece(pieceCid: string | PieceCID): Promise<Uint8Array> {\n    const parsedPieceCid = asPieceCID(pieceCid)\n    if (parsedPieceCid == null) {\n      throw new Error(`Invalid PieceCID: ${String(pieceCid)}`)\n    }\n\n    // Use the retrieval endpoint configured at construction time\n    const downloadUrl = constructPieceUrl(this._serviceURL, parsedPieceCid)\n\n    const response = await fetch(downloadUrl)\n\n    // Use the shared download and validation function\n    return await downloadAndValidate(response, parsedPieceCid)\n  }\n\n  /**\n   * Get data set details from the PDP server\n   * @param dataSetId - The ID of the data set to fetch\n   * @returns Promise that resolves with data set data\n   */\n  async getDataSet(dataSetId: number): Promise<DataSetData> {\n    const data = await SP.getDataSet({\n      endpoint: this._serviceURL,\n      dataSetId: BigInt(dataSetId),\n    })\n\n    return {\n      id: data.id,\n      pieces: data.pieces.map((piece) => {\n        const pieceCid = Piece.parse(piece.pieceCid)\n        return {\n          pieceId: piece.pieceId,\n          pieceCid: pieceCid,\n          subPieceCid: pieceCid,\n          subPieceOffset: piece.subPieceOffset,\n        }\n      }),\n      nextChallengeEpoch: data.nextChallengeEpoch,\n    }\n  }\n\n  /**\n   * Delete a piece from a data set\n   * @param dataSetId - The ID of dataset to delete\n   * @param clientDataSetId - Client dataset ID of the dataset to delete\n   * @param pieceID -  The ID of the piece to delete\n   * @returns Promise for transaction hash of the delete operation\n   */\n  async deletePiece(dataSetId: number, clientDataSetId: bigint, pieceID: number): Promise<string> {\n    const authData = await this.getAuthHelper().signSchedulePieceRemovals(clientDataSetId, [BigInt(pieceID)])\n\n    const { txHash } = await SP.deletePiece({\n      endpoint: this._serviceURL,\n      dataSetId: BigInt(dataSetId),\n      pieceId: BigInt(pieceID),\n      extraData: ethers.AbiCoder.defaultAbiCoder().encode(['bytes'], [authData.signature]) as Hex,\n    })\n    return txHash\n  }\n\n  /**\n   * Encode DataSetCreateData for extraData field\n   * This matches the Solidity struct DataSetCreateData in Warm Storage contract\n   */\n  private _encodeDataSetCreateData(data: {\n    payer: string\n    clientDataSetId: bigint\n    metadata: MetadataEntry[]\n    signature: string\n  }): string {\n    // Ensure signature has 0x prefix\n    const signature = data.signature.startsWith('0x') ? data.signature : `0x${data.signature}`\n\n    // ABI encode the struct as a tuple\n    // DataSetCreateData struct:\n    // - address payer\n    // - uint256 clientDataSetId\n    // - string[] metadataKeys\n    // - string[] metadataValues\n    // - bytes signature\n    const keys = data.metadata.map((item) => item.key)\n    const values = data.metadata.map((item) => item.value)\n    const abiCoder = ethers.AbiCoder.defaultAbiCoder()\n    const encoded = abiCoder.encode(\n      ['address', 'uint256', 'string[]', 'string[]', 'bytes'],\n      [data.payer, data.clientDataSetId, keys, values, signature]\n    )\n\n    // Return hex string without 0x prefix (since we add it in the calling code)\n    return encoded.slice(2)\n  }\n\n  /**\n   * Encode AddPieces extraData for the addPieces operation\n   * Format: (uint256 nonce, string[][] metadataKeys, string[][] metadataValues, bytes signature)\n   */\n  private _encodeAddPiecesExtraData(data: { nonce: bigint; signature: string; metadata: MetadataEntry[][] }): string {\n    // Ensure signature has 0x prefix\n    const signature = data.signature.startsWith('0x') ? data.signature : `0x${data.signature}`\n    const keys = data.metadata.map((item) => item.map((item) => item.key))\n    const values = data.metadata.map((item) => item.map((item) => item.value))\n\n    // ABI encode as (uint256 nonce, string[][] metadataKeys, string[][] metadataValues, bytes signature)\n    const abiCoder = ethers.AbiCoder.defaultAbiCoder()\n    const encoded = abiCoder.encode(\n      ['uint256', 'string[][]', 'string[][]', 'bytes'],\n      [data.nonce, keys, values, signature]\n    )\n\n    // Return hex string without 0x prefix (since we add it in the calling code)\n    return encoded.slice(2)\n  }\n\n  /**\n   * Ping the service provider to check connectivity\n   * @returns Promise that resolves if provider is reachable (200 response)\n   * @throws Error if provider is not reachable or returns non-200 status\n   */\n  async ping(): Promise<void> {\n    const url = `${this._serviceURL}/pdp/ping`\n    const response = await fetch(url, {\n      method: 'GET',\n      headers: {},\n    })\n\n    if (response.status !== 200) {\n      const errorText = await response.text().catch(() => 'Unknown error')\n      throw new Error(`Provider ping failed: ${response.status} ${response.statusText} - ${errorText}`)\n    }\n  }\n\n  /**\n   * Get the service URL for this PDPServer instance\n   * @returns The service URL\n   */\n  getServiceURL(): string {\n    return this._serviceURL\n  }\n\n  getAuthHelper(): PDPAuthHelper {\n    if (this._authHelper == null) {\n      throw new Error('AuthHelper is not available for an operation that requires signing')\n    }\n    return this._authHelper\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2258, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/pdp/verifier.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/pdp/verifier.ts"],"sourcesContent":["/**\n * PDPVerifier - Direct interaction with the PDPVerifier contract\n *\n * This is a low-level utility for interacting with the PDPVerifier contract.\n * It provides protocol-level operations without business logic.\n *\n * @example\n * ```typescript\n * import { PDPVerifier } from '@filoz/synapse-sdk/pdp'\n * import { ethers } from 'ethers'\n *\n * const provider = new ethers.JsonRpcProvider(rpcUrl)\n * const pdpVerifier = new PDPVerifier(provider, contractAddress)\n *\n * // Check if a data set is live\n * const isLive = await pdpVerifier.dataSetLive(dataSetId)\n * console.log(`Data set ${dataSetId} is ${isLive ? 'live' : 'not live'}`)\n * ```\n */\n\nimport { hexToPieceCID } from '@filoz/synapse-core/piece'\nimport { ethers } from 'ethers'\nimport type { PieceCID } from '../types.ts'\nimport { CONTRACT_ABIS, createError } from '../utils/index.ts'\n\nexport class PDPVerifier {\n  private readonly _provider: ethers.Provider\n  private readonly _contractAddress: string\n  private readonly _contract: ethers.Contract\n\n  constructor(provider: ethers.Provider, contractAddress: string) {\n    this._provider = provider\n    this._contractAddress = contractAddress\n    this._contract = new ethers.Contract(this._contractAddress, CONTRACT_ABIS.PDP_VERIFIER, this._provider)\n  }\n\n  /**\n   * Check if a data set is live\n   * @param dataSetId - The PDPVerifier data set ID\n   * @returns Whether the data set exists and is live\n   */\n  async dataSetLive(dataSetId: number): Promise<boolean> {\n    return await this._contract.dataSetLive(dataSetId)\n  }\n\n  /**\n   * Get the next piece ID for a data set\n   * @param dataSetId - The PDPVerifier data set ID\n   * @returns The next piece ID (which equals the current piece count)\n   */\n  async getNextPieceId(dataSetId: number): Promise<number> {\n    const nextPieceId = await this._contract.getNextPieceId(dataSetId)\n    return Number(nextPieceId)\n  }\n\n  /**\n   * Get the data set listener (record keeper)\n   * @param dataSetId - The PDPVerifier data set ID\n   * @returns The address of the listener contract\n   */\n  async getDataSetListener(dataSetId: number): Promise<string> {\n    return await this._contract.getDataSetListener(dataSetId)\n  }\n\n  /**\n   * Get the data set storage provider addresses\n   * @param dataSetId - The PDPVerifier data set ID\n   * @returns Object with current storage provider and proposed storage provider\n   */\n  async getDataSetStorageProvider(\n    dataSetId: number\n  ): Promise<{ storageProvider: string; proposedStorageProvider: string }> {\n    const [storageProvider, proposedStorageProvider] = await this._contract.getDataSetStorageProvider(dataSetId)\n    return { storageProvider, proposedStorageProvider }\n  }\n\n  /**\n   * Get the leaf count for a data set\n   * @param dataSetId - The PDPVerifier data set ID\n   * @returns The number of leaves in the data set\n   */\n  async getDataSetLeafCount(dataSetId: number): Promise<number> {\n    const leafCount = await this._contract.getDataSetLeafCount(dataSetId)\n    return Number(leafCount)\n  }\n\n  /**\n   * Extract data set ID from a transaction receipt by looking for DataSetCreated events\n   * @param receipt - Transaction receipt\n   * @returns Data set ID if found, null otherwise\n   */\n  extractDataSetIdFromReceipt(receipt: ethers.TransactionReceipt): number | null {\n    try {\n      // Parse logs looking for DataSetCreated event\n      for (const log of receipt.logs) {\n        try {\n          const parsedLog = this._contract.interface.parseLog({\n            topics: log.topics,\n            data: log.data,\n          })\n\n          if (parsedLog != null && parsedLog.name === 'DataSetCreated') {\n            return Number(parsedLog.args.setId)\n          }\n        } catch {\n          // ignore error\n        }\n      }\n\n      return null\n    } catch (error) {\n      throw new Error(\n        `Failed to extract data set ID from receipt: ${error instanceof Error ? error.message : String(error)}`\n      )\n    }\n  }\n\n  /**\n   * Get active pieces for a data set with pagination\n   * @param dataSetId - The PDPVerifier data set ID\n   * @param options - Optional configuration object\n   * @param options.offset - The offset to start from (default: 0)\n   * @param options.limit - The maximum number of pieces to return (default: 100)\n   * @param options.signal - Optional AbortSignal to cancel the operation\n   * @returns Object containing pieces, piece IDs, raw sizes, and hasMore flag\n   */\n  async getActivePieces(\n    dataSetId: number,\n    options?: {\n      offset?: number\n      limit?: number\n      signal?: AbortSignal\n    }\n  ): Promise<{\n    pieces: Array<{ pieceCid: PieceCID; pieceId: number }>\n    hasMore: boolean\n  }> {\n    const offset = options?.offset ?? 0\n    const limit = options?.limit ?? 100\n    const signal = options?.signal\n\n    if (signal?.aborted) {\n      throw new Error('Operation aborted')\n    }\n\n    const result = await this._contract.getActivePieces(dataSetId, offset, limit)\n\n    return {\n      pieces: result[0].map((piece: { data: string }, index: number) => {\n        try {\n          return {\n            pieceCid: hexToPieceCID(piece.data),\n            pieceId: Number(result[1][index]),\n          }\n        } catch (error) {\n          throw createError(\n            'PDPVerifier',\n            'getActivePieces',\n            `Failed to convert piece data to PieceCID: ${error instanceof Error ? error.message : String(error)}`,\n            error\n          )\n        }\n      }),\n      hasMore: Boolean(result[2]),\n    }\n  }\n\n  /**\n   * Get the PDPVerifier contract address for the current network\n   */\n  getContractAddress(): string {\n    return this._contract.target as string\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2348, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/pdp/index.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/pdp/index.ts"],"sourcesContent":["/**\n * Exports the PDP components\n *\n * @packageDocumentation\n * @module PDP\n * @example\n * ```ts\n * import { PDPAuthHelper, PDPServer, PDPVerifier } from '@filoz/synapse-sdk/pdp'\n * ```\n */\n\nexport { PDPAuthHelper } from './auth.ts'\nexport type {\n  AddPiecesResponse,\n  CreateDataSetResponse,\n  DataSetCreationStatusResponse,\n  FindPieceResponse,\n  PieceAdditionStatusResponse,\n} from './server.ts'\nexport { PDPServer } from './server.ts'\n// Export validation utilities for advanced use\nexport {\n  asDataSetData,\n  asDataSetPieceData,\n  isDataSetCreationStatusResponse,\n  isFindPieceResponse,\n  isPieceAdditionStatusResponse,\n  validateDataSetCreationStatusResponse,\n  validateFindPieceResponse,\n  validatePieceAdditionStatusResponse,\n} from './validation.ts'\nexport { PDPVerifier } from './verifier.ts'\n"],"names":[],"mappings":";AAWA,OAAO,EAAE,aAAa,EAAE,MAAM,WAAW,CAAA;AAQzC,OAAO,EAAE,SAAS,EAAE,MAAM,aAAa,CAAA;AAEvC,OAAO,EACL,aAAa,EACb,kBAAkB,EAClB,+BAA+B,EAC/B,mBAAmB,EACnB,6BAA6B,EAC7B,qCAAqC,EACrC,yBAAyB,EACzB,mCAAmC,GACpC,MAAM,iBAAiB,CAAA;AACxB,OAAO,EAAE,WAAW,EAAE,MAAM,eAAe,CAAA"}},
    {"offset": {"line": 2361, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/session/key.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/session/key.ts"],"sourcesContent":["/**\n * SessionKey - Tracks the user's approval of a session key\n *\n * Session keys allow the user to authorize an app to take actions on\n * their behalf without prompting their wallet for signatures.\n * Session keys have a scope and an expiration.\n * Session keys should be generated on the user's computer and persisted\n * in a safe place or discarded.\n *\n * @example\n * ```typescript\n * const sessionKey = synapse.createSessionkey(privateKey)\n * const expiries = await sessionKey.fetchExpiries([ADD_PIECES_TYPEHASH])\n * if (expiries[ADD_PIECES_TYPEHASH] * BigInt(1000) < BigInt(Date.now()) + HOUR_MILLIS) {\n *   const DAY_MILLIS = BigInt(24) * HOUR_MILLIS\n *   const loginTx = await sessionKey.login(BigInt(Date.now()) / BigInt(1000 + 30 * DAY_MILLIS), PDP_PERMISSIONS, \"example.com\")\n *   const loginReceipt = await loginTx.wait()\n * }\n * synapse.setSession(sessionKey)\n * const context = await synapse.storage.createContext()\n * ```\n */\n\nimport { ethers } from 'ethers'\nimport { EIP712_TYPE_HASHES } from '../utils/eip712.ts'\nimport { CONTRACT_ABIS, CONTRACT_ADDRESSES, getFilecoinNetworkType } from '../utils/index.ts'\n\nexport const CREATE_DATA_SET_TYPEHASH = EIP712_TYPE_HASHES.CreateDataSet\nexport const ADD_PIECES_TYPEHASH = EIP712_TYPE_HASHES.AddPieces\nexport const SCHEDULE_PIECE_REMOVALS_TYPEHASH = EIP712_TYPE_HASHES.SchedulePieceRemovals\nexport const DELETE_DATA_SET_TYPEHASH = EIP712_TYPE_HASHES.DeleteDataSet\n\n// These are the PDP-related permissions that can be granted to a session key.\n// They are bytes32 hex strings that can be supplied to fetchExpiries, login, and revoke.\nexport const PDP_PERMISSIONS = [\n  CREATE_DATA_SET_TYPEHASH,\n  ADD_PIECES_TYPEHASH,\n  SCHEDULE_PIECE_REMOVALS_TYPEHASH,\n  DELETE_DATA_SET_TYPEHASH,\n]\n\nexport const PDP_PERMISSION_NAMES: Record<string, string> = {\n  [CREATE_DATA_SET_TYPEHASH]: 'CreateDataSet',\n  [ADD_PIECES_TYPEHASH]: 'AddPieces',\n  [SCHEDULE_PIECE_REMOVALS_TYPEHASH]: 'SchedulePieceRemovals',\n  [DELETE_DATA_SET_TYPEHASH]: 'DeleteDataSet',\n}\n\nconst DEFAULT_ORIGIN: string = (globalThis as any).location?.hostname || 'unknown'\n\nexport class SessionKey {\n  private readonly _provider: ethers.Provider\n  private readonly _registry: ethers.Contract\n  private readonly _signer: ethers.Signer\n  private readonly _owner: ethers.Signer\n\n  public constructor(\n    provider: ethers.Provider,\n    sessionKeyRegistryAddress: string,\n    signer: ethers.Signer,\n    owner: ethers.Signer\n  ) {\n    this._provider = provider\n    this._registry = new ethers.Contract(sessionKeyRegistryAddress, CONTRACT_ABIS.SESSION_KEY_REGISTRY, owner)\n    this._signer = signer\n    this._owner = owner\n  }\n\n  getSigner(): ethers.Signer {\n    return this._signer\n  }\n\n  /**\n   * Queries current permission expiries from the registry\n   * @param permissions Expiries to fetch, as a list of bytes32 hex strings\n   * @return map of each permission to its expiry for this session key\n   */\n  async fetchExpiries(permissions: string[] = PDP_PERMISSIONS): Promise<Record<string, bigint>> {\n    const network = await getFilecoinNetworkType(this._provider)\n\n    const multicall = new ethers.Contract(\n      CONTRACT_ADDRESSES.MULTICALL3[network],\n      CONTRACT_ABIS.MULTICALL3,\n      this._provider\n    )\n    const registryInterface = new ethers.Interface(CONTRACT_ABIS.SESSION_KEY_REGISTRY)\n\n    const [ownerAddress, signerAddress, registryAddress] = await Promise.all([\n      this._owner.getAddress(),\n      this._signer.getAddress(),\n      this._registry.getAddress(),\n    ])\n\n    // Prepare multicall batch\n    const calls: Array<{ target: string; allowFailure: boolean; callData: string }> = []\n    for (const permission of permissions) {\n      calls.push({\n        target: registryAddress,\n        allowFailure: true,\n        callData: registryInterface.encodeFunctionData('authorizationExpiry', [\n          ownerAddress,\n          signerAddress,\n          permission,\n        ]),\n      })\n    }\n\n    // Execute multicall\n    const results = await multicall.aggregate3.staticCall(calls)\n\n    const expiries: Record<string, bigint> = {}\n    for (let i = 0; i < permissions.length; i++) {\n      expiries[PDP_PERMISSIONS[i]] = registryInterface.decodeFunctionResult(\n        'authorizationExpiry',\n        results[i].returnData\n      )[0]\n    }\n    return expiries\n  }\n\n  /**\n   * Authorize signer with permissions until expiry. This can also be used to\n   * renew existing authorization by updating the expiry.\n   *\n   * @param expiry unix time (block.timestamp) that the permissions expire\n   * @param permissions list of permissions granted to the signer, as a list of bytes32 hex strings\n   * @param origin the name of the application prompting this login\n   * @return signed and broadcasted login transaction details\n   */\n  async login(\n    expiry: bigint,\n    permissions: string[] = PDP_PERMISSIONS,\n    origin = DEFAULT_ORIGIN\n  ): Promise<ethers.TransactionResponse> {\n    return await this._registry.login(await this._signer.getAddress(), expiry, permissions, origin)\n  }\n\n  /**\n   * Invalidate signer permissions, setting their expiry to zero.\n   *\n   * @param permissions list of permissions removed from the signer, as a list of bytes32 hex strings\n   * @return signed and broadcasted revoke transaction details\n   */\n  async revoke(permissions: string[] = PDP_PERMISSIONS): Promise<ethers.TransactionResponse> {\n    return await this._registry.revoke(await this._signer.getAddress(), permissions)\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2455, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/session/index.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/session/index.ts"],"sourcesContent":["export * from './key.ts'\n"],"names":[],"mappings":";AAAA,cAAc,UAAU,CAAA"}},
    {"offset": {"line": 2462, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/sp-registry/service.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/sp-registry/service.ts"],"sourcesContent":["/**\n * SPRegistryService - Service for interacting with ServiceProviderRegistry contract\n *\n * Manages service provider registration, product offerings, and provider queries.\n * Handles encoding/decoding of product data internally.\n *\n * @example\n * ```typescript\n * import { SPRegistryService } from '@filoz/synapse-sdk/sp-registry'\n *\n * const spRegistry = await SPRegistryService.create(provider, registryAddress)\n *\n * // Register as a provider\n * const tx = await spRegistry.registerProvider(signer, {\n *   name: 'My Storage Service',\n *   description: 'Fast and reliable storage',\n *   pdpOffering: { ... }\n * })\n *\n * // Query providers\n * const providers = await spRegistry.getAllActiveProviders()\n * ```\n */\n\nimport { capabilitiesListToObject, decodePDPCapabilities, encodePDPCapabilities } from '@filoz/synapse-core/utils'\nimport { ethers } from 'ethers'\nimport { CONTRACT_ABIS, CONTRACT_ADDRESSES } from '../utils/constants.ts'\nimport { getFilecoinNetworkType } from '../utils/index.ts'\nimport type {\n  PDPOffering,\n  PDPServiceInfo,\n  ProductType,\n  ProviderInfo,\n  ProviderRegistrationInfo,\n  ServiceProduct,\n} from './types.ts'\n\nexport class SPRegistryService {\n  private readonly _provider: ethers.Provider\n  private readonly _registryAddress: string\n  private _registryContract: ethers.Contract | null = null\n\n  /**\n   * Constructor for SPRegistryService\n   */\n  constructor(provider: ethers.Provider, registryAddress: string) {\n    this._provider = provider\n    this._registryAddress = registryAddress\n  }\n\n  /**\n   * Create a new SPRegistryService instance\n   */\n  static async create(provider: ethers.Provider, registryAddress: string): Promise<SPRegistryService> {\n    return new SPRegistryService(provider, registryAddress)\n  }\n\n  /**\n   * Get cached registry contract instance or create new one\n   */\n  private _getRegistryContract(): ethers.Contract {\n    if (this._registryContract == null) {\n      this._registryContract = new ethers.Contract(\n        this._registryAddress,\n        CONTRACT_ABIS.SERVICE_PROVIDER_REGISTRY,\n        this._provider\n      )\n    }\n    return this._registryContract\n  }\n\n  // ========== Provider Management ==========\n\n  /**\n   * Register as a new service provider with optional PDP product\n   * @param signer - Signer to register as provider\n   * @param info - Provider registration information\n   * @returns Transaction response containing the provider ID\n   *\n   * @example\n   * ```typescript\n   * const tx = await spRegistry.registerProvider(signer, {\n   *   payee: '0x...', // Address that will receive payments\n   *   name: 'My Storage Provider',\n   *   description: 'High-performance storage service',\n   *   pdpOffering: {\n   *     serviceURL: 'https://provider.example.com',\n   *     minPieceSizeInBytes: SIZE_CONSTANTS.KiB,\n   *     maxPieceSizeInBytes: SIZE_CONSTANTS.GiB,\n   *     // ... other PDP fields\n   *   },\n   *   capabilities: { 'region': 'us-east', 'tier': 'premium' }\n   * })\n   *\n   * // Wait for transaction and get provider ID from event\n   * const receipt = await tx.wait()\n   * const event = receipt.logs.find(log =>\n   *   log.topics[0] === ethers.id('ProviderRegistered(uint256,address,address)')\n   * )\n   * const providerId = event ? parseInt(event.topics[1], 16) : null\n   * ```\n   */\n  async registerProvider(signer: ethers.Signer, info: ProviderRegistrationInfo): Promise<ethers.TransactionResponse> {\n    const contract = this._getRegistryContract().connect(signer) as ethers.Contract\n\n    // Get registration fee\n    const registrationFee = await contract.REGISTRATION_FEE()\n\n    // Prepare product data and capabilities\n    const productType = 0 // ProductType.PDP\n\n    const [capabilityKeys, capabilityValues] = encodePDPCapabilities(info.pdpOffering, info.capabilities)\n\n    // Register provider with all parameters in a single call\n    const tx = await contract.registerProvider(\n      info.payee,\n      info.name,\n      info.description,\n      productType,\n      capabilityKeys,\n      capabilityValues,\n      { value: registrationFee }\n    )\n\n    return tx\n  }\n\n  /**\n   * Update provider information\n   * @param signer - Provider's signer\n   * @param name - New name\n   * @param description - New description\n   * @returns Transaction response\n   */\n  async updateProviderInfo(\n    signer: ethers.Signer,\n    name: string,\n    description: string\n  ): Promise<ethers.TransactionResponse> {\n    const contract = this._getRegistryContract().connect(signer) as ethers.Contract\n    return await contract.updateProviderInfo(name, description)\n  }\n\n  /**\n   * Remove provider registration\n   * @param signer - Provider's signer\n   * @returns Transaction response\n   */\n  async removeProvider(signer: ethers.Signer): Promise<ethers.TransactionResponse> {\n    const contract = this._getRegistryContract().connect(signer) as ethers.Contract\n    return await contract.removeProvider()\n  }\n\n  // ========== Provider Queries ==========\n\n  /**\n   * Get provider information by ID\n   * @param providerId - Provider ID\n   * @returns Provider info with decoded products\n   */\n  async getProvider(providerId: number): Promise<ProviderInfo | null> {\n    try {\n      const contract = this._getRegistryContract()\n      // TODO: use getProviderWithProduct\n      const rawProvider = await contract.getProvider(providerId)\n\n      if (rawProvider.info.serviceProvider === ethers.ZeroAddress) {\n        return null\n      }\n\n      // Get products for this provider\n      const products = await this._getProviderProducts(providerId)\n\n      return this._convertToProviderInfo(providerId, rawProvider.info, products)\n    } catch (error) {\n      if (error instanceof Error && error.message.includes('Provider not found')) {\n        return null\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Get provider information by address\n   * @param address - Provider address\n   * @returns Provider info with decoded products\n   */\n  async getProviderByAddress(address: string): Promise<ProviderInfo | null> {\n    try {\n      const contract = this._getRegistryContract()\n      const provider = await contract.getProviderByAddress(address)\n\n      // Check if provider exists (beneficiary address will be zero if not found)\n      if (provider.info.serviceProvider === ethers.ZeroAddress) {\n        return null\n      }\n\n      // Get products for this provider and convert to ProviderInfo\n      const products = await this._getProviderProducts(Number(provider.providerId))\n      return this._convertToProviderInfo(Number(provider.providerId), provider.info, products)\n    } catch (error) {\n      console.warn('Error fetching provider by address:', error)\n      return null\n    }\n  }\n\n  /**\n   * Get provider ID by address\n   * @param address - Provider address\n   * @returns Provider ID (0 if not found)\n   */\n  async getProviderIdByAddress(address: string): Promise<number> {\n    const contract = this._getRegistryContract()\n    const id = await contract.getProviderIdByAddress(address)\n    return Number(id)\n  }\n\n  /**\n   * Get all active providers (handles pagination internally)\n   * @returns List of all active providers\n   */\n  async getAllActiveProviders(): Promise<ProviderInfo[]> {\n    const contract = this._getRegistryContract()\n    const providerPromises: Promise<ProviderInfo[]>[] = []\n    const pageSize = 50 // Fetch 50 providers at a time (conservative for multicall limits)\n    let offset = 0\n    let hasMore = true\n\n    // Loop through all pages and start fetching provider details in parallel\n    while (hasMore) {\n      const result = await contract.getAllActiveProviders(offset, pageSize)\n      const providerIds = result[0] // First element is the array of provider IDs\n      hasMore = result[1] // Second element is the hasMore flag\n\n      // Convert BigInt IDs to numbers and start fetching provider details\n      if (providerIds.length > 0) {\n        const ids = providerIds.map((id: bigint) => Number(id))\n        providerPromises.push(this.getProviders(ids))\n      }\n\n      offset += pageSize\n    }\n\n    // Wait for all provider details to be fetched and flatten the results\n    const providerBatches = await Promise.all(providerPromises)\n    return providerBatches.flat()\n  }\n\n  /**\n   * Get active providers by product type (handles pagination internally)\n   * @param productType - Product type to filter by\n   * @returns List of providers with specified product type\n   */\n  async getActiveProvidersByProductType(productType: ProductType): Promise<ProviderInfo[]> {\n    const contract = this._getRegistryContract()\n    const providerPromises: Promise<ProviderInfo[]>[] = []\n\n    let offset = 0\n    const limit = 50 // Fetch in batches (conservative for multicall limits)\n    let hasMore = true\n\n    // Loop through all pages and start fetching provider details in parallel\n    while (hasMore) {\n      const result = await contract.getProvidersByProductType(productType, true, offset, limit)\n\n      // Convert BigInt IDs to numbers and start fetching provider details\n      if (result.providerIds.length > 0) {\n        const ids = result.providerIds.map((id: bigint) => Number(id))\n        providerPromises.push(this.getProviders(ids))\n      }\n\n      hasMore = result.hasMore\n      offset += limit\n    }\n\n    // Wait for all provider details to be fetched and flatten the results\n    const providerBatches = await Promise.all(providerPromises)\n    const allProviders = providerBatches.flat()\n\n    return allProviders\n  }\n\n  /**\n   * Check if provider is active\n   * @param providerId - Provider ID\n   * @returns Whether provider is active\n   */\n  async isProviderActive(providerId: number): Promise<boolean> {\n    const contract = this._getRegistryContract()\n    return await contract.isProviderActive(providerId)\n  }\n\n  /**\n   * Check if address is a registered provider\n   * @param address - Address to check\n   * @returns Whether address is registered\n   */\n  async isRegisteredProvider(address: string): Promise<boolean> {\n    const contract = this._getRegistryContract()\n    return await contract.isRegisteredProvider(address)\n  }\n\n  /**\n   * Get total number of providers\n   * @returns Total provider count\n   */\n  async getProviderCount(): Promise<number> {\n    const contract = this._getRegistryContract()\n    const count = await contract.getProviderCount()\n    return Number(count)\n  }\n\n  /**\n   * Get number of active providers\n   * @returns Active provider count\n   */\n  async activeProviderCount(): Promise<number> {\n    const contract = this._getRegistryContract()\n    const count = await contract.activeProviderCount()\n    return Number(count)\n  }\n\n  // ========== Product Management ==========\n\n  /**\n   * Add PDP product to provider\n   * @param signer - Provider's signer\n   * @param pdpOffering - PDP offering details\n   * @param capabilities - Optional capability keys\n   * @returns Transaction response\n   */\n  async addPDPProduct(\n    signer: ethers.Signer,\n    pdpOffering: PDPOffering,\n    capabilities: Record<string, string> = {}\n  ): Promise<ethers.TransactionResponse> {\n    const contract = this._getRegistryContract().connect(signer) as ethers.Contract\n\n    // Encode PDP offering\n    const [capabilityKeys, capabilityValues] = encodePDPCapabilities(pdpOffering, capabilities)\n\n    // Add product\n    return await contract.addProduct(\n      0, // ProductType.PDP\n      capabilityKeys,\n      capabilityValues\n    )\n  }\n\n  /**\n   * Update PDP product with capabilities\n   * @param signer - Provider's signer\n   * @param pdpOffering - Updated PDP offering\n   * @param capabilities - Updated capability key-value pairs\n   * @returns Transaction response\n   */\n  async updatePDPProduct(\n    signer: ethers.Signer,\n    pdpOffering: PDPOffering,\n    capabilities: Record<string, string> = {}\n  ): Promise<ethers.TransactionResponse> {\n    const contract = this._getRegistryContract().connect(signer) as ethers.Contract\n\n    // Encode PDP offering\n    const [capabilityKeys, capabilityValues] = encodePDPCapabilities(pdpOffering, capabilities)\n\n    // Update product\n    return await contract.updateProduct(\n      0, // ProductType.PDP\n      capabilityKeys,\n      capabilityValues\n    )\n  }\n\n  /**\n   * Remove product from provider\n   * @param signer - Provider's signer\n   * @param productType - Type of product to remove\n   * @returns Transaction response\n   */\n  async removeProduct(signer: ethers.Signer, productType: ProductType): Promise<ethers.TransactionResponse> {\n    const contract = this._getRegistryContract().connect(signer) as ethers.Contract\n    return await contract.removeProduct(productType)\n  }\n\n  /**\n   * Get PDP service info for a provider\n   * @param providerId - Provider ID\n   * @returns PDP service info or null if not found\n   */\n  async getPDPService(providerId: number): Promise<PDPServiceInfo | null> {\n    try {\n      const contract = this._getRegistryContract()\n      const result = await contract.getProviderWithProduct(providerId, 0) // 0 = ProductType.PDP\n\n      // This also handles the case where the product does not exist\n      if (!result.product.isActive) {\n        return null\n      }\n\n      const capabilities = capabilitiesListToObject(result.product.capabilityKeys, result.productCapabilityValues)\n\n      return {\n        offering: decodePDPCapabilities(capabilities),\n        capabilities,\n        isActive: result.product.isActive,\n      }\n    } catch {\n      return null\n    }\n  }\n\n  /**\n   * Check if provider has a specific product type\n   * @param providerId - Provider ID\n   * @param productType - Product type to check\n   * @returns Whether provider has the product\n   */\n  async providerHasProduct(providerId: number, productType: ProductType): Promise<boolean> {\n    const contract = this._getRegistryContract()\n    return await contract.providerHasProduct(providerId, productType)\n  }\n\n  // ========== Batch Operations ==========\n\n  /**\n   * Get multiple providers by IDs using Multicall3 for efficiency\n   * @param providerIds - Array of provider IDs\n   * @returns Array of provider info\n   */\n  async getProviders(providerIds: number[]): Promise<ProviderInfo[]> {\n    if (providerIds.length === 0) {\n      return []\n    }\n\n    try {\n      // Use Multicall3 for efficiency\n      const result = await this._getProvidersWithMulticall(providerIds)\n      return result\n    } catch (_error) {\n      // TODO: Remove this fallback block and properly mock Multicall3 in tests\n      // The fallback is only needed because SPRegistryService tests don't currently\n      // mock Multicall3 calls. Once proper test infrastructure is in place, this\n      // try/catch and the _getProvidersIndividually method can be removed.\n      // Fall back to individual calls if Multicall3 fails\n      const result = await this._getProvidersIndividually(providerIds)\n      return result\n    }\n  }\n\n  /**\n   * Get providers using Multicall3 for batch efficiency\n   */\n  private async _getProvidersWithMulticall(providerIds: number[]): Promise<ProviderInfo[]> {\n    const network = await getFilecoinNetworkType(this._provider)\n    const multicall3Address = CONTRACT_ADDRESSES.MULTICALL3[network]\n    const multicall = new ethers.Contract(multicall3Address, CONTRACT_ABIS.MULTICALL3, this._provider)\n    const iface = new ethers.Interface(CONTRACT_ABIS.SERVICE_PROVIDER_REGISTRY)\n\n    // Prepare multicall batch\n    const calls = this._prepareMulticallCalls(providerIds, iface)\n\n    // Execute multicall\n    const results = await multicall.aggregate3.staticCall(calls)\n\n    // Process results\n    return this._processMulticallResults(providerIds, results, iface)\n  }\n\n  /**\n   * Prepare calls for Multicall3 batch\n   */\n  private _prepareMulticallCalls(\n    providerIds: number[],\n    iface: ethers.Interface\n  ): Array<{ target: string; allowFailure: boolean; callData: string }> {\n    const calls: Array<{ target: string; allowFailure: boolean; callData: string }> = []\n\n    for (const id of providerIds) {\n      // Add getProviderWithProduct call\n      calls.push({\n        target: this._registryAddress,\n        allowFailure: true,\n        callData: iface.encodeFunctionData('getProviderWithProduct', [id, 0]),\n      })\n    }\n\n    return calls\n  }\n\n  /**\n   * Process Multicall3 results into ProviderInfo array\n   */\n  private _processMulticallResults(providerIds: number[], results: any[], iface: ethers.Interface): ProviderInfo[] {\n    const providers: ProviderInfo[] = []\n\n    for (let i = 0; i < providerIds.length; i++) {\n      if (!results[i].success) {\n        continue\n      }\n\n      try {\n        const [, rawProvider, product, productCapabilityValues] = iface.decodeFunctionResult(\n          'getProviderWithProduct',\n          results[i].returnData\n        )[0]\n\n        const capabilities = capabilitiesListToObject(product.capabilityKeys, productCapabilityValues)\n        // Convert to ProviderInfo\n        const providerInfo = this._convertToProviderInfo(providerIds[i], rawProvider, [\n          {\n            type: 'PDP',\n            isActive: product.isActive,\n            capabilities,\n            data: decodePDPCapabilities(capabilities),\n          },\n        ])\n        if (providerInfo.serviceProvider === ethers.ZeroAddress) {\n          continue\n        }\n        providers.push(providerInfo)\n      } catch {\n        // Skip failed decoding\n      }\n    }\n\n    return providers\n  }\n\n  /**\n   * Fallback method to get providers individually\n   */\n  private async _getProvidersIndividually(providerIds: number[]): Promise<ProviderInfo[]> {\n    const providers: ProviderInfo[] = []\n    const promises = providerIds.map((id) => this.getProvider(id))\n    const results = await Promise.all(promises)\n\n    for (const provider of results) {\n      if (provider != null) {\n        providers.push(provider)\n      }\n    }\n\n    return providers\n  }\n\n  // ========== Internal Helpers ==========\n\n  /**\n   * Get products for a provider\n   * @param providerId - Provider ID\n   * @returns Array of decoded service products\n   */\n  private async _getProviderProducts(providerId: number): Promise<ServiceProduct[]> {\n    const products: ServiceProduct[] = []\n\n    // Get PDP product directly - getPDPService returns null if product doesn't exist\n    const pdpService = await this.getPDPService(providerId)\n    if (pdpService != null) {\n      products.push({\n        type: 'PDP',\n        isActive: pdpService.isActive,\n        capabilities: pdpService.capabilities,\n        data: pdpService.offering,\n      })\n    }\n\n    // Future: Add other product types here\n\n    return products\n  }\n\n  /**\n   * Convert raw provider data to ProviderInfo\n   */\n  private _convertToProviderInfo(providerId: number, providerInfo: any, productsArray: ServiceProduct[]): ProviderInfo {\n    // Convert products array to Record for direct access by type\n    const products: Partial<Record<'PDP', ServiceProduct>> = {}\n\n    for (const product of productsArray) {\n      if (product.type === 'PDP') {\n        products.PDP = product\n      }\n    }\n\n    return {\n      id: providerId,\n      serviceProvider: providerInfo.serviceProvider,\n      payee: providerInfo.payee,\n      name: providerInfo.name,\n      description: providerInfo.description,\n      active: providerInfo.isActive,\n      products,\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2744, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/sp-registry/index.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/sp-registry/index.ts"],"sourcesContent":["/**\n * ServiceProviderRegistry module\n * @module sp-registry\n */\n\nexport { SPRegistryService } from './service.ts'\nexport type {\n  PDPOffering,\n  PDPServiceInfo,\n  ProductType,\n  ProviderInfo,\n  ProviderRegistrationInfo,\n  ServiceProduct,\n} from './types.ts'\n"],"names":[],"mappings":";AAKA,OAAO,EAAE,iBAAiB,EAAE,MAAM,cAAc,CAAA"}},
    {"offset": {"line": 2751, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/storage/context.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/storage/context.ts"],"sourcesContent":["/**\n * StorageContext - Represents a specific Service Provider + Data Set pair\n *\n * This class provides a connection to a specific service provider and data set,\n * handling uploads and downloads within that context. It manages:\n * - Provider selection and data set creation/reuse\n * - PieceCID calculation and validation\n * - Payment rail setup through Warm Storage\n * - Batched piece additions for efficiency\n *\n * @example\n * ```typescript\n * // Create storage context (auto-selects provider)\n * const context = await synapse.storage.createContext()\n *\n * // Upload data to this context's provider\n * const result = await context.upload(data)\n * console.log('Stored at:', result.pieceCid)\n *\n * // Download data from this context's provider\n * const retrieved = await context.download(result.pieceCid)\n * ```\n */\n\nimport { asPieceCID } from '@filoz/synapse-core/piece'\nimport * as SP from '@filoz/synapse-core/sp'\nimport { randIndex, randU256 } from '@filoz/synapse-core/utils'\nimport type { ethers } from 'ethers'\nimport type { Hex } from 'viem'\nimport type { PaymentsService } from '../payments/index.ts'\nimport { PDPAuthHelper, PDPServer } from '../pdp/index.ts'\nimport { PDPVerifier } from '../pdp/verifier.ts'\nimport { SPRegistryService } from '../sp-registry/index.ts'\nimport type { ProviderInfo } from '../sp-registry/types.ts'\nimport type { Synapse } from '../synapse.ts'\nimport type {\n  CreateContextsOptions,\n  DownloadOptions,\n  EnhancedDataSetInfo,\n  MetadataEntry,\n  PieceCID,\n  PieceStatus,\n  PreflightInfo,\n  ProviderSelectionResult,\n  StorageServiceOptions,\n  UploadCallbacks,\n  UploadOptions,\n  UploadResult,\n} from '../types.ts'\nimport {\n  calculateLastProofDate,\n  createError,\n  epochToDate,\n  getCurrentEpoch,\n  METADATA_KEYS,\n  SIZE_CONSTANTS,\n  timeUntilEpoch,\n} from '../utils/index.ts'\nimport { combineMetadata, metadataMatches, objectToEntries, validatePieceMetadata } from '../utils/metadata.ts'\nimport type { WarmStorageService } from '../warm-storage/index.ts'\n\nconst NO_REMAINING_PROVIDERS_ERROR_MESSAGE = 'No approved service providers available'\n\nexport class StorageContext {\n  private readonly _synapse: Synapse\n  private readonly _provider: ProviderInfo\n  private readonly _pdpServer: PDPServer\n  private readonly _warmStorageService: WarmStorageService\n  private readonly _warmStorageAddress: string\n  private readonly _withCDN: boolean\n  private readonly _signer: ethers.Signer\n  private readonly _uploadBatchSize: number\n  private _dataSetId: number | undefined\n  private readonly _dataSetMetadata: Record<string, string>\n\n  // AddPieces batching state\n  private _pendingPieces: Array<{\n    pieceCid: PieceCID\n    resolve: (pieceId: number) => void\n    reject: (error: Error) => void\n    callbacks?: UploadCallbacks\n    metadata?: MetadataEntry[]\n  }> = []\n\n  private _isProcessing: boolean = false\n\n  // Upload tracking for batching (using symbols for simple idempotency)\n  private _activeUploads: Set<symbol> = new Set()\n  // Timeout to wait before processing batch if there are other in-progress uploads, this allows\n  // more uploads to join our batch\n  private readonly _uploadBatchWaitTimeout: number = 15000 // 15 seconds, half Filecoin's blocktime\n\n  // Public properties from interface\n  public readonly serviceProvider: string\n\n  // Getter for withCDN\n  get withCDN(): boolean {\n    return this._withCDN\n  }\n\n  // Getter for provider info\n  get provider(): ProviderInfo {\n    return this._provider\n  }\n\n  // Getter for data set metadata\n  get dataSetMetadata(): Record<string, string> {\n    return this._dataSetMetadata\n  }\n\n  // Getter for data set ID\n  get dataSetId(): number | undefined {\n    return this._dataSetId\n  }\n\n  /**\n   * Validate data size against minimum and maximum limits\n   * @param sizeBytes - Size of data in bytes\n   * @param context - Context for error messages (e.g., 'upload', 'preflightUpload')\n   * @throws Error if size is outside allowed limits\n   */\n  private static validateRawSize(sizeBytes: number, context: string): void {\n    if (sizeBytes < SIZE_CONSTANTS.MIN_UPLOAD_SIZE) {\n      throw createError(\n        'StorageContext',\n        context,\n        `Data size ${sizeBytes} bytes is below minimum allowed size of ${SIZE_CONSTANTS.MIN_UPLOAD_SIZE} bytes`\n      )\n    }\n\n    if (sizeBytes > SIZE_CONSTANTS.MAX_UPLOAD_SIZE) {\n      // This restriction is ~arbitrary for now, but there is a hard limit on PDP uploads in Curio\n      // of 254 MiB, see: https://github.com/filecoin-project/curio/blob/3ddc785218f4e237f0c073bac9af0b77d0f7125c/pdp/handlers_upload.go#L38\n      // We can increase this in future, arbitrarily, but we first need to:\n      //  - Handle streaming input.\n      //  - Chunking input at size 254 MiB and make a separate piece per each chunk\n      //  - Combine the pieces using \"subPieces\" and an aggregate PieceCID in our AddRoots call\n      throw createError(\n        'StorageContext',\n        context,\n        `Data size ${sizeBytes} bytes exceeds maximum allowed size of ${\n          SIZE_CONSTANTS.MAX_UPLOAD_SIZE\n        } bytes (${Math.floor(SIZE_CONSTANTS.MAX_UPLOAD_SIZE / 1024 / 1024)} MiB)`\n      )\n    }\n  }\n\n  constructor(\n    synapse: Synapse,\n    warmStorageService: WarmStorageService,\n    provider: ProviderInfo,\n    dataSetId: number | undefined,\n    options: StorageServiceOptions,\n    dataSetMetadata: Record<string, string>\n  ) {\n    this._synapse = synapse\n    this._provider = provider\n    this._withCDN = options.withCDN ?? false\n    this._signer = synapse.getSigner()\n    this._warmStorageService = warmStorageService\n    this._uploadBatchSize = Math.max(1, options.uploadBatchSize ?? SIZE_CONSTANTS.DEFAULT_UPLOAD_BATCH_SIZE)\n    this._dataSetMetadata = dataSetMetadata\n\n    // Set public properties\n    this._dataSetId = dataSetId\n    this.serviceProvider = provider.serviceProvider\n\n    // Get WarmStorage address from Synapse (which already handles override)\n    this._warmStorageAddress = synapse.getWarmStorageAddress()\n\n    // Create PDPAuthHelper for signing operations\n    const authHelper = new PDPAuthHelper(this._warmStorageAddress, this._signer, BigInt(synapse.getChainId()))\n\n    // Create PDPServer instance with provider URL from PDP product\n    if (!provider.products.PDP?.data.serviceURL) {\n      throw new Error(`Provider ${provider.id} does not have a PDP product with serviceURL`)\n    }\n    this._pdpServer = new PDPServer(authHelper, provider.products.PDP.data.serviceURL)\n  }\n\n  /**\n   * Creates new storage contexts with specified options\n   * Each context corresponds to a different data set\n   */\n  static async createContexts(\n    synapse: Synapse,\n    warmStorageService: WarmStorageService,\n    options: CreateContextsOptions\n  ): Promise<StorageContext[]> {\n    const count = options?.count ?? 2\n    const resolutions: ProviderSelectionResult[] = []\n    const clientAddress = await synapse.getClient().getAddress()\n    const registryAddress = warmStorageService.getServiceProviderRegistryAddress()\n    const spRegistry = new SPRegistryService(synapse.getProvider(), registryAddress)\n    if (options.dataSetIds) {\n      const selections = []\n      for (const dataSetId of new Set(options.dataSetIds)) {\n        selections.push(\n          StorageContext.resolveByDataSetId(dataSetId, warmStorageService, spRegistry, clientAddress, {\n            withCDN: options.withCDN,\n            withIpni: options.withIpni,\n            dev: options.dev,\n            metadata: options.metadata,\n          })\n        )\n        if (selections.length >= count) {\n          break\n        }\n      }\n      resolutions.push(...(await Promise.all(selections)))\n    }\n    const resolvedProviderIds = resolutions.map((resolution) => resolution.provider.id)\n    if (resolutions.length < count) {\n      if (options.providerIds) {\n        const selections = []\n        // NOTE: Set.difference is unavailable in some targets\n        for (const providerId of [...new Set(options.providerIds)].filter(\n          (providerId) => !resolvedProviderIds.includes(providerId)\n        )) {\n          selections.push(\n            StorageContext.resolveByProviderId(\n              clientAddress,\n              providerId,\n              options.metadata ?? {},\n              warmStorageService,\n              spRegistry,\n              options.forceCreateDataSets\n            )\n          )\n          resolvedProviderIds.push(providerId)\n          if (selections.length + resolutions.length >= count) {\n            break\n          }\n        }\n        resolutions.push(...(await Promise.all(selections)))\n      }\n    }\n    if (resolutions.length < count) {\n      const excludeProviderIds = [...(options.excludeProviderIds ?? []), ...resolvedProviderIds]\n      for (let i = resolutions.length; i < count; i++) {\n        try {\n          const resolution = await StorageContext.smartSelectProvider(\n            clientAddress,\n            options.metadata ?? {},\n            warmStorageService,\n            spRegistry,\n            excludeProviderIds,\n            options.forceCreateDataSets ?? false,\n            options.withIpni ?? false,\n            options.dev ?? false\n          )\n          excludeProviderIds.push(resolution.provider.id)\n          resolutions.push(resolution)\n        } catch (error) {\n          if (error instanceof Error && error.message.includes(NO_REMAINING_PROVIDERS_ERROR_MESSAGE)) {\n            break\n          }\n          throw error\n        }\n      }\n    }\n    return await Promise.all(\n      resolutions.map(\n        async (resolution) =>\n          await StorageContext.createWithSelectedProvider(resolution, synapse, warmStorageService, options)\n      )\n    )\n  }\n\n  /**\n   * Static factory method to create a StorageContext\n   * Handles provider selection and data set selection/creation\n   */\n  static async create(\n    synapse: Synapse,\n    warmStorageService: WarmStorageService,\n    options: StorageServiceOptions = {}\n  ): Promise<StorageContext> {\n    // Create SPRegistryService\n    const registryAddress = warmStorageService.getServiceProviderRegistryAddress()\n    const spRegistry = new SPRegistryService(synapse.getProvider(), registryAddress)\n\n    // Resolve provider and data set based on options\n    const resolution = await StorageContext.resolveProviderAndDataSet(synapse, warmStorageService, spRegistry, options)\n\n    return await StorageContext.createWithSelectedProvider(resolution, synapse, warmStorageService, options)\n  }\n\n  private static async createWithSelectedProvider(\n    resolution: ProviderSelectionResult,\n    synapse: Synapse,\n    warmStorageService: WarmStorageService,\n    options: StorageServiceOptions = {}\n  ): Promise<StorageContext> {\n    // Notify callback about provider selection\n    try {\n      options.callbacks?.onProviderSelected?.(resolution.provider)\n    } catch (error) {\n      // Log but don't propagate callback errors\n      console.error('Error in onProviderSelected callback:', error)\n    }\n\n    if (resolution.dataSetId !== -1) {\n      options.callbacks?.onDataSetResolved?.({\n        isExisting: resolution.dataSetId !== -1,\n        dataSetId: resolution.dataSetId,\n        provider: resolution.provider,\n      })\n    }\n\n    return new StorageContext(\n      synapse,\n      warmStorageService,\n      resolution.provider,\n      resolution.dataSetId === -1 ? undefined : resolution.dataSetId,\n      options,\n      resolution.dataSetMetadata\n    )\n  }\n\n  /**\n   * Resolve provider and data set based on provided options\n   * Uses lazy loading to minimize RPC calls\n   */\n  private static async resolveProviderAndDataSet(\n    synapse: Synapse,\n    warmStorageService: WarmStorageService,\n    spRegistry: SPRegistryService,\n    options: StorageServiceOptions\n  ): Promise<ProviderSelectionResult> {\n    const clientAddress = await synapse.getClient().getAddress()\n\n    // Handle explicit data set ID selection (highest priority)\n    if (options.dataSetId != null && options.forceCreateDataSet !== true) {\n      return await StorageContext.resolveByDataSetId(\n        options.dataSetId,\n        warmStorageService,\n        spRegistry,\n        clientAddress,\n        options\n      )\n    }\n\n    // Convert options to metadata format - merge withCDN flag into metadata if needed\n    const requestedMetadata = combineMetadata(options.metadata, options.withCDN)\n\n    // Handle explicit provider ID selection\n    if (options.providerId != null) {\n      return await StorageContext.resolveByProviderId(\n        clientAddress,\n        options.providerId,\n        requestedMetadata,\n        warmStorageService,\n        spRegistry,\n        options.forceCreateDataSet\n      )\n    }\n\n    // Handle explicit provider address selection\n    if (options.providerAddress != null) {\n      return await StorageContext.resolveByProviderAddress(\n        options.providerAddress,\n        warmStorageService,\n        spRegistry,\n        clientAddress,\n        requestedMetadata,\n        options.forceCreateDataSet\n      )\n    }\n\n    // Smart selection when no specific parameters provided\n    return await StorageContext.smartSelectProvider(\n      clientAddress,\n      requestedMetadata,\n      warmStorageService,\n      spRegistry,\n      options.excludeProviderIds ?? [],\n      options.forceCreateDataSet ?? false,\n      options.withIpni ?? false,\n      options.dev ?? false\n    )\n  }\n\n  /**\n   * Resolve using a specific data set ID\n   */\n  private static async resolveByDataSetId(\n    dataSetId: number,\n    warmStorageService: WarmStorageService,\n    spRegistry: SPRegistryService,\n    signerAddress: string,\n    options: StorageServiceOptions\n  ): Promise<ProviderSelectionResult> {\n    // Fetch data sets to find the specific one\n    const dataSets = await warmStorageService.getClientDataSetsWithDetails(signerAddress)\n    const dataSet = dataSets.find((ds) => ds.pdpVerifierDataSetId === dataSetId)\n\n    if (dataSet == null || !dataSet.isLive || !dataSet.isManaged) {\n      throw createError(\n        'StorageContext',\n        'resolveByDataSetId',\n        `Data set ${dataSetId} not found, not owned by ${signerAddress}, ` +\n          'or not managed by the current WarmStorage contract'\n      )\n    }\n\n    // Validate consistency with other parameters if provided\n    if (options.providerId != null || options.providerAddress != null) {\n      await StorageContext.validateDataSetConsistency(dataSet, options, spRegistry)\n    }\n\n    // Look up provider by ID from the data set\n    const provider = await spRegistry.getProvider(dataSet.providerId)\n    if (provider == null) {\n      throw createError(\n        'StorageContext',\n        'resolveByDataSetId',\n        `Provider ID ${dataSet.providerId} for data set ${dataSetId} not found in registry`\n      )\n    }\n\n    // Validate CDN settings match if specified\n    if (options.withCDN != null && dataSet.withCDN !== options.withCDN) {\n      throw createError(\n        'StorageContext',\n        'resolveByDataSetId',\n        `Data set ${dataSetId} has CDN ${dataSet.withCDN ? 'enabled' : 'disabled'}, ` +\n          `but requested ${options.withCDN ? 'enabled' : 'disabled'}`\n      )\n    }\n\n    // Backfill data set metadata from chain\n    const dataSetMetadata = await warmStorageService.getDataSetMetadata(dataSetId)\n\n    return {\n      provider,\n      dataSetId,\n      isExisting: true,\n      dataSetMetadata,\n    }\n  }\n\n  /**\n   * Validate data set consistency with provided options\n   */\n  private static async validateDataSetConsistency(\n    dataSet: EnhancedDataSetInfo,\n    options: StorageServiceOptions,\n    spRegistry: SPRegistryService\n  ): Promise<void> {\n    // Validate provider ID if specified\n    if (options.providerId != null) {\n      if (dataSet.providerId !== options.providerId) {\n        throw createError(\n          'StorageContext',\n          'validateDataSetConsistency',\n          `Data set ${dataSet.pdpVerifierDataSetId} belongs to provider ID ${dataSet.providerId}, ` +\n            `but provider ID ${options.providerId} was requested`\n        )\n      }\n    }\n\n    // Validate provider address if specified\n    if (options.providerAddress != null) {\n      // Look up the actual provider to get its serviceProvider address\n      const actualProvider = await spRegistry.getProvider(dataSet.providerId)\n      if (\n        actualProvider == null ||\n        actualProvider.serviceProvider.toLowerCase() !== options.providerAddress.toLowerCase()\n      ) {\n        throw createError(\n          'StorageContext',\n          'validateDataSetConsistency',\n          `Data set ${dataSet.pdpVerifierDataSetId} belongs to provider ${actualProvider?.serviceProvider ?? 'unknown'}, ` +\n            `but provider ${options.providerAddress} was requested`\n        )\n      }\n    }\n  }\n\n  /**\n   * Resolve using a specific provider ID\n   */\n  private static async resolveByProviderId(\n    signerAddress: string,\n    providerId: number,\n    requestedMetadata: Record<string, string>,\n    warmStorageService: WarmStorageService,\n    spRegistry: SPRegistryService,\n    forceCreateDataSet?: boolean\n  ): Promise<ProviderSelectionResult> {\n    // Fetch provider (always) and dataSets (only if not forcing) in parallel\n    const [provider, dataSets] = await Promise.all([\n      spRegistry.getProvider(providerId),\n      forceCreateDataSet ? Promise.resolve(null) : warmStorageService.getClientDataSetsWithDetails(signerAddress),\n    ])\n\n    if (provider == null) {\n      throw createError('StorageContext', 'resolveByProviderId', `Provider ID ${providerId} not found in registry`)\n    }\n\n    // If forcing creation, skip the search for existing data sets\n    if (forceCreateDataSet === true) {\n      return {\n        provider,\n        dataSetId: -1, // Marker for new data set\n        isExisting: false,\n        dataSetMetadata: requestedMetadata,\n      }\n    }\n\n    // dataSets is guaranteed non-null here since forceCreateDataSet is false\n\n    // Filter for this provider's data sets with matching metadata\n    const providerDataSets = (\n      dataSets as Awaited<ReturnType<typeof warmStorageService.getClientDataSetsWithDetails>>\n    ).filter((ps) => {\n      if (ps.providerId !== provider.id || !ps.isLive || !ps.isManaged || ps.pdpEndEpoch !== 0) {\n        return false\n      }\n      // Check if metadata matches\n      return metadataMatches(ps.metadata, requestedMetadata)\n    })\n\n    if (providerDataSets.length > 0) {\n      // Sort by preference: data sets with pieces first, then by ID\n      const sorted = providerDataSets.sort((a, b) => {\n        if (a.currentPieceCount > 0 && b.currentPieceCount === 0) return -1\n        if (b.currentPieceCount > 0 && a.currentPieceCount === 0) return 1\n        return a.pdpVerifierDataSetId - b.pdpVerifierDataSetId\n      })\n\n      // Fetch metadata for existing data set\n      const dataSetMetadata = await warmStorageService.getDataSetMetadata(sorted[0].pdpVerifierDataSetId)\n\n      return {\n        provider,\n        dataSetId: sorted[0].pdpVerifierDataSetId,\n        isExisting: true,\n        dataSetMetadata,\n      }\n    }\n\n    // Need to create new data set\n    return {\n      provider,\n      dataSetId: -1, // Marker for new data set\n      isExisting: false,\n      dataSetMetadata: requestedMetadata,\n    }\n  }\n\n  /**\n   * Resolve using a specific provider address\n   */\n  private static async resolveByProviderAddress(\n    providerAddress: string,\n    warmStorageService: WarmStorageService,\n    spRegistry: SPRegistryService,\n    signerAddress: string,\n    requestedMetadata: Record<string, string>,\n    forceCreateDataSet?: boolean\n  ): Promise<ProviderSelectionResult> {\n    // Get provider by address\n    const provider = await spRegistry.getProviderByAddress(providerAddress)\n    if (provider == null) {\n      throw createError(\n        'StorageContext',\n        'resolveByProviderAddress',\n        `Provider ${providerAddress} not found in registry`\n      )\n    }\n\n    // Use the providerId resolution logic\n    return await StorageContext.resolveByProviderId(\n      signerAddress,\n      provider.id,\n      requestedMetadata,\n      warmStorageService,\n      spRegistry,\n      forceCreateDataSet\n    )\n  }\n\n  /**\n   * Smart provider selection algorithm\n   * Prioritizes existing data sets and provider health\n   */\n  private static async smartSelectProvider(\n    signerAddress: string,\n    requestedMetadata: Record<string, string>,\n    warmStorageService: WarmStorageService,\n    spRegistry: SPRegistryService,\n    excludeProviderIds: number[],\n    forceCreateDataSet: boolean,\n    withIpni: boolean,\n    dev: boolean\n  ): Promise<ProviderSelectionResult> {\n    // Strategy:\n    // 1. Try to find existing data sets first\n    // 2. If no existing data sets, find a healthy provider\n\n    // Get client's data sets\n    const dataSets = await warmStorageService.getClientDataSetsWithDetails(signerAddress)\n\n    const skipProviderIds = new Set<number>(excludeProviderIds)\n    // Filter for managed data sets with matching metadata\n    const managedDataSets = dataSets.filter(\n      (ps) =>\n        ps.isLive &&\n        ps.isManaged &&\n        ps.pdpEndEpoch === 0 &&\n        metadataMatches(ps.metadata, requestedMetadata) &&\n        !skipProviderIds.has(ps.providerId)\n    )\n\n    if (managedDataSets.length > 0 && !forceCreateDataSet) {\n      // Prefer data sets with pieces, sort by ID (older first)\n      const sorted = managedDataSets.sort((a, b) => {\n        if (a.currentPieceCount > 0 && b.currentPieceCount === 0) return -1\n        if (b.currentPieceCount > 0 && a.currentPieceCount === 0) return 1\n        return a.pdpVerifierDataSetId - b.pdpVerifierDataSetId\n      })\n\n      // Create async generator that yields providers lazily\n      async function* generateProviders(): AsyncGenerator<ProviderInfo> {\n        // First, yield providers from existing data sets (in sorted order)\n        for (const dataSet of sorted) {\n          if (skipProviderIds.has(dataSet.providerId)) {\n            continue\n          }\n          skipProviderIds.add(dataSet.providerId)\n          const provider = await spRegistry.getProvider(dataSet.providerId)\n\n          if (provider == null) {\n            console.warn(\n              `Provider ID ${dataSet.providerId} for data set ${dataSet.pdpVerifierDataSetId} is not currently approved`\n            )\n            continue\n          }\n\n          if (withIpni && provider.products.PDP?.data.ipniIpfs === false) {\n            continue\n          }\n\n          const serviceStatus = provider.products.PDP?.capabilities?.serviceStatus\n          if (!dev && serviceStatus === '0x646576') {\n            // \"dev\" in hex\n            continue\n          }\n\n          yield provider\n        }\n      }\n\n      try {\n        const selectedProvider = await StorageContext.selectProviderWithPing(generateProviders())\n\n        // Find the first matching data set ID for this provider\n        // Match by provider ID (stable identifier in the registry)\n        const matchingDataSet = sorted.find((ps) => ps.providerId === selectedProvider.id)\n\n        if (matchingDataSet == null) {\n          console.warn(\n            `Could not match selected provider ${selectedProvider.serviceProvider} (ID: ${selectedProvider.id}) ` +\n              `to existing data sets. Falling back to selecting from all providers.`\n          )\n          // Fall through to select from all approved providers below\n        } else {\n          // Fetch metadata for existing data set\n          const dataSetMetadata = await warmStorageService.getDataSetMetadata(matchingDataSet.pdpVerifierDataSetId)\n\n          return {\n            provider: selectedProvider,\n            dataSetId: matchingDataSet.pdpVerifierDataSetId,\n            isExisting: true,\n            dataSetMetadata,\n          }\n        }\n      } catch (_error) {\n        console.warn('All providers from existing data sets failed health check. Falling back to all providers.')\n        // Fall through to select from all approved providers below\n      }\n    }\n\n    // No existing data sets - select from all approved providers. First we get approved IDs from\n    // WarmStorage, then fetch provider details.\n    const approvedIds = await warmStorageService.getApprovedProviderIds()\n    const approvedProviders = await spRegistry.getProviders(approvedIds)\n    const allProviders = approvedProviders.filter(\n      (provider: ProviderInfo) =>\n        (!withIpni || provider.products.PDP?.data.ipniIpfs === true) &&\n        (dev || provider.products.PDP?.capabilities?.serviceStatus !== '0x646576') &&\n        !excludeProviderIds.includes(provider.id)\n    )\n\n    if (allProviders.length === 0) {\n      throw createError('StorageContext', 'smartSelectProvider', NO_REMAINING_PROVIDERS_ERROR_MESSAGE)\n    }\n\n    // Random selection from all providers\n    const provider = await StorageContext.selectRandomProvider(allProviders)\n\n    return {\n      provider,\n      dataSetId: -1, // Marker for new data set\n      isExisting: false,\n      dataSetMetadata: requestedMetadata,\n    }\n  }\n\n  /**\n   * Select a random provider from a list with ping validation\n   * @param providers - Array of providers to select from\n   * @param withIpni - Filter for IPNI support\n   * @param dev - Include dev providers\n   * @returns Selected provider\n   */\n  private static async selectRandomProvider(providers: ProviderInfo[]): Promise<ProviderInfo> {\n    if (providers.length === 0) {\n      throw createError('StorageContext', 'selectRandomProvider', 'No providers available')\n    }\n\n    // Create async generator that yields providers in random order\n    async function* generateRandomProviders(): AsyncGenerator<ProviderInfo> {\n      const remaining = [...providers]\n\n      while (remaining.length > 0) {\n        // Remove and yield the selected provider\n        const selected = remaining.splice(randIndex(remaining.length), 1)[0]\n        yield selected\n      }\n    }\n\n    return await StorageContext.selectProviderWithPing(generateRandomProviders())\n  }\n\n  /**\n   * Select a provider from an async iterator with ping validation.\n   * This is shared logic used by both smart selection and random selection.\n   * @param providers - Async iterable of providers to try\n   * @returns The first provider that responds\n   * @throws If all providers fail\n   */\n  private static async selectProviderWithPing(providers: AsyncIterable<ProviderInfo>): Promise<ProviderInfo> {\n    let providerCount = 0\n\n    // Try providers in order until we find one that responds to ping\n    for await (const provider of providers) {\n      providerCount++\n      try {\n        // Create a temporary PDPServer for this specific provider's endpoint\n        if (!provider.products.PDP?.data.serviceURL) {\n          // Skip providers without PDP products\n          continue\n        }\n        const providerPdpServer = new PDPServer(null, provider.products.PDP.data.serviceURL)\n        await providerPdpServer.ping()\n        return provider\n      } catch (error) {\n        console.warn(\n          `Provider ${provider.serviceProvider} failed ping test:`,\n          error instanceof Error ? error.message : String(error)\n        )\n        // Continue to next provider\n      }\n    }\n\n    // All providers failed ping test\n    if (providerCount === 0) {\n      throw createError('StorageContext', 'selectProviderWithPing', 'No providers available to select from')\n    }\n\n    throw createError(\n      'StorageContext',\n      'selectProviderWithPing',\n      `All ${providerCount} providers failed health check. Storage may be temporarily unavailable.`\n    )\n  }\n\n  /**\n   * Static method to perform preflight checks for an upload\n   * @param size - The size of data to upload in bytes\n   * @param withCDN - Whether CDN is enabled\n   * @param warmStorageService - WarmStorageService instance\n   * @param paymentsService - PaymentsService instance\n   * @returns Preflight check results without provider/dataSet specifics\n   */\n  static async performPreflightCheck(\n    warmStorageService: WarmStorageService,\n    paymentsService: PaymentsService,\n    size: number,\n    withCDN: boolean\n  ): Promise<PreflightInfo> {\n    // Validate size before proceeding\n    StorageContext.validateRawSize(size, 'preflightUpload')\n\n    // Check allowances and get costs in a single call\n    const allowanceCheck = await warmStorageService.checkAllowanceForStorage(size, withCDN, paymentsService)\n\n    // Return preflight info\n    return {\n      estimatedCost: {\n        perEpoch: allowanceCheck.costs.perEpoch,\n        perDay: allowanceCheck.costs.perDay,\n        perMonth: allowanceCheck.costs.perMonth,\n      },\n      allowanceCheck: {\n        sufficient: allowanceCheck.sufficient,\n        message: allowanceCheck.message,\n      },\n      selectedProvider: null,\n      selectedDataSetId: null,\n    }\n  }\n\n  /**\n   * Run preflight checks for an upload\n   * @param size - The size of data to upload in bytes\n   * @returns Preflight information including costs and allowances\n   */\n  async preflightUpload(size: number): Promise<PreflightInfo> {\n    // Use the static method for core logic\n    const preflightResult = await StorageContext.performPreflightCheck(\n      this._warmStorageService,\n      this._synapse.payments,\n      size,\n      this._withCDN\n    )\n\n    // Return preflight info with provider and dataSet specifics\n    return preflightResult\n  }\n\n  /**\n   * Upload data to the service provider\n   *\n   * Accepts Uint8Array or ReadableStream<Uint8Array>.\n   * For large files, prefer streaming to minimize memory usage.\n   *\n   * Note: When uploading to multiple contexts, pieceCid should be pre-calculated and passed in options\n   * to avoid redundant computation. For streaming uploads, pieceCid must be provided in options as it\n   * cannot be calculated without consuming the stream.\n   */\n  async upload(data: Uint8Array | ReadableStream<Uint8Array>, options?: UploadOptions): Promise<UploadResult> {\n    performance.mark('synapse:upload-start')\n\n    // Validation Phase: Check data size and calculate pieceCid\n    let size: number | undefined\n    const pieceCid = options?.pieceCid\n    if (data instanceof Uint8Array) {\n      size = data.length\n      StorageContext.validateRawSize(size, 'upload')\n    }\n    // Note: Size is unknown for streams (size will be undefined)\n\n    // Track this upload for batching purposes\n    const uploadId = Symbol('upload')\n    this._activeUploads.add(uploadId)\n\n    try {\n      let uploadResult: SP.UploadPieceResponse\n      // Upload Phase: Upload data to service provider\n      try {\n        performance.mark('synapse:pdpServer.uploadPiece-start')\n        uploadResult = await this._pdpServer.uploadPiece(data, {\n          ...options,\n          pieceCid,\n        })\n        performance.mark('synapse:pdpServer.uploadPiece-end')\n        performance.measure(\n          'synapse:pdpServer.uploadPiece',\n          'synapse:pdpServer.uploadPiece-start',\n          'synapse:pdpServer.uploadPiece-end'\n        )\n      } catch (error) {\n        performance.mark('synapse:pdpServer.uploadPiece-end')\n        performance.measure(\n          'synapse:pdpServer.uploadPiece',\n          'synapse:pdpServer.uploadPiece-start',\n          'synapse:pdpServer.uploadPiece-end'\n        )\n        throw createError('StorageContext', 'uploadPiece', 'Failed to upload piece to service provider', error)\n      }\n\n      // Poll for piece to be \"parked\" (ready)\n      performance.mark('synapse:findPiece-start')\n      await this._pdpServer.findPiece(uploadResult.pieceCid)\n      performance.mark('synapse:findPiece-end')\n      performance.measure('synapse:findPiece', 'synapse:findPiece-start', 'synapse:findPiece-end')\n\n      // Upload phase complete - remove from active tracking\n      this._activeUploads.delete(uploadId)\n\n      // Notify upload complete\n      if (options?.onUploadComplete != null) {\n        options.onUploadComplete(uploadResult.pieceCid)\n      }\n\n      // Add Piece Phase: Queue the AddPieces operation for sequential processing\n\n      // Validate metadata early (before queueing) to fail fast\n      if (options?.metadata != null) {\n        validatePieceMetadata(options.metadata)\n      }\n\n      const finalPieceId = await new Promise<number>((resolve, reject) => {\n        // Add to pending batch\n        this._pendingPieces.push({\n          pieceCid: uploadResult.pieceCid,\n          resolve,\n          reject,\n          callbacks: options,\n          metadata: options?.metadata ? objectToEntries(options.metadata) : undefined,\n        })\n\n        // Debounce: defer processing to next event loop tick\n        // This allows multiple synchronous upload() calls to queue up before processing\n        setTimeout(() => {\n          void this._processPendingPieces().catch((error) => {\n            console.error('Failed to process pending pieces batch:', error)\n          })\n        }, 0)\n      })\n\n      // Return upload result\n      performance.mark('synapse:upload-end')\n      performance.measure('synapse:upload', 'synapse:upload-start', 'synapse:upload-end')\n      return {\n        pieceCid: uploadResult.pieceCid,\n        size: uploadResult.size,\n        pieceId: finalPieceId,\n      }\n    } finally {\n      this._activeUploads.delete(uploadId)\n    }\n  }\n\n  /**\n   * Process pending pieces by batching them into a single AddPieces operation\n   * This method is called from the promise queue to ensure sequential execution\n   */\n  private async _processPendingPieces(): Promise<void> {\n    if (this._isProcessing || this._pendingPieces.length === 0) {\n      return\n    }\n    this._isProcessing = true\n\n    // Wait for any in-flight uploads to complete before processing, but only if we don't\n    // already have a full batch - no point waiting for more if we can process a full batch now.\n    // Snapshot the current uploads so we don't wait for new uploads that start during our wait.\n    const uploadsToWaitFor = new Set(this._activeUploads)\n\n    if (uploadsToWaitFor.size > 0 && this._pendingPieces.length < this._uploadBatchSize) {\n      const waitStart = Date.now()\n      const pollInterval = 200\n\n      while (uploadsToWaitFor.size > 0 && Date.now() - waitStart < this._uploadBatchWaitTimeout) {\n        // Check which of our snapshot uploads have completed\n        for (const uploadId of uploadsToWaitFor) {\n          if (!this._activeUploads.has(uploadId)) {\n            uploadsToWaitFor.delete(uploadId)\n          }\n        }\n\n        if (uploadsToWaitFor.size > 0) {\n          await new Promise((resolve) => setTimeout(resolve, pollInterval))\n        }\n      }\n\n      const waited = Date.now() - waitStart\n      if (waited > pollInterval) {\n        console.debug(`Waited ${waited}ms for ${uploadsToWaitFor.size} active upload(s) to complete`)\n      }\n    }\n\n    // Extract up to uploadBatchSize pending pieces\n    const batch = this._pendingPieces.splice(0, this._uploadBatchSize)\n    try {\n      // Create piece data array and metadata from the batch\n      const pieceCids: PieceCID[] = batch.map((item) => item.pieceCid)\n      const metadataArray: MetadataEntry[][] = batch.map((item) => item.metadata ?? [])\n      const confirmedPieceIds: number[] = []\n\n      if (this.dataSetId) {\n        const [, dataSetInfo] = await Promise.all([\n          this._warmStorageService.validateDataSet(this.dataSetId),\n          this._warmStorageService.getDataSet(this.dataSetId),\n        ])\n        // Add pieces to the data set\n        const addPiecesResult = await this._pdpServer.addPieces(\n          this.dataSetId, // PDPVerifier data set ID\n          dataSetInfo.clientDataSetId, // Client's dataset ID\n          pieceCids,\n          metadataArray\n        )\n\n        // Notify callbacks with transaction\n        batch.forEach((item) => {\n          item.callbacks?.onPieceAdded?.(addPiecesResult.txHash as Hex)\n        })\n        const addPiecesResponse = await SP.pollForAddPiecesStatus(addPiecesResult)\n\n        // Handle transaction tracking if available\n        confirmedPieceIds.push(...(addPiecesResponse.confirmedPieceIds ?? []))\n\n        batch.forEach((item) => {\n          item.callbacks?.onPieceConfirmed?.(confirmedPieceIds)\n        })\n      } else {\n        const payer = await this._synapse.getClient().getAddress()\n        // Prepare metadata - merge withCDN flag into metadata if needed\n        const baseMetadataObj = this._dataSetMetadata ?? {}\n        const metadataObj =\n          this._withCDN && !(METADATA_KEYS.WITH_CDN in baseMetadataObj)\n            ? { ...baseMetadataObj, [METADATA_KEYS.WITH_CDN]: '' }\n            : baseMetadataObj\n\n        // Convert to MetadataEntry[] for PDP operations (requires ordered array)\n        const finalMetadata = objectToEntries(metadataObj)\n        // Create a new data set and add pieces to it\n        const createAndAddPiecesResult = await this._pdpServer.createAndAddPieces(\n          randU256(),\n          this._provider.payee,\n          payer,\n          this._synapse.getWarmStorageAddress(),\n          pieceCids,\n          {\n            dataset: finalMetadata,\n            pieces: metadataArray,\n          }\n        )\n        batch.forEach((item) => {\n          item.callbacks?.onPieceAdded?.(createAndAddPiecesResult.txHash as Hex)\n        })\n        const confirmedDataset = await SP.pollForDataSetCreationStatus(createAndAddPiecesResult)\n        this._dataSetId = confirmedDataset.dataSetId\n\n        const confirmedPieces = await SP.pollForAddPiecesStatus({\n          statusUrl: new URL(\n            `/pdp/data-sets/${confirmedDataset.dataSetId}/pieces/added/${confirmedDataset.createMessageHash}`,\n            this._pdpServer.getServiceURL()\n          ).toString(),\n        })\n\n        confirmedPieceIds.push(...(confirmedPieces.confirmedPieceIds ?? []))\n\n        batch.forEach((item) => {\n          item.callbacks?.onPieceConfirmed?.(confirmedPieceIds)\n        })\n      }\n\n      // Resolve all promises in the batch with their respective piece IDs\n      batch.forEach((item, index) => {\n        const pieceId = confirmedPieceIds[index]\n        if (pieceId == null) {\n          throw createError('StorageContext', 'addPieces', `Server did not return piece ID for piece at index ${index}`)\n        }\n        item.resolve(pieceId)\n      })\n    } catch (error) {\n      // Reject all promises in the batch\n      const finalError = createError('StorageContext', 'addPieces', 'Failed to add piece to data set', error)\n      batch.forEach((item) => {\n        item.reject(finalError)\n      })\n    } finally {\n      this._isProcessing = false\n      if (this._pendingPieces.length > 0) {\n        void this._processPendingPieces().catch((error) => {\n          console.error('Failed to process pending pieces batch:', error)\n        })\n      }\n    }\n  }\n\n  /**\n   * Download data from this specific service provider\n   * @param pieceCid - The PieceCID identifier\n   * @param options - Download options\n   * @returns The downloaded data\n   */\n  async download(pieceCid: string | PieceCID, options?: DownloadOptions): Promise<Uint8Array> {\n    // Pass through to storage manager with our provider hint and withCDN setting\n    // Use storage manager if available (production), otherwise use provider download for tests\n    const downloadFn = this._synapse.storage?.download ?? this._synapse.download\n    return await downloadFn.call(this._synapse.storage ?? this._synapse, pieceCid, {\n      providerAddress: this._provider.serviceProvider,\n      withCDN: (options as any)?.withCDN ?? this._withCDN,\n    })\n  }\n\n  /**\n   * Download data from the service provider\n   * @deprecated Use download() instead. This method will be removed in a future version.\n   */\n  async providerDownload(pieceCid: string | PieceCID, options?: DownloadOptions): Promise<Uint8Array> {\n    console.warn('providerDownload() is deprecated. Use download() instead.')\n    return await this.download(pieceCid, options)\n  }\n\n  /**\n   * Get information about the service provider used by this service\n   * @returns Provider information including pricing (currently same for all providers)\n   */\n  async getProviderInfo(): Promise<ProviderInfo> {\n    return await this._synapse.getProviderInfo(this.serviceProvider)\n  }\n\n  /**\n   * Get the list of piece CIDs for this service service's data set.\n   * @returns Array of piece CIDs as PieceCID objects\n   * @deprecated Use getPieces() generator for better memory efficiency with large data sets\n   */\n  async getDataSetPieces(): Promise<PieceCID[]> {\n    if (this.dataSetId == null) {\n      return []\n    }\n\n    const pieces: PieceCID[] = []\n    for await (const { pieceCid } of this.getPieces()) {\n      pieces.push(pieceCid)\n    }\n    return pieces\n  }\n\n  /**\n   * Get all active pieces for this data set as an async generator.\n   * This provides lazy evaluation and better memory efficiency for large data sets.\n   * @param options - Optional configuration object\n   * @param options.batchSize - The batch size for each pagination call (default: 100)\n   * @param options.signal - Optional AbortSignal to cancel the operation\n   * @yields Object with pieceCid and pieceId - the piece ID is needed for certain operations like deletion\n   */\n  async *getPieces(options?: {\n    batchSize?: number\n    signal?: AbortSignal\n  }): AsyncGenerator<{ pieceCid: PieceCID; pieceId: number }> {\n    if (this._dataSetId == null) {\n      return\n    }\n    const pdpVerifierAddress = this._warmStorageService.getPDPVerifierAddress()\n    const pdpVerifier = new PDPVerifier(this._synapse.getProvider(), pdpVerifierAddress)\n\n    const batchSize = options?.batchSize ?? 100\n    const signal = options?.signal\n    let offset = 0\n    let hasMore = true\n\n    while (hasMore) {\n      if (signal?.aborted) {\n        throw createError('StorageContext', 'getPieces', 'Operation aborted')\n      }\n\n      const result = await pdpVerifier.getActivePieces(this._dataSetId, { offset, limit: batchSize, signal })\n\n      // Yield pieces one by one for lazy evaluation\n      for (let i = 0; i < result.pieces.length; i++) {\n        if (signal?.aborted) {\n          throw createError('StorageContext', 'getPieces', 'Operation aborted')\n        }\n\n        yield {\n          pieceCid: result.pieces[i].pieceCid,\n          pieceId: result.pieces[i].pieceId,\n        }\n      }\n\n      hasMore = result.hasMore\n      offset += batchSize\n    }\n  }\n  private async _getPieceIdByCID(pieceCid: string | PieceCID): Promise<number> {\n    if (this.dataSetId == null) {\n      throw createError('StorageContext', 'getPieceIdByCID', 'Data set not found')\n    }\n    const parsedPieceCID = asPieceCID(pieceCid)\n    if (parsedPieceCID == null) {\n      throw createError('StorageContext', 'deletePiece', 'Invalid PieceCID provided')\n    }\n\n    const dataSetData = await this._pdpServer.getDataSet(this.dataSetId)\n    const pieceData = dataSetData.pieces.find((piece) => piece.pieceCid.toString() === parsedPieceCID.toString())\n    if (pieceData == null) {\n      throw createError('StorageContext', 'deletePiece', 'Piece not found in data set')\n    }\n    return pieceData.pieceId\n  }\n\n  /**\n   * Delete a piece with given CID from this data set\n   * @param piece - The PieceCID identifier or a piece number to delete by pieceID\n   * @returns Transaction hash of the delete operation\n   */\n  async deletePiece(piece: string | PieceCID | number): Promise<string> {\n    if (this.dataSetId == null) {\n      throw createError('StorageContext', 'deletePiece', 'Data set not found')\n    }\n    const pieceId = typeof piece === 'number' ? piece : await this._getPieceIdByCID(piece)\n    const dataSetInfo = await this._warmStorageService.getDataSet(this.dataSetId)\n\n    return this._pdpServer.deletePiece(this.dataSetId, dataSetInfo.clientDataSetId, pieceId)\n  }\n\n  /**\n   * Check if a piece exists on this service provider.\n   * @param pieceCid - The PieceCID (piece CID) to check\n   * @returns True if the piece exists on this provider, false otherwise\n   */\n  async hasPiece(pieceCid: string | PieceCID): Promise<boolean> {\n    const parsedPieceCID = asPieceCID(pieceCid)\n    if (parsedPieceCID == null) {\n      return false\n    }\n\n    try {\n      await this._pdpServer.findPiece(parsedPieceCID)\n      return true\n    } catch {\n      return false\n    }\n  }\n\n  /**\n   * Check if a piece exists on this service provider and get its proof status.\n   * Also returns timing information about when the piece was last proven and when the next\n   * proof is due.\n   *\n   * Note: Proofs are submitted for entire data sets, not individual pieces. The timing information\n   * returned reflects when the data set (containing this piece) was last proven and when the next\n   * proof is due.\n   *\n   * @param pieceCid - The PieceCID (piece CID) to check\n   * @returns Status information including existence, data set timing, and retrieval URL\n   */\n  async pieceStatus(pieceCid: string | PieceCID): Promise<PieceStatus> {\n    if (this.dataSetId == null) {\n      throw createError('StorageContext', 'pieceStatus', 'Data set not found')\n    }\n    const parsedPieceCID = asPieceCID(pieceCid)\n    if (parsedPieceCID == null) {\n      throw createError('StorageContext', 'pieceStatus', 'Invalid PieceCID provided')\n    }\n\n    // Run multiple operations in parallel for better performance\n    const [exists, dataSetData, currentEpoch] = await Promise.all([\n      // Check if piece exists on provider\n      this.hasPiece(parsedPieceCID),\n      // Get data set data\n      this._pdpServer\n        .getDataSet(this.dataSetId)\n        .catch((error) => {\n          console.debug('Failed to get data set data:', error)\n          return null\n        }),\n      // Get current epoch\n      getCurrentEpoch(this._synapse.getProvider()),\n    ])\n    const network = this._synapse.getNetwork()\n\n    // Initialize return values\n    let retrievalUrl: string | null = null\n    let pieceId: number | undefined\n    let lastProven: Date | null = null\n    let nextProofDue: Date | null = null\n    let inChallengeWindow = false\n    let hoursUntilChallengeWindow = 0\n    let isProofOverdue = false\n\n    // If piece exists, get provider info for retrieval URL and proving params in parallel\n    if (exists) {\n      const [providerInfo, provingParams] = await Promise.all([\n        // Get provider info for retrieval URL\n        this.getProviderInfo().catch(() => null),\n        // Get proving period configuration (only if we have data set data)\n        dataSetData != null\n          ? Promise.all([this._warmStorageService.getMaxProvingPeriod(), this._warmStorageService.getChallengeWindow()])\n              .then(([maxProvingPeriod, challengeWindow]) => ({\n                maxProvingPeriod,\n                challengeWindow,\n              }))\n              .catch(() => null)\n          : Promise.resolve(null),\n      ])\n\n      // Set retrieval URL if we have provider info\n      if (providerInfo != null) {\n        // Remove trailing slash from serviceURL to avoid double slashes\n        if (!providerInfo.products.PDP?.data.serviceURL) {\n          throw new Error(`Provider ${providerInfo.id} does not have a PDP product with serviceURL`)\n        }\n        retrievalUrl = `${providerInfo.products.PDP.data.serviceURL.replace(\n          /\\/$/,\n          ''\n        )}/piece/${parsedPieceCID.toString()}`\n      }\n\n      // Process proof timing data if we have data set data and proving params\n      if (dataSetData != null && provingParams != null) {\n        // Check if this PieceCID is in the data set\n        const pieceData = dataSetData.pieces.find((piece) => piece.pieceCid.toString() === parsedPieceCID.toString())\n\n        if (pieceData != null) {\n          pieceId = pieceData.pieceId\n\n          // Calculate timing based on nextChallengeEpoch\n          if (dataSetData.nextChallengeEpoch > 0) {\n            // nextChallengeEpoch is when the challenge window STARTS, not ends!\n            // The proving deadline is nextChallengeEpoch + challengeWindow\n            const challengeWindowStart = dataSetData.nextChallengeEpoch\n            const provingDeadline = challengeWindowStart + provingParams.challengeWindow\n\n            // Calculate when the next proof is due (end of challenge window)\n            nextProofDue = epochToDate(provingDeadline, network)\n\n            // Calculate last proven date (one proving period before next challenge)\n            const lastProvenDate = calculateLastProofDate(\n              dataSetData.nextChallengeEpoch,\n              provingParams.maxProvingPeriod,\n              network\n            )\n            if (lastProvenDate != null) {\n              lastProven = lastProvenDate\n            }\n\n            // Check if we're in the challenge window\n            inChallengeWindow = Number(currentEpoch) >= challengeWindowStart && Number(currentEpoch) < provingDeadline\n\n            // Check if proof is overdue (past the proving deadline)\n            isProofOverdue = Number(currentEpoch) >= provingDeadline\n\n            // Calculate hours until challenge window starts (only if before challenge window)\n            if (Number(currentEpoch) < challengeWindowStart) {\n              const timeUntil = timeUntilEpoch(challengeWindowStart, Number(currentEpoch))\n              hoursUntilChallengeWindow = timeUntil.hours\n            }\n          } else {\n            // If nextChallengeEpoch is 0, it might mean:\n            // 1. Proof was just submitted and system is updating\n            // 2. Data set is not active\n            // In case 1, we might have just proven, so set lastProven to very recent\n            // This is a temporary state and should resolve quickly\n            console.debug('Data set has nextChallengeEpoch=0, may have just been proven')\n          }\n        }\n      }\n    }\n\n    return {\n      exists,\n      dataSetLastProven: lastProven,\n      dataSetNextProofDue: nextProofDue,\n      retrievalUrl,\n      pieceId,\n      inChallengeWindow,\n      hoursUntilChallengeWindow,\n      isProofOverdue,\n    }\n  }\n\n  /**\n   * Terminates the data set by sending on-chain message.\n   * This will also result in the removal of all pieces in the data set.\n   * @returns Transaction response\n   */\n  async terminate(): Promise<ethers.TransactionResponse> {\n    if (this.dataSetId == null) {\n      throw createError('StorageContext', 'terminate', 'Data set not found')\n    }\n    return this._synapse.storage.terminateDataSet(this.dataSetId)\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3458, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/storage/manager.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/storage/manager.ts"],"sourcesContent":["/**\n * StorageManager - Central facade for all storage operations\n *\n * Manages storage contexts (SP + DataSet pairs) with intelligent caching and reuse.\n * Provides both SP-agnostic operations (download from anywhere) and context-based\n * operations (upload/download to/from specific providers).\n *\n * @example\n * ```typescript\n * // Simple usage - auto-manages context\n * await synapse.storage.upload(data)\n * await synapse.storage.download(pieceCid)\n *\n * // Explicit context\n * const context = await synapse.storage.createContext({ providerId: 1 })\n * await context.upload(data)\n *\n * // Context routing\n * await synapse.storage.upload(data, { context })\n * ```\n */\n\nimport * as Piece from '@filoz/synapse-core/piece'\nimport { asPieceCID, downloadAndValidate } from '@filoz/synapse-core/piece'\nimport { randIndex } from '@filoz/synapse-core/utils'\nimport { ethers } from 'ethers'\nimport { SPRegistryService } from '../sp-registry/index.ts'\nimport type { Synapse } from '../synapse.ts'\nimport type {\n  CreateContextsOptions,\n  DownloadOptions,\n  EnhancedDataSetInfo,\n  PieceCID,\n  PieceRetriever,\n  PreflightInfo,\n  ProviderInfo,\n  StorageContextCallbacks,\n  StorageInfo,\n  StorageServiceOptions,\n  UploadCallbacks,\n  UploadResult,\n} from '../types.ts'\nimport {\n  combineMetadata,\n  createError,\n  METADATA_KEYS,\n  metadataMatches,\n  SIZE_CONSTANTS,\n  TIME_CONSTANTS,\n  TOKENS,\n} from '../utils/index.ts'\nimport type { WarmStorageService } from '../warm-storage/index.ts'\nimport { StorageContext } from './context.ts'\n\n// Combined callbacks type that can include both creation and upload callbacks\ntype CombinedCallbacks = StorageContextCallbacks & UploadCallbacks\n\n/**\n * Upload options for StorageManager.upload() - the all-in-one upload method\n *\n * This is the \"uber-shortcut\" method that can handle everything from context\n * creation to piece upload in a single call. It combines:\n * - Storage context creation options (provider selection, data set creation)\n * - Upload callbacks (both creation and upload progress)\n * - Piece-specific metadata\n *\n * Usage patterns:\n * 1. With explicit context: `{ context, callbacks?, metadata? }` - routes to context.upload()\n * 2. Auto-create context: `{ providerId?, dataSetId?, withCDN?, callbacks?, metadata? }` - creates/reuses context\n * 3. Use default context: `{ callbacks?, metadata? }` - uses cached default context\n *\n * @internal This type is intentionally not exported as it's specific to StorageManager\n */\ninterface StorageManagerUploadOptions extends StorageServiceOptions {\n  // Multiple storage providers: if provided, all other context options are invalid\n  contexts?: StorageContext[]\n\n  // Context routing - if provided, all other context options are invalid\n  context?: StorageContext\n\n  // Callbacks that can include both creation and upload callbacks\n  callbacks?: Partial<CombinedCallbacks>\n\n  /** Optional pre-calculated PieceCID to skip CommP calculation (BYO PieceCID, it will be checked by the server) */\n  pieceCid?: PieceCID\n\n  /** Optional AbortSignal to cancel the upload */\n  signal?: AbortSignal\n}\n\ninterface StorageManagerDownloadOptions extends DownloadOptions {\n  context?: StorageContext\n  providerAddress?: string\n  withCDN?: boolean\n}\n\nexport class StorageManager {\n  private readonly _synapse: Synapse\n  private readonly _warmStorageService: WarmStorageService\n  private readonly _pieceRetriever: PieceRetriever\n  private readonly _withCDN: boolean\n  private readonly _dev: boolean\n  private readonly _withIpni: boolean | undefined\n  private _defaultContexts?: StorageContext[]\n\n  constructor(\n    synapse: Synapse,\n    warmStorageService: WarmStorageService,\n    pieceRetriever: PieceRetriever,\n    withCDN: boolean,\n    dev: boolean,\n    withIpni?: boolean\n  ) {\n    this._synapse = synapse\n    this._warmStorageService = warmStorageService\n    this._pieceRetriever = pieceRetriever\n    this._withCDN = withCDN\n    this._dev = dev\n    this._withIpni = withIpni\n  }\n\n  /**\n   * Upload data to storage\n   * Uses the storage contexts or context provided in the options\n   * Otherwise creates/reuses default context\n   *\n   * Accepts Uint8Array or ReadableStream<Uint8Array>.\n   * For large files, prefer streaming to minimize memory usage.\n   *\n   * Note: Multi-context uploads (uploading to multiple providers simultaneously) currently\n   * only support Uint8Array. For streaming uploads with multiple contexts, convert your\n   * stream to Uint8Array first or use stream forking (future feature).\n   */\n  async upload(\n    data: Uint8Array | ReadableStream<Uint8Array>,\n    options?: StorageManagerUploadOptions\n  ): Promise<UploadResult> {\n    // Validate options - if context is provided, no other options should be set\n    if (options?.context != null || options?.contexts != null) {\n      const invalidOptions = []\n      if (options.providerId !== undefined) invalidOptions.push('providerId')\n      if (options.providerAddress !== undefined) invalidOptions.push('providerAddress')\n      if (options.dataSetId !== undefined) invalidOptions.push('dataSetId')\n      if (options.withCDN !== undefined) invalidOptions.push('withCDN')\n      if (options.forceCreateDataSet !== undefined) invalidOptions.push('forceCreateDataSet')\n      if (options.uploadBatchSize !== undefined) invalidOptions.push('uploadBatchSize')\n\n      if (invalidOptions.length > 0) {\n        throw createError(\n          'StorageManager',\n          'upload',\n          `Cannot specify both 'context' and other options: ${invalidOptions.join(', ')}`\n        )\n      }\n    }\n\n    if (options?.contexts != null && options.contexts.length > 0) {\n      if (options?.context != null) {\n        throw createError('StorageManager', 'upload', \"Cannot specify both 'context' and 'contexts'\")\n      }\n    }\n\n    // Get the context to use\n    const contexts =\n      options?.contexts ??\n      (options?.context\n        ? [options.context]\n        : await this.createContexts({\n            withCDN: options?.withCDN,\n            withIpni: options?.withIpni,\n            count: 1, // single context by default for now - this will be changed in a future version\n            dev: options?.dev,\n            uploadBatchSize: options?.uploadBatchSize,\n            forceCreateDataSets: options?.forceCreateDataSet,\n            metadata: options?.metadata,\n            excludeProviderIds: options?.excludeProviderIds,\n            providerIds: options?.providerId ? [options.providerId] : undefined,\n            dataSetIds: options?.dataSetId ? [options.dataSetId] : undefined,\n            callbacks: options?.callbacks,\n          }))\n\n    // Multi-context upload handling\n    if (contexts.length > 1) {\n      // Multi-context uploads require Uint8Array to calculate pieceCid once\n      if (!(data instanceof Uint8Array)) {\n        throw createError(\n          'StorageManager',\n          'upload',\n          'Multi-context uploads currently only support Uint8Array. ' +\n            'For streaming uploads to multiple providers, convert your stream to Uint8Array first.'\n        )\n      }\n\n      // Calculate pieceCid once for all contexts\n      const pieceCid = Piece.calculate(data)\n\n      // Upload to all contexts with the same pieceCid\n      return Promise.all(\n        contexts.map((context) =>\n          context.upload(data, {\n            ...options?.callbacks, // TODO: callbacks should be able to differentiate by provider\n            metadata: options?.metadata,\n            pieceCid,\n            signal: options?.signal,\n          })\n        )\n      ).then((results) => results[0]) // all results should be the same\n    } else {\n      // Single context upload - supports all data types\n      const context = contexts[0]\n\n      // Upload to single context\n      return context.upload(data, {\n        ...options?.callbacks,\n        metadata: options?.metadata,\n        signal: options?.signal,\n      })\n    }\n  }\n\n  /**\n   * Download data from storage\n   * If context is provided, routes to context.download()\n   * Otherwise performs SP-agnostic download\n   */\n  async download(pieceCid: string | PieceCID, options?: StorageManagerDownloadOptions): Promise<Uint8Array> {\n    // Validate options - if context is provided, no other options should be set\n    if (options?.context != null) {\n      const invalidOptions = []\n      if (options.providerAddress !== undefined) invalidOptions.push('providerAddress')\n      if (options.withCDN !== undefined) invalidOptions.push('withCDN')\n\n      if (invalidOptions.length > 0) {\n        throw createError(\n          'StorageManager',\n          'download',\n          `Cannot specify both 'context' and other options: ${invalidOptions.join(', ')}`\n        )\n      }\n\n      // Route to specific context\n      return await options.context.download(pieceCid, options)\n    }\n\n    // SP-agnostic download with fast path optimization\n    const parsedPieceCID = asPieceCID(pieceCid)\n    if (parsedPieceCID == null) {\n      throw createError('StorageManager', 'download', `Invalid PieceCID: ${String(pieceCid)}`)\n    }\n\n    // Use withCDN setting: option > manager default > synapse default\n    const withCDN = options?.withCDN ?? this._withCDN\n\n    // Fast path: If we have a default context with CDN disabled and no specific provider requested,\n    // check if the piece exists on the default context's provider first\n    if (this._defaultContexts != null && !withCDN && options?.providerAddress == null) {\n      // from the default contexts, select a random storage provider that has the piece\n      const contextsWithoutCDN = this._defaultContexts.filter((context) => context.withCDN === false)\n      const contextsHavePiece = await Promise.all(contextsWithoutCDN.map((context) => context.hasPiece(parsedPieceCID)))\n      const defaultContextsWithPiece = contextsWithoutCDN.filter((_context, i) => contextsHavePiece[i])\n      if (defaultContextsWithPiece.length > 0) {\n        options = {\n          ...options,\n          providerAddress:\n            defaultContextsWithPiece[randIndex(defaultContextsWithPiece.length)].provider.serviceProvider,\n        }\n      }\n    }\n\n    const clientAddress = await this._synapse.getClient().getAddress()\n\n    // Use piece retriever to fetch\n    const response = await this._pieceRetriever.fetchPiece(parsedPieceCID, clientAddress, {\n      providerAddress: options?.providerAddress,\n      withCDN,\n    })\n\n    return await downloadAndValidate(response, parsedPieceCID)\n  }\n\n  /**\n   * Run preflight checks for an upload without creating a context\n   * @param size - The size of data to upload in bytes\n   * @param options - Optional settings including withCDN flag and/or metadata\n   * @returns Preflight information including costs and allowances\n   */\n  async preflightUpload(\n    size: number,\n    options?: { withCDN?: boolean; metadata?: Record<string, string> }\n  ): Promise<PreflightInfo> {\n    // Determine withCDN from metadata if provided, otherwise use option > manager default\n    let withCDN = options?.withCDN ?? this._withCDN\n\n    // Check metadata for withCDN key - this takes precedence\n    if (options?.metadata != null && METADATA_KEYS.WITH_CDN in options.metadata) {\n      // The withCDN metadata entry should always have an empty string value by convention,\n      // but the contract only checks for key presence, not value\n      const value = options.metadata[METADATA_KEYS.WITH_CDN]\n      if (value !== '') {\n        console.warn(`Warning: withCDN metadata entry has unexpected value \"${value}\". Expected empty string.`)\n      }\n      withCDN = true // Enable CDN when key exists (matches contract behavior)\n    }\n\n    // Use the static method from StorageContext for core logic\n    return await StorageContext.performPreflightCheck(this._warmStorageService, this._synapse.payments, size, withCDN)\n  }\n\n  /**\n   * Creates storage contexts for multi-provider storage deals and other operations.\n   *\n   * By storing data with multiple independent providers, you reduce dependency on any\n   * single provider and improve overall data availability. Use contexts together as a group.\n   *\n   * Contexts are selected by priority:\n   * 1. Specified datasets (`dataSetIds`) - uses their existing providers\n   * 2. Specified providers (`providerIds` or `providerAddresses`) - finds or creates matching datasets\n   * 3. Automatically selected from remaining approved providers\n   *\n   * For automatic selection, existing datasets matching the `metadata` are reused unless\n   * `forceCreateDataSets` is true. Providers are randomly chosen to distribute across the network.\n   *\n   * @param synapse - Synapse instance\n   * @param warmStorageService - Warm storage service instance\n   * @param options - Configuration options\n   * @param options.count - Maximum number of contexts to create (default: 2)\n   * @param options.dataSetIds - Specific dataset IDs to include\n   * @param options.providerIds - Specific provider IDs to use\n   * @param options.metadata - Metadata to match when finding/creating datasets\n   * @param options.forceCreateDataSets - Always create new datasets instead of reusing existing ones\n   * @param options.excludeProviderIds - Provider IDs to skip during selection\n   * @returns Promise resolving to array of storage contexts\n   */\n  async createContexts(options?: CreateContextsOptions): Promise<StorageContext[]> {\n    const withCDN = options?.withCDN ?? this._withCDN\n    const canUseDefault =\n      options == null ||\n      (options.providerIds == null &&\n        options.dataSetIds == null &&\n        options.forceCreateDataSets !== true &&\n        options.uploadBatchSize == null)\n    if (this._defaultContexts != null) {\n      const expectedSize = options?.count ?? 2\n      if (\n        this._defaultContexts.length === expectedSize &&\n        this._defaultContexts.every((context) => options?.excludeProviderIds?.includes(context.provider.id) !== true)\n      ) {\n        const requestedMetadata = combineMetadata(options?.metadata, withCDN)\n        if (\n          this._defaultContexts.every((defaultContext) =>\n            metadataMatches(defaultContext.dataSetMetadata, requestedMetadata)\n          )\n        ) {\n          if (options?.callbacks != null) {\n            for (const defaultContext of this._defaultContexts) {\n              try {\n                options.callbacks.onProviderSelected?.(defaultContext.provider)\n              } catch (error) {\n                console.error('Error in onProviderSelected callback:', error)\n              }\n\n              if (defaultContext.dataSetId != null) {\n                try {\n                  options.callbacks.onDataSetResolved?.({\n                    isExisting: true, // Always true for cached context\n                    dataSetId: defaultContext.dataSetId,\n                    provider: defaultContext.provider,\n                  })\n                } catch (error) {\n                  console.error('Error in onDataSetResolved callback:', error)\n                }\n              }\n            }\n          }\n          return this._defaultContexts\n        }\n      }\n    }\n\n    const contexts = await StorageContext.createContexts(this._synapse, this._warmStorageService, {\n      ...options,\n      withCDN,\n      withIpni: options?.withIpni ?? this._withIpni,\n      dev: options?.dev ?? this._dev,\n    })\n\n    if (canUseDefault) {\n      this._defaultContexts = contexts\n    }\n\n    return contexts\n  }\n\n  /**\n   * Create a new storage context with specified options\n   */\n  async createContext(options?: StorageServiceOptions): Promise<StorageContext> {\n    // Determine the effective withCDN setting\n    const effectiveWithCDN = options?.withCDN ?? this._withCDN\n\n    // Check if we can return the default context\n    // We can use the default if:\n    // 1. No options provided, OR\n    // 2. Only withCDN, metadata and/or callbacks are provided (callbacks can fire for cached context)\n    const canUseDefault =\n      options == null ||\n      (options.providerId == null &&\n        options.providerAddress == null &&\n        options.dataSetId == null &&\n        options.forceCreateDataSet !== true &&\n        options.uploadBatchSize == null)\n\n    if (canUseDefault && this._defaultContexts != null) {\n      // Check if we have a default context with compatible metadata\n\n      const requestedMetadata = combineMetadata(options?.metadata, effectiveWithCDN)\n      for (const defaultContext of this._defaultContexts) {\n        if (options?.excludeProviderIds?.includes(defaultContext.provider.id)) {\n          continue\n        }\n        // Check if the requested metadata matches what the default context was created with\n        if (!metadataMatches(defaultContext.dataSetMetadata, requestedMetadata)) {\n          continue\n        }\n        // Fire callbacks for cached context to ensure consistent behavior\n        if (options?.callbacks != null) {\n          try {\n            options.callbacks.onProviderSelected?.(defaultContext.provider)\n          } catch (error) {\n            console.error('Error in onProviderSelected callback:', error)\n          }\n\n          if (defaultContext.dataSetId != null) {\n            try {\n              options.callbacks.onDataSetResolved?.({\n                isExisting: true, // Always true for cached context\n                dataSetId: defaultContext.dataSetId,\n                provider: defaultContext.provider,\n              })\n            } catch (error) {\n              console.error('Error in onDataSetResolved callback:', error)\n            }\n          }\n        }\n        return defaultContext\n      }\n    }\n\n    // Create a new context with specific options\n    const context = await StorageContext.create(this._synapse, this._warmStorageService, {\n      ...options,\n      withCDN: effectiveWithCDN,\n      withIpni: options?.withIpni ?? this._withIpni,\n      dev: options?.dev ?? this._dev,\n    })\n\n    if (canUseDefault) {\n      this._defaultContexts = [context]\n    }\n    return context\n  }\n\n  /**\n   * Get or create the default context\n   */\n  async getDefaultContext(): Promise<StorageContext> {\n    return await this.createContext()\n  }\n\n  /**\n   * Query data sets for this client\n   * @param clientAddress - Optional client address, defaults to current signer\n   * @returns Array of enhanced data set information including management status\n   */\n  async findDataSets(clientAddress?: string): Promise<EnhancedDataSetInfo[]> {\n    const address = clientAddress ?? (await this._synapse.getClient().getAddress())\n    return await this._warmStorageService.getClientDataSetsWithDetails(address)\n  }\n\n  /**\n   * Terminate a data set with given ID that belongs to the synapse signer.\n   * This will also result in the removal of all pieces in the data set.\n   * @param dataSetId - The ID of the data set to terminate\n   * @returns Transaction response\n   */\n  async terminateDataSet(dataSetId: number): Promise<ethers.TransactionResponse> {\n    return this._warmStorageService.terminateDataSet(this._synapse.getSigner(), dataSetId)\n  }\n\n  /**\n   * Get comprehensive information about the storage service including\n   * approved providers, pricing, contract addresses, and current allowances\n   * @returns Complete storage service information\n   */\n  async getStorageInfo(): Promise<StorageInfo> {\n    try {\n      // Helper function to get allowances with error handling\n      const getOptionalAllowances = async (): Promise<StorageInfo['allowances']> => {\n        try {\n          const warmStorageAddress = this._synapse.getWarmStorageAddress()\n          const approval = await this._synapse.payments.serviceApproval(warmStorageAddress, TOKENS.USDFC)\n          return {\n            service: warmStorageAddress,\n            // Forward whether operator is approved so callers can react accordingly\n            isApproved: approval.isApproved,\n            rateAllowance: approval.rateAllowance,\n            lockupAllowance: approval.lockupAllowance,\n            rateUsed: approval.rateUsed,\n            lockupUsed: approval.lockupUsed,\n          }\n        } catch {\n          // Return null if wallet not connected or any error occurs\n          return null\n        }\n      }\n\n      // Create SPRegistryService to get providers\n      const registryAddress = this._warmStorageService.getServiceProviderRegistryAddress()\n      const spRegistry = new SPRegistryService(this._synapse.getProvider(), registryAddress)\n\n      // Fetch all data in parallel for performance\n      const [pricingData, approvedIds, allowances] = await Promise.all([\n        this._warmStorageService.getServicePrice(),\n        this._warmStorageService.getApprovedProviderIds(),\n        getOptionalAllowances(),\n      ])\n\n      // Get provider details for approved IDs\n      const providers = await spRegistry.getProviders(approvedIds)\n\n      // Calculate pricing per different time units\n      const epochsPerMonth = BigInt(pricingData.epochsPerMonth)\n\n      // TODO: StorageInfo needs updating to reflect that CDN costs are usage-based\n\n      // Calculate per-epoch pricing (base storage cost)\n      const noCDNPerEpoch = BigInt(pricingData.pricePerTiBPerMonthNoCDN) / epochsPerMonth\n      // CDN costs are usage-based (egress charges), so base storage cost is the same\n      const withCDNPerEpoch = BigInt(pricingData.pricePerTiBPerMonthNoCDN) / epochsPerMonth\n\n      // Calculate per-day pricing (base storage cost)\n      const noCDNPerDay = BigInt(pricingData.pricePerTiBPerMonthNoCDN) / TIME_CONSTANTS.DAYS_PER_MONTH\n      // CDN costs are usage-based (egress charges), so base storage cost is the same\n      const withCDNPerDay = BigInt(pricingData.pricePerTiBPerMonthNoCDN) / TIME_CONSTANTS.DAYS_PER_MONTH\n\n      // Filter out providers with zero addresses\n      const validProviders = providers.filter((p: ProviderInfo) => p.serviceProvider !== ethers.ZeroAddress)\n\n      const network = this._synapse.getNetwork()\n\n      return {\n        pricing: {\n          noCDN: {\n            perTiBPerMonth: BigInt(pricingData.pricePerTiBPerMonthNoCDN),\n            perTiBPerDay: noCDNPerDay,\n            perTiBPerEpoch: noCDNPerEpoch,\n          },\n          // CDN costs are usage-based (egress charges), base storage cost is the same\n          withCDN: {\n            perTiBPerMonth: BigInt(pricingData.pricePerTiBPerMonthNoCDN),\n            perTiBPerDay: withCDNPerDay,\n            perTiBPerEpoch: withCDNPerEpoch,\n          },\n          tokenAddress: pricingData.tokenAddress,\n          tokenSymbol: 'USDFC', // Hardcoded as we know it's always USDFC\n        },\n        providers: validProviders,\n        serviceParameters: {\n          network,\n          epochsPerMonth,\n          epochsPerDay: TIME_CONSTANTS.EPOCHS_PER_DAY,\n          epochDuration: TIME_CONSTANTS.EPOCH_DURATION,\n          minUploadSize: SIZE_CONSTANTS.MIN_UPLOAD_SIZE,\n          maxUploadSize: SIZE_CONSTANTS.MAX_UPLOAD_SIZE,\n          warmStorageAddress: this._synapse.getWarmStorageAddress(),\n          paymentsAddress: this._warmStorageService.getPaymentsAddress(),\n          pdpVerifierAddress: this._warmStorageService.getPDPVerifierAddress(),\n        },\n        allowances,\n      }\n    } catch (error) {\n      throw new Error(\n        `Failed to get storage service information: ${error instanceof Error ? error.message : String(error)}`\n      )\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3767, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/storage/service.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/storage/service.ts"],"sourcesContent":["/**\n * Compatibility wrapper for backwards compatibility\n * @deprecated StorageService has been renamed to StorageContext.\n * Import StorageContext from './context.ts' instead.\n */\n\nexport { StorageContext as StorageService } from './context.ts'\n"],"names":[],"mappings":";AAMA,OAAO,EAAE,cAAc,IAAI,cAAc,EAAE,MAAM,cAAc,CAAA"}},
    {"offset": {"line": 3774, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/storage/index.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/storage/index.ts"],"sourcesContent":["/**\n * Exports the Storage components\n *\n * @packageDocumentation\n * @module Storage\n * @example\n * ```ts\n * import { StorageContext, StorageManager, StorageService } from '@filoz/synapse-sdk/storage'\n * ```\n */\n\nexport { StorageContext } from './context.ts'\nexport { StorageManager } from './manager.ts'\nexport { StorageService } from './service.ts'\n"],"names":[],"mappings":";AAWA,OAAO,EAAE,cAAc,EAAE,MAAM,cAAc,CAAA;AAC7C,OAAO,EAAE,cAAc,EAAE,MAAM,cAAc,CAAA;AAC7C,OAAO,EAAE,cAAc,EAAE,MAAM,cAAc,CAAA"}},
    {"offset": {"line": 3785, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/sp-registry/types.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/sp-registry/types.ts"],"sourcesContent":["/**\n * Types for ServiceProviderRegistry interaction\n */\n\nimport type { PDPOffering } from '@filoz/synapse-core/warm-storage'\n\nexport type { PDPOffering }\n\n/**\n * Product types supported by the registry\n */\nexport const PRODUCTS = {\n  PDP: 0,\n} as const\nexport type ProductType = (typeof PRODUCTS)[keyof typeof PRODUCTS]\n\n/**\n * Decoded provider info for SDK use\n */\nexport interface ProviderInfo {\n  id: number\n  serviceProvider: string // TODO Hex\n  payee: string\n  name: string\n  description: string\n  active: boolean\n  // Map of product type to product data for direct access\n  products: Partial<Record<'PDP', ServiceProduct>>\n}\n\n/**\n * Polymorphic service product interface\n */\nexport interface ServiceProduct {\n  type: 'PDP'\n  isActive: boolean\n  capabilities: Record<string, string> // Object map of capability key-value pairs\n  data: PDPOffering\n}\n\n/**\n * Provider registration info for new providers\n */\nexport interface ProviderRegistrationInfo {\n  payee: string\n  name: string\n  description: string\n  pdpOffering: PDPOffering\n  capabilities?: Record<string, string> // Object map of capability key-value pairs\n}\n\n/**\n * PDP service info returned from getPDPService\n */\nexport interface PDPServiceInfo {\n  offering: PDPOffering\n  capabilities: Record<string, string> // Object map of capability key-value pairs\n  isActive: boolean\n}\n"],"names":[],"mappings":";;;;AAWO,MAAM,QAAQ,GAAG;IACtB,GAAG,EAAE,CAAC;CACE,CAAA"}},
    {"offset": {"line": 3796, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/subgraph/queries.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/subgraph/queries.ts"],"sourcesContent":["/**\n * Subgraph queries\n */\n\nexport const QUERIES = {\n  // queries for subgraphRetriever\n  GET_APPROVED_PROVIDERS_FOR_PIECE_LINK: `\n    query GetApprovedProvidersForCommP($cid: Bytes!) {\n      pieces(where: { cid: $cid }) {\n        id\n        dataSet {\n          setId\n          serviceProvider {\n            id\n            providerId\n            serviceProvider\n            payee\n            name\n            description\n            registeredAt\n            status\n            approvedAt\n            products {\n              decodedProductData\n              productType\n              isActive\n              capabilityValues\n              capabilityKeys\n            }\n          }\n        }\n      }\n    }\n  `,\n  GET_PROVIDER_BY_ADDRESS: `\n    query Provider($serviceProvider: ID!) {\n      provider (id: $serviceProvider) {\n        id\n        providerId\n        serviceProvider\n        payee\n        name\n        description\n        registeredAt\n        status\n        approvedAt\n        products {\n          decodedProductData\n          productType\n          isActive\n          capabilityValues\n          capabilityKeys\n        }\n      }\n    }\n  `,\n  // flexible query templates\n  GET_PROVIDERS_FLEXIBLE: `\n    query ProvidersFlexible($where: Provider_filter, $first: Int, $skip: Int, $orderBy: Provider_orderBy, $orderDirection: OrderDirection) {\n      providers(\n        where: $where\n        first: $first\n        skip: $skip\n        orderBy: $orderBy\n        orderDirection: $orderDirection\n      ) {\n        id\n        providerId\n        serviceProvider\n        payee\n        registeredAt\n        approvedAt\n        status\n        totalFaultedPeriods\n        totalFaultedPieces\n        totalDataSets\n        totalPieces\n        totalDataSize\n        createdAt\n        updatedAt\n        products {\n          decodedProductData\n          productType\n          isActive\n          capabilityValues\n          capabilityKeys\n        }\n      }\n    }\n  `,\n  GET_DATA_SETS_FLEXIBLE: `\n    query DataSetsFlexible($where: DataSet_filter, $first: Int, $skip: Int, $orderBy: DataSet_orderBy, $orderDirection: OrderDirection) {\n      dataSets(\n        where: $where\n        first: $first\n        skip: $skip\n        orderBy: $orderBy\n        orderDirection: $orderDirection\n      ) {\n        id\n        setId\n        listener\n        payer\n        withCDN\n        isActive\n        leafCount\n        challengeRange\n        lastProvenEpoch\n        nextChallengeEpoch\n        totalPieces\n        totalDataSize\n        totalProofs\n        totalProvedPieces\n        totalFaultedPeriods\n        totalFaultedPieces\n        metadataKeys\n        metadataValues\n        createdAt\n        updatedAt\n        serviceProvider {\n          id\n          providerId\n          serviceProvider\n          payee\n          name\n          description\n          registeredAt\n          status\n          approvedAt\n          products {\n            decodedProductData\n            productType\n            isActive\n            capabilityValues\n            capabilityKeys\n          }\n        }\n        rails {\n          id\n          type\n          railId\n          token\n          paymentRate\n          settledUpto\n          endEpoch\n        }\n      }\n    }\n  `,\n  GET_PIECES_FLEXIBLE: `\n    query PiecesFlexible($where: Piece_filter, $first: Int, $skip: Int, $orderBy: Piece_orderBy, $orderDirection: OrderDirection) {\n      pieces(\n        where: $where\n        first: $first\n        skip: $skip\n        orderBy: $orderBy\n        orderDirection: $orderDirection\n      ) {\n        id\n        setId\n        pieceId\n        rawSize\n        leafCount\n        cid\n        removed\n        totalProofsSubmitted\n        totalPeriodsFaulted\n        lastProvenEpoch\n        lastProvenAt\n        lastFaultedEpoch\n        lastFaultedAt\n        createdAt\n        metadataKeys\n        metadataValues\n        dataSet {\n          id\n          setId\n          isActive\n          serviceProvider {\n            id\n            providerId\n            serviceProvider\n            payee\n            name\n            description\n            registeredAt\n            status\n            approvedAt\n            products {\n              decodedProductData\n              productType\n              isActive\n              capabilityValues\n              capabilityKeys\n            }\n          }\n        }\n      }\n    }\n  `,\n  GET_FAULT_RECORDS_FLEXIBLE: `\n    query FaultRecordsFlexible($where: FaultRecord_filter, $first: Int, $skip: Int, $orderBy: FaultRecord_orderBy, $orderDirection: OrderDirection) {\n      faultRecords(\n        where: $where\n        first: $first\n        skip: $skip\n        orderBy: $orderBy\n        orderDirection: $orderDirection\n      ) {\n        id\n        dataSetId\n        pieceIds\n        currentChallengeEpoch\n        nextChallengeEpoch\n        periodsFaulted\n        deadline\n        createdAt\n        dataSet {\n          id\n          setId\n          serviceProvider {\n            id\n            providerId\n            serviceProvider\n            payee\n            name\n            description\n            registeredAt\n            status\n            approvedAt\n            products {\n              decodedProductData\n              productType\n              isActive\n              capabilityValues\n              capabilityKeys\n            }\n          }\n        }\n      }\n    }\n  `,\n} as const\n"],"names":[],"mappings":";;;;AAIO,MAAM,OAAO,GAAG;IAErB,qCAAqC,EAAE,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;GA2BtC;IACD,uBAAuB,EAAE,CAAA;;;;;;;;;;;;;;;;;;;;;GAqBxB;IAED,sBAAsB,EAAE,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAgCvB;IACD,sBAAsB,EAAE,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA0DvB;IACD,mBAAmB,EAAE,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAkDpB;IACD,0BAA0B,EAAE,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAyC3B;CACO,CAAA"}},
    {"offset": {"line": 4041, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/subgraph/service.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/subgraph/service.ts"],"sourcesContent":["/**\n * SubgraphService - A service for querying a subgraph to find service providers for a given piece.\n *\n * This service abstracts the logic for connecting to and querying a GraphQL endpoint,\n * which can be a direct URL or a Goldsky-hosted subgraph.\n *\n * @example\n * ```typescript\n * import { SubgraphService } from '@filoz/synapse-sdk/subgraph'\n *\n * // Using a direct endpoint\n * const subgraphService = new SubgraphService({ endpoint: 'https://your-subgraph-endpoint.com/query' });\n *\n * // Using Goldsky configuration\n * const goldskyService = new SubgraphService({\n *   goldsky: {\n *     projectId: 'your-project-id',\n *     subgraphName: 'your-subgraph-name',\n *     version: 'v1.0.0'\n *   }\n * });\n *\n * const providers = await subgraphService.getApprovedProvidersForPieceCID('bafkzcib...');\n * console.log(providers);\n * ```\n */\n\nimport { asPieceCID } from '@filoz/synapse-core/piece'\nimport { fromHex, toHex } from 'multiformats/bytes'\nimport { CID } from 'multiformats/cid'\nimport { type PDPOffering, PRODUCTS, type ProductType, type ServiceProduct } from '../sp-registry/types.ts'\nimport type { PieceCID, ProviderInfo, SubgraphConfig, SubgraphRetrievalService } from '../types.ts'\nimport { createError } from '../utils/errors.ts'\nimport { QUERIES } from './queries.ts'\n\n// Simplified response types\ninterface GraphQLResponse<T = any> {\n  data?: T\n  errors?: Array<{ message: string }>\n}\n\n/**\n * Options for pagination in subgraph queries\n */\nexport interface PaginationOptions {\n  first?: number\n  skip?: number\n}\n\n/**\n * Options for flexible subgraph queries with custom where clauses\n */\nexport interface QueryOptions extends PaginationOptions {\n  where?: Record<string, any>\n  orderBy?: string\n  orderDirection?: 'asc' | 'desc'\n}\n\n/**\n * Options for nested entity queries in subgraphs\n */\nexport interface NestedQueryOptions extends QueryOptions {\n  nestedWhere?: Record<string, any>\n}\n\n/**\n * Extended provider statistics including fault information\n */\nexport interface ProviderStats extends ProviderInfo {\n  status: string\n  totalFaultedPeriods: number\n  totalFaultedPieces: number\n  totalDataSets: number\n  totalPieces: number\n  totalDataSize: number\n  createdAt: number\n  updatedAt: number\n}\n\n/**\n * Basic data set information from subgraph\n */\nexport interface SubgraphDataSetInfo {\n  id: string\n  setId: number\n  isActive: boolean\n  leafCount: number\n  totalDataSize: number\n  totalPieces: number\n  totalProofs: number\n  totalProvedPieces: number\n  totalFaultedPieces: number\n  createdAt: number\n  updatedAt: number\n}\n\n/**\n * Detailed data set information from subgraph with additional metadata\n */\nexport interface DetailedSubgraphDataSetInfo extends SubgraphDataSetInfo {\n  listener: string\n  payer: string\n  withCDN: boolean\n  challengeRange: number\n  lastProvenEpoch: number\n  nextChallengeEpoch: number\n  totalFaultedPeriods: number\n  metadataKeys: string[]\n  metadataValues: string[]\n  serviceProvider: ProviderInfo\n  rails?: {\n    id: string\n    type: string\n    railId: number\n    token: string\n    paymentRate: number\n    settledUpto: number\n    endEpoch: number\n  }[]\n}\n\n/**\n * Piece information with data set context\n */\nexport interface PieceInfo {\n  id: string\n  setId: number\n  pieceId: number\n  rawSize: number\n  leafCount: number\n  cid: PieceCID | null\n  removed: boolean\n  totalProofsSubmitted: number\n  totalPeriodsFaulted: number\n  lastProvenEpoch: number\n  lastProvenAt: number\n  lastFaultedEpoch: number\n  lastFaultedAt: number\n  createdAt: number\n  metadataKeys: string[]\n  metadataValues: string[]\n  dataSet: {\n    id: string\n    setId: number\n    isActive: boolean\n    serviceProvider: ProviderInfo\n  }\n}\n\n/**\n * Fault record information\n */\nexport interface FaultRecord {\n  id: string\n  dataSetId: number\n  pieceIds: number[]\n  currentChallengeEpoch: number\n  nextChallengeEpoch: number\n  periodsFaulted: number\n  deadline: number\n  createdAt: number\n  dataSet: {\n    id: string\n    setId: number\n    serviceProvider: ProviderInfo\n  }\n}\n\nexport class SubgraphService implements SubgraphRetrievalService {\n  private readonly endpoint: string\n  private readonly headers: Record<string, string>\n\n  constructor(subgraphConfig: SubgraphConfig) {\n    this.endpoint = this.resolveEndpoint(subgraphConfig)\n    this.headers = this.buildHeaders(subgraphConfig.apiKey)\n  }\n\n  /**\n   * Resolves the GraphQL endpoint from configuration\n   */\n  private resolveEndpoint(config: SubgraphConfig): string {\n    if (config.endpoint != null && config.endpoint.trim() !== '') {\n      return config.endpoint.trim()\n    }\n\n    if (config.goldsky != null) {\n      return this.buildGoldskyEndpoint(config.goldsky)\n    }\n\n    throw createError(\n      'SubgraphService',\n      'constructor',\n      'Invalid configuration: provide either endpoint or complete goldsky config'\n    )\n  }\n\n  /**\n   * Builds Goldsky endpoint URL\n   */\n  private buildGoldskyEndpoint(goldsky: NonNullable<SubgraphConfig['goldsky']>): string {\n    const { projectId, subgraphName, version } = goldsky\n\n    if (\n      projectId?.trim() == null ||\n      projectId?.trim() === '' ||\n      subgraphName?.trim() == null ||\n      subgraphName?.trim() === '' ||\n      version?.trim() == null ||\n      version?.trim() === ''\n    ) {\n      throw createError(\n        'SubgraphService',\n        'constructor',\n        'Incomplete Goldsky config: projectId, subgraphName, and version required'\n      )\n    }\n\n    return `https://api.goldsky.com/api/public/${projectId}/subgraphs/${subgraphName}/${version}/gn`\n  }\n\n  /**\n   * Builds HTTP headers for requests\n   */\n  private buildHeaders(apiKey?: string): Record<string, string> {\n    const headers = { 'Content-Type': 'application/json' }\n\n    if (apiKey != null && apiKey !== '') {\n      return { ...headers, Authorization: `Bearer ${apiKey}` }\n    }\n\n    return headers\n  }\n\n  /**\n   * Normalizes query options with defaults\n   */\n  private normalizeQueryOptions(options: QueryOptions = {}): QueryOptions {\n    return {\n      where: {},\n      first: 10,\n      skip: 0,\n      orderBy: 'createdAt',\n      orderDirection: 'desc',\n      ...options,\n    } as const\n  }\n\n  /**\n   * Executes a GraphQL query\n   */\n  private async executeQuery<T>(query: string, variables: Record<string, any>, operation: string): Promise<T> {\n    try {\n      const response = await fetch(this.endpoint, {\n        method: 'POST',\n        headers: this.headers,\n        body: JSON.stringify({ query, variables }),\n      })\n\n      if (!response.ok) {\n        const errorText = await response.text()\n        throw createError('SubgraphService', operation, `HTTP ${response.status}: ${errorText}`)\n      }\n\n      const result = (await response.json()) as GraphQLResponse<T>\n\n      if (result.errors != null && result.errors.length > 0) {\n        const errorMsg = result.errors.map((e) => e.message).join('; ')\n        throw createError('SubgraphService', operation, `GraphQL errors: ${errorMsg}`)\n      }\n\n      return result.data as T\n    } catch (error) {\n      if (error instanceof Error && error.name === 'SynapseError') {\n        throw error\n      }\n\n      throw createError('SubgraphService', operation, `Query execution failed: ${(error as Error).message}`, {\n        cause: error,\n      })\n    }\n  }\n\n  /**\n   * Maps a ProductType value back to its corresponding key in the PRODUCTS constant.\n   *\n   * This method performs a reverse lookup to find the key that corresponds to the given\n   * ProductType value.\n   *\n   */\n  private getProductType(productType: ProductType): keyof typeof PRODUCTS {\n    const entry = Object.entries(PRODUCTS).find(([, value]) => value === productType)\n    return entry != null ? (entry[0] as keyof typeof PRODUCTS) : 'PDP'\n  }\n\n  /**\n   * Transforms raw provider data from the subgraph into a structured ProviderInfo object.\n   *\n   * This method safely converts subgraph provider data into the SDK's ProviderInfo format,\n   * handling potential missing fields and parsing errors gracefully.\n   *\n   */\n  private transformProviderData(data: any): ProviderInfo {\n    // Provide safe defaults for required fields\n    const safeData = {\n      providerId: data?.providerId ?? 0,\n      serviceProvider: data?.serviceProvider ?? '',\n      payee: data?.payee ?? '',\n      name: data?.name ?? '',\n      description: data?.description ?? '',\n      status: data?.status ?? 'UNKNOWN',\n      products: Array.isArray(data?.products) ? data.products : [],\n    }\n\n    return {\n      id: safeData.providerId,\n      serviceProvider: safeData.serviceProvider,\n      payee: safeData.payee,\n      name: safeData.name,\n      description: safeData.description,\n      active: safeData.status === 'APPROVED',\n      products: this.transformProducts(safeData.products),\n    }\n  }\n\n  /**\n   * Transforms an array of product data into a structured products record.\n   */\n  private transformProducts(products: any[]): Partial<Record<'PDP', ServiceProduct>> {\n    return products.reduce(\n      (productAcc: Record<string, ServiceProduct>, product: any) => {\n        const productType = this.getProductType(product?.productType)\n        const serviceProduct = this.createServiceProduct(product, productType)\n\n        if (serviceProduct != null) {\n          productAcc[productType] = serviceProduct\n        }\n\n        return productAcc\n      },\n      {} as Record<string, ServiceProduct>\n    )\n  }\n\n  /**\n   * Creates a ServiceProduct from raw product data with error handling.\n   */\n  private createServiceProduct(product: any, productType: keyof typeof PRODUCTS): ServiceProduct | null {\n    try {\n      return {\n        type: productType,\n        isActive: product?.isActive ?? false,\n        capabilities: this.transformCapabilities(product?.capabilityValues),\n        data: this.parseProductData(product?.decodedProductData),\n      }\n    } catch (error) {\n      console.warn(\n        `SubgraphService: Failed to create service product for type ${productType}:`,\n        error instanceof Error ? error.message : 'Unknown error'\n      )\n      return null\n    }\n  }\n\n  /**\n   * Transforms capability values into a key-value record.\n   */\n  private transformCapabilities(capabilityValues: any[]): Record<string, string> {\n    if (!Array.isArray(capabilityValues)) {\n      return {}\n    }\n\n    return capabilityValues.reduce(\n      (capabilityAcc: Record<string, string>, capability: any) => {\n        if (capability?.key != null && capability?.value != null) {\n          capabilityAcc[capability.key] = String(capability.value)\n        }\n        return capabilityAcc\n      },\n      {} as Record<string, string>\n    )\n  }\n\n  /**\n   * Safely parses product data JSON with error handling.\n   */\n  private parseProductData(decodedProductData: string): PDPOffering {\n    try {\n      if (decodedProductData == null || decodedProductData.trim() === '') {\n        throw new Error('Empty or null product data')\n      }\n\n      const parsed = JSON.parse(decodedProductData) as PDPOffering\n\n      // Validate required fields exist\n      if (parsed?.serviceURL == null) {\n        throw new Error('Missing required serviceURL field')\n      }\n\n      return parsed\n    } catch (error) {\n      console.warn(\n        `SubgraphService: Failed to parse product data, using defaults:`,\n        error instanceof Error ? error.message : 'Unknown error'\n      )\n\n      // Return safe defaults for PDPOffering\n      return {\n        serviceURL: '',\n        minPieceSizeInBytes: 0n,\n        maxPieceSizeInBytes: 0n,\n        ipniPiece: false,\n        ipniIpfs: false,\n        storagePricePerTibPerDay: 0n,\n        minProvingPeriodInEpochs: 0n,\n        location: '',\n        paymentTokenAddress: '0x0000000000000000000000000000000000000000',\n      }\n    }\n  }\n\n  /**\n   * Safely parses timestamp values\n   */\n  private parseTimestamp(value?: number | string): number {\n    if (value == null) return 0\n    const parsed = Number(value)\n    return Number.isNaN(parsed) ? 0 : parsed\n  }\n\n  /**\n   * Safely converts a hex format CID to PieceCID format\n   * @param hexCid - The CID in hex format\n   * @returns The CID in PieceCID format or null if conversion fails\n   */\n  private safeConvertHexToCid(hexCid: string): PieceCID | null {\n    try {\n      const cleanHex = hexCid.startsWith('0x') ? hexCid.slice(2) : hexCid\n      const cidBytes = fromHex(cleanHex)\n      const cid = CID.decode(cidBytes)\n      const pieceCid = asPieceCID(cid)\n\n      if (pieceCid == null) {\n        throw new Error(`Failed to convert CID to PieceCID format: ${hexCid}`)\n      }\n\n      return pieceCid\n    } catch (error) {\n      console.warn(\n        `SubgraphService: queryProviders: Failed to convert CID to PieceCID format: ${\n          error instanceof Error ? error.message : 'Unknown error'\n        }`\n      )\n      return null\n    }\n  }\n\n  /**\n   * Validates provider data completeness\n   */\n  private isValidProviderData(data: any): boolean {\n    return data?.id != null && data.id.trim() !== '' && data?.products != null && data.products.length > 0\n  }\n\n  /**\n   * Queries the subgraph to find approved service providers that have a specific piece (PieceCID).\n   *\n   * It sends a GraphQL query to the configured endpoint and parses the response to extract\n   * a list of providers, including their addresses and retrieval URLs.\n   *\n   * @param pieceCid - The piece commitment (PieceCID) to search for.\n   * @returns A promise that resolves to an array of `ProviderInfo` objects.\n   *          Returns an empty array if no providers are found or if an error occurs during the fetch.\n   */\n  async getApprovedProvidersForPieceCID(pieceCid: PieceCID): Promise<ProviderInfo[]> {\n    const pieceCidParsed = asPieceCID(pieceCid)\n    if (pieceCidParsed == null) {\n      throw createError('SubgraphService', 'getApprovedProvidersForPieceCID', 'Invalid PieceCID')\n    }\n    const hexPieceCid = toHex(pieceCidParsed.bytes)\n\n    const data = await this.executeQuery<{ pieces: any[] }>(\n      QUERIES.GET_APPROVED_PROVIDERS_FOR_PIECE_LINK,\n      { cid: hexPieceCid },\n      'getApprovedProvidersForPieceCID'\n    )\n\n    if (data?.pieces == null || data.pieces.length === 0) {\n      console.log(`SubgraphService: No providers found for PieceCID: ${pieceCidParsed.toString()}`)\n      return []\n    }\n\n    const uniqueProviderMap = data.pieces.reduce((acc: Map<string, any>, piece: any) => {\n      const provider = piece.dataSet.serviceProvider\n      const address = provider?.serviceProvider?.toLowerCase() as string\n\n      if (address == null || address === '' || acc.has(address)) {\n        return acc\n      }\n\n      if (!this.isValidProviderData(provider)) {\n        console.warn('SubgraphService: Skipping incomplete provider data for approved provider:', provider)\n        return acc\n      }\n\n      acc.set(address, provider)\n\n      return acc\n    }, new Map<string, any>())\n\n    return Array.from(uniqueProviderMap.values()).map((provider) => this.transformProviderData(provider))\n  }\n\n  /**\n   * Queries the subgraph to find a specific approved service provider by their address.\n   *\n   * @param address - The wallet address of the provider to search for.\n   * @returns A promise that resolves to an `ProviderInfo` object if the provider is found, or `null` otherwise.\n   */\n  async getProviderByAddress(address: string): Promise<ProviderInfo | null> {\n    const data = await this.executeQuery<{ provider: any | null }>(\n      QUERIES.GET_PROVIDER_BY_ADDRESS,\n      { serviceProvider: address },\n      'getProviderByAddress'\n    )\n\n    if (data?.provider == null) {\n      console.log(`SubgraphService: No provider found for address: ${address}`)\n      return null\n    }\n\n    return this.transformProviderData(data.provider)\n  }\n\n  /**\n   * Generic method to query providers with flexible where clauses\n   *\n   * @param options - Query options including where clause, pagination, and ordering\n   * @returns A promise that resolves to an array of `ProviderInfo` objects\n   *\n   * @example\n   * ```typescript\n   * // Get providers with specific status\n   * const approvedProviders = await service.queryProviders({\n   *   where: { status: \"APPROVED\" },\n   *   first: 10,\n   *   orderBy: \"approvedAt\",\n   *   orderDirection: \"desc\"\n   * });\n   *\n   * // Get providers with minimum data sets\n   * const activeProviders = await service.queryProviders({\n   *   where: { totalDataSets_gte: \"5\" },\n   *   first: 20\n   * });\n   * ```\n   */\n  async queryProviders(options: QueryOptions = {}): Promise<ProviderInfo[]> {\n    const data = await this.executeQuery<{ providers: any[] }>(\n      QUERIES.GET_PROVIDERS_FLEXIBLE,\n      this.normalizeQueryOptions(options),\n      'queryProviders'\n    )\n\n    if (data?.providers == null || data?.providers?.length === 0) {\n      console.log('SubgraphService: No providers found for the given criteria')\n      return []\n    }\n\n    return data.providers\n      .filter((provider) => this.isValidProviderData(provider))\n      .map((provider) => this.transformProviderData(provider))\n  }\n\n  /**\n   * Generic method to query data sets with flexible where clauses\n   *\n   * @param options - Query options including where clause, pagination, and ordering\n   * @returns A promise that resolves to an array of `DetailedSubgraphDataSetInfo` objects\n   *\n   * @example\n   * ```typescript\n   * // Get active data sets\n   * const activeDataSets = await service.queryDataSets({\n   *   where: { isActive: true },\n   *   first: 50,\n   *   orderBy: \"createdAt\",\n   *   orderDirection: \"desc\"\n   * });\n   *\n   * // Get data sets by owner with minimum data size\n   * const largeDataSets = await service.queryDataSets({\n   *   where: {\n   *     owner: \"0x123...\",\n   *     totalDataSize_gte: \"1000000000\"\n   *   }\n   * });\n   * ```\n   */\n  async queryDataSets(options: QueryOptions = {}): Promise<DetailedSubgraphDataSetInfo[]> {\n    const data = await this.executeQuery<{ dataSets: any[] }>(\n      QUERIES.GET_DATA_SETS_FLEXIBLE,\n      this.normalizeQueryOptions(options),\n      'queryDataSets'\n    )\n\n    if (data?.dataSets == null || data?.dataSets?.length === 0) {\n      console.log('SubgraphService: No data sets found for the given criteria')\n      return []\n    }\n\n    return data.dataSets.map((dataSet: any) => ({\n      id: dataSet.id,\n      setId: this.parseTimestamp(dataSet.setId),\n      listener: dataSet.listener ?? '',\n      payer: dataSet.payer ?? '',\n      withCDN: dataSet.withCDN ?? false,\n      isActive: dataSet.isActive,\n      leafCount: this.parseTimestamp(dataSet.leafCount),\n      challengeRange: this.parseTimestamp(dataSet.challengeRange),\n      lastProvenEpoch: this.parseTimestamp(dataSet.lastProvenEpoch),\n      nextChallengeEpoch: this.parseTimestamp(dataSet.nextChallengeEpoch),\n      totalPieces: this.parseTimestamp(dataSet.totalPieces),\n      totalDataSize: this.parseTimestamp(dataSet.totalDataSize),\n      totalProofs: this.parseTimestamp(dataSet.totalProofs),\n      totalProvedPieces: this.parseTimestamp(dataSet.totalProvedPieces),\n      totalFaultedPeriods: this.parseTimestamp(dataSet.totalFaultedPeriods),\n      totalFaultedPieces: this.parseTimestamp(dataSet.totalFaultedPieces),\n      metadataKeys: dataSet.metadataKeys ?? [],\n      metadataValues: dataSet.metadataValues ?? [],\n      createdAt: this.parseTimestamp(dataSet.createdAt),\n      updatedAt: this.parseTimestamp(dataSet.updatedAt),\n      serviceProvider:\n        dataSet.serviceProvider != null\n          ? this.transformProviderData(dataSet.serviceProvider)\n          : this.transformProviderData({}), // Create default provider\n      rails:\n        dataSet.rails != null\n          ? dataSet.rails.map((rail: any) => ({\n              id: rail.id,\n              type: rail.type,\n              railId: this.parseTimestamp(rail.railId),\n              token: rail.token,\n              paymentRate: this.parseTimestamp(rail.paymentRate),\n              settledUpto: this.parseTimestamp(rail.settledUpto),\n              endEpoch: this.parseTimestamp(rail.endEpoch),\n            }))\n          : undefined,\n    }))\n  }\n\n  /**\n   * Generic method to query pieces with flexible where clauses\n   *\n   * @param options - Query options including where clause, pagination, and ordering\n   * @returns A promise that resolves to an array of `PieceInfo` objects\n   *\n   * @example\n   * ```typescript\n   * // Get pieces by data set\n   * const dataSetPieces = await service.queryPieces({\n   *   where: { dataSet: \"0x123...\" },\n   *   first: 100,\n   *   orderBy: \"createdAt\"\n   * });\n   *\n   * // Get non-removed pieces with minimum size\n   * const largePieces = await service.queryPieces({\n   *   where: {\n   *     removed: false,\n   *     rawSize_gte: \"1000000\"\n   *   }\n   * });\n   * ```\n   */\n  async queryPieces(options: QueryOptions = {}): Promise<PieceInfo[]> {\n    const data = await this.executeQuery<{ pieces: any[] }>(\n      QUERIES.GET_PIECES_FLEXIBLE,\n      this.normalizeQueryOptions(options),\n      'queryPieces'\n    )\n\n    if (data?.pieces == null || data?.pieces?.length === 0) {\n      console.log('SubgraphService: No pieces found for the given criteria')\n      return []\n    }\n\n    return data.pieces.map((piece) => ({\n      id: piece.id,\n      setId: this.parseTimestamp(piece.setId),\n      pieceId: this.parseTimestamp(piece.pieceId),\n      rawSize: this.parseTimestamp(piece.rawSize),\n      leafCount: this.parseTimestamp(piece.leafCount),\n      cid: this.safeConvertHexToCid(piece.cid),\n      removed: piece.removed,\n      totalProofsSubmitted: this.parseTimestamp(piece.totalProofsSubmitted),\n      totalPeriodsFaulted: this.parseTimestamp(piece.totalPeriodsFaulted),\n      lastProvenEpoch: this.parseTimestamp(piece.lastProvenEpoch),\n      lastProvenAt: this.parseTimestamp(piece.lastProvenAt),\n      lastFaultedEpoch: this.parseTimestamp(piece.lastFaultedEpoch),\n      lastFaultedAt: this.parseTimestamp(piece.lastFaultedAt),\n      createdAt: this.parseTimestamp(piece.createdAt),\n      metadataKeys: piece.metadataKeys ?? [],\n      metadataValues: piece.metadataValues ?? [],\n      dataSet: {\n        id: piece.dataSet.id,\n        setId: this.parseTimestamp(piece.dataSet.setId),\n        isActive: piece.dataSet.isActive,\n        serviceProvider: this.transformProviderData(piece.dataSet.serviceProvider),\n      },\n    }))\n  }\n\n  /**\n   * Generic method to query fault records with flexible where clauses\n   *\n   * @param options - Query options including where clause, pagination, and ordering\n   * @returns A promise that resolves to an array of `FaultRecord` objects\n   *\n   * @example\n   * ```typescript\n   * // Get recent fault records\n   * const recentFaults = await service.queryFaultRecords({\n   *   where: { createdAt_gte: \"1640995200\" },\n   *   first: 20,\n   *   orderBy: \"createdAt\",\n   *   orderDirection: \"desc\"\n   * });\n   *\n   * // Get fault records for specific data set\n   * const dataSetFaults = await service.queryFaultRecords({\n   *   where: { dataSetId: \"123\" }\n   * });\n   * ```\n   */\n  async queryFaultRecords(options: QueryOptions = {}): Promise<FaultRecord[]> {\n    const data = await this.executeQuery<{ faultRecords: any[] }>(\n      QUERIES.GET_FAULT_RECORDS_FLEXIBLE,\n      this.normalizeQueryOptions(options),\n      'queryFaultRecords'\n    )\n\n    if (data?.faultRecords == null || data?.faultRecords?.length === 0) {\n      console.log('SubgraphService: No fault records found for the given criteria')\n      return []\n    }\n\n    return data.faultRecords.map((fault) => ({\n      id: fault.id,\n      dataSetId: this.parseTimestamp(fault.dataSetId),\n      pieceIds: fault.pieceIds.map((id: any) => this.parseTimestamp(id)),\n      currentChallengeEpoch: this.parseTimestamp(fault.currentChallengeEpoch),\n      nextChallengeEpoch: this.parseTimestamp(fault.nextChallengeEpoch),\n      periodsFaulted: this.parseTimestamp(fault.periodsFaulted),\n      deadline: this.parseTimestamp(fault.deadline),\n      createdAt: this.parseTimestamp(fault.createdAt),\n      dataSet: {\n        id: fault.dataSet.id,\n        setId: this.parseTimestamp(fault.dataSet.setId),\n        serviceProvider: this.transformProviderData(fault.dataSet.serviceProvider),\n      },\n    }))\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4380, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/subgraph/index.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/subgraph/index.ts"],"sourcesContent":["/**\n * Exports the Subgraph components\n *\n * @packageDocumentation\n * @module Subgraph\n * @example\n * ```ts\n * import { SubgraphService } from '@filoz/synapse-sdk/subgraph'\n * ```\n */\nexport type {\n  DetailedSubgraphDataSetInfo,\n  FaultRecord,\n  NestedQueryOptions,\n  PaginationOptions,\n  PieceInfo,\n  ProviderStats,\n  QueryOptions,\n  SubgraphDataSetInfo,\n} from './service.ts'\nexport { SubgraphService } from './service.ts'\n"],"names":[],"mappings":";AAoBA,OAAO,EAAE,eAAe,EAAE,MAAM,cAAc,CAAA"}},
    {"offset": {"line": 4387, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/retriever/utils.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/retriever/utils.ts"],"sourcesContent":["/**\n * Utility to attempt fetching a piece from multiple providers in parallel.\n */\n\nimport type { PieceCID, ProviderInfo } from '../types.ts'\nimport { createError } from '../utils/errors.ts'\nimport { constructFindPieceUrl, constructPieceUrl } from '../utils/piece.ts'\n\n// Define the type for provider attempt results (internal to this function)\ninterface ProviderAttemptResult {\n  response: Response\n  index: number\n}\n\n/**\n * Attempt to fetch a piece from multiple providers in parallel\n * @param providers - List of providers to try\n * @param pieceCid - The piece to fetch\n * @param retrieverName - Name of the calling retriever for error reporting\n * @param signal - Optional abort signal\n * @returns The first successful response\n */\nexport async function fetchPiecesFromProviders(\n  providers: ProviderInfo[],\n  pieceCid: PieceCID,\n  retrieverName: string,\n  signal?: AbortSignal\n): Promise<Response> {\n  // Track failures for error reporting\n  const failures: Array<{ provider: string; error: string }> = []\n\n  // Create individual abort controllers for each provider\n  const abortControllers: AbortController[] = []\n\n  const providerAttempts: Array<Promise<ProviderAttemptResult>> = providers.map(async (provider, index) => {\n    // Create a dedicated controller for this provider\n    const controller = new AbortController()\n    abortControllers[index] = controller\n\n    // If parent signal is provided, propagate abort to this controller\n    if (signal != null) {\n      signal.addEventListener(\n        'abort',\n        () => {\n          controller.abort(signal.reason)\n        },\n        { once: true }\n      )\n\n      // If parent is already aborted, abort immediately\n      if (signal.aborted) {\n        controller.abort(signal.reason)\n      }\n    }\n\n    try {\n      // Phase 1: Check if provider has the piece\n      if (!provider.products.PDP?.data.serviceURL) {\n        throw new Error(`Provider ${provider.id} does not have PDP product with serviceURL`)\n      }\n      const findUrl = constructFindPieceUrl(provider.products.PDP.data.serviceURL, pieceCid)\n      const findResponse = await fetch(findUrl, {\n        signal: controller.signal,\n      })\n\n      if (!findResponse.ok) {\n        // Provider doesn't have the piece\n        failures.push({\n          provider: provider.serviceProvider,\n          error: `findPiece returned ${findResponse.status}`,\n        })\n        throw new Error('Provider does not have piece')\n      }\n\n      // Phase 2: Provider has piece, download it\n      const downloadUrl = constructPieceUrl(provider.products.PDP.data.serviceURL, pieceCid)\n      const response = await fetch(downloadUrl, {\n        signal: controller.signal,\n      })\n\n      if (response.ok) {\n        // Don't cancel here! Let Promise.race decide the winner\n        return { response, index }\n      }\n\n      // Download failed\n      failures.push({\n        provider: provider.serviceProvider,\n        error: `download returned ${response.status}`,\n      })\n      throw new Error(`Download failed with status ${response.status}`)\n    } catch (error: any) {\n      // Log actual failures\n      const errorMsg = error.message ?? 'Unknown error'\n      if (!failures.some((f) => f.provider === provider.serviceProvider)) {\n        failures.push({ provider: provider.serviceProvider, error: errorMsg })\n      }\n      if (errorMsg !== 'This operation was aborted') {\n        // TODO: remove this at some point, it might get noisy\n        console.warn(`Failed to fetch from provider ${provider.serviceProvider}:`, errorMsg)\n      }\n      throw error\n    }\n  })\n\n  try {\n    // Use Promise.any to get the first successful response\n    const { response, index: winnerIndex } = await Promise.any(providerAttempts)\n\n    // Now that we have a winner, cancel all other requests\n    abortControllers.forEach((ctrl, i) => {\n      if (i !== winnerIndex) {\n        ctrl.abort()\n      }\n    })\n\n    return response\n  } catch (error) {\n    // Promise.any throws AggregateError when all promises reject\n    if (error instanceof AggregateError) {\n      // All providers failed\n      const failureDetails = failures.map((f) => `${f.provider}: ${f.error}`).join('; ')\n      throw createError(\n        retrieverName,\n        'fetchPiecesFromProviders',\n        `All providers failed to serve piece ${pieceCid.toString()}. Details: ${failureDetails}`\n      )\n    }\n    // Re-throw unexpected errors\n    throw error\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4475, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/retriever/chain.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/retriever/chain.ts"],"sourcesContent":["/**\n * ChainRetriever - Queries on-chain data to find and retrieve pieces\n *\n * This retriever uses the Warm Storage service to find service providers\n * that have the requested piece, then attempts to download from them.\n */\n\nimport type { SPRegistryService } from '../sp-registry/index.ts'\nimport type { PieceCID, PieceRetriever, ProviderInfo } from '../types.ts'\nimport { createError } from '../utils/index.ts'\nimport type { WarmStorageService } from '../warm-storage/index.ts'\nimport { fetchPiecesFromProviders } from './utils.ts'\n\nexport class ChainRetriever implements PieceRetriever {\n  private readonly warmStorageService: WarmStorageService\n  private readonly childRetriever?: PieceRetriever\n  private readonly spRegistry: SPRegistryService\n\n  constructor(warmStorageService: WarmStorageService, spRegistry: SPRegistryService, childRetriever?: PieceRetriever) {\n    this.warmStorageService = warmStorageService\n    this.spRegistry = spRegistry\n    this.childRetriever = childRetriever\n  }\n\n  /**\n   * Find providers that can serve pieces for a client\n   * @param client - The client address\n   * @param providerAddress - Optional specific provider to use\n   * @returns List of provider info\n   */\n  private async findProviders(client: string, providerAddress?: string): Promise<ProviderInfo[]> {\n    if (providerAddress != null) {\n      // Direct provider case - skip data set lookup entirely\n      const provider = await this.spRegistry.getProviderByAddress(providerAddress)\n      if (provider == null) {\n        throw createError('ChainRetriever', 'findProviders', `Provider ${providerAddress} not found in registry`)\n      }\n      return [provider]\n    }\n\n    // Multiple provider case - need data sets to find providers\n\n    // Get client's data sets with details\n    const dataSets = await this.warmStorageService.getClientDataSetsWithDetails(client)\n\n    // Filter for live data sets with pieces\n    const validDataSets = dataSets.filter((ds) => ds.isLive && ds.currentPieceCount > 0)\n\n    if (validDataSets.length === 0) {\n      throw createError('ChainRetriever', 'findProviders', `No active data sets with data found for client ${client}`)\n    }\n\n    // Get unique provider IDs from data sets (much more reliable than using payee addresses)\n    const uniqueProviderIds = [...new Set(validDataSets.map((ds) => ds.providerId))]\n\n    // Batch fetch provider info for all unique provider IDs\n    const providerInfos = await this.spRegistry.getProviders(uniqueProviderIds)\n\n    // Filter out null values (providers not found in registry)\n    const validProviderInfos = providerInfos.filter((info): info is ProviderInfo => info != null)\n\n    if (validProviderInfos.length === 0) {\n      throw createError(\n        'ChainRetriever',\n        'findProviders',\n        'No valid providers found (all providers may have been removed from registry or are inactive)'\n      )\n    }\n\n    return validProviderInfos\n  }\n\n  async fetchPiece(\n    pieceCid: PieceCID,\n    client: string,\n    options?: {\n      providerAddress?: string\n      withCDN?: boolean\n      signal?: AbortSignal\n    }\n  ): Promise<Response> {\n    // Helper function to try child retriever or throw error\n    const tryChildOrThrow = async (reason: string): Promise<Response> => {\n      if (this.childRetriever !== undefined) {\n        return await this.childRetriever.fetchPiece(pieceCid, client, options)\n      }\n      throw createError('ChainRetriever', 'fetchPiece', `Failed to retrieve piece ${pieceCid.toString()}: ${reason}`)\n    }\n\n    // Find providers\n    let providersToTry: ProviderInfo[] = []\n    try {\n      providersToTry = await this.findProviders(client, options?.providerAddress)\n    } catch (error) {\n      // Provider discovery failed - this is a critical error\n      const message = error instanceof Error ? error.message : 'Provider discovery failed'\n      return await tryChildOrThrow(message)\n    }\n\n    // If no providers found, try child retriever\n    if (providersToTry.length === 0) {\n      return await tryChildOrThrow('No providers found and no additional retriever method was configured')\n    }\n\n    // Try to fetch from providers\n    try {\n      return await fetchPiecesFromProviders(providersToTry, pieceCid, 'ChainRetriever', options?.signal)\n    } catch {\n      // All provider attempts failed\n      return await tryChildOrThrow(\n        'All provider retrieval attempts failed and no additional retriever method was configured'\n      )\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4546, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/retriever/filbeam.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/retriever/filbeam.ts"],"sourcesContent":["/**\n * FilBeamRetriever - CDN optimization wrapper for piece retrieval\n *\n * This intercepts piece requests and attempts CDN retrieval before falling back\n * to the base retriever.\n */\n\nimport type { FilecoinNetworkType, PieceCID, PieceRetriever } from '../types.ts'\n\nexport class FilBeamRetriever implements PieceRetriever {\n  private readonly baseRetriever: PieceRetriever\n  private readonly network: FilecoinNetworkType\n\n  constructor(baseRetriever: PieceRetriever, network: FilecoinNetworkType) {\n    this.baseRetriever = baseRetriever\n    this.network = network\n  }\n\n  hostname(): string {\n    return this.network === 'mainnet' ? 'filbeam.io' : 'calibration.filbeam.io'\n  }\n\n  async fetchPiece(\n    pieceCid: PieceCID,\n    client: string,\n    options?: {\n      providerAddress?: string\n      withCDN?: boolean\n      signal?: AbortSignal\n    }\n  ): Promise<Response> {\n    if (options?.withCDN === true) {\n      const cdnUrl = `https://${client}.${this.hostname()}/${pieceCid.toString()}`\n      try {\n        const cdnResponse = await fetch(cdnUrl, { signal: options?.signal })\n        if (cdnResponse.ok) {\n          return cdnResponse\n        } else if (cdnResponse.status === 402) {\n          console.warn(\n            'CDN requires payment. Please initialise Synapse SDK with the option `withCDN: true` and re-upload your files.'\n          )\n        } else {\n          console.warn('CDN fetch failed with status:', cdnResponse.status)\n        }\n      } catch (error) {\n        console.warn('CDN fetch failed:', error)\n      }\n      console.log('Falling back to direct retrieval')\n    }\n\n    return await this.baseRetriever.fetchPiece(pieceCid, client, options)\n  }\n}\n"],"names":[],"mappings":";;;;AASM,MAAO,gBAAgB;IACV,aAAa,CAAgB;IAC7B,OAAO,CAAqB;IAE7C,YAAY,aAA6B,EAAE,OAA4B,CAAA;QACrE,IAAI,CAAC,aAAa,GAAG,aAAa,CAAA;QAClC,IAAI,CAAC,OAAO,GAAG,OAAO,CAAA;IACxB,CAAC;IAED,QAAQ,GAAA;QACN,OAAO,IAAI,CAAC,OAAO,KAAK,SAAS,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,wBAAwB,CAAA;IAC7E,CAAC;IAED,KAAK,CAAC,UAAU,CACd,QAAkB,EAClB,MAAc,EACd,OAIC,EAAA;QAED,IAAI,OAAO,EAAE,OAAO,KAAK,IAAI,EAAE,CAAC;YAC9B,MAAM,MAAM,GAAG,CAAA,QAAA,EAAW,MAAM,CAAA,CAAA,EAAI,IAAI,CAAC,QAAQ,EAAE,CAAA,CAAA,EAAI,QAAQ,CAAC,QAAQ,EAAE,EAAE,CAAA;YAC5E,IAAI,CAAC;gBACH,MAAM,WAAW,GAAG,MAAM,KAAK,CAAC,MAAM,EAAE;oBAAE,MAAM,EAAE,OAAO,EAAE,MAAM;gBAAA,CAAE,CAAC,CAAA;gBACpE,IAAI,WAAW,CAAC,EAAE,EAAE,CAAC;oBACnB,OAAO,WAAW,CAAA;gBACpB,CAAC,MAAM,IAAI,WAAW,CAAC,MAAM,KAAK,GAAG,EAAE,CAAC;oBACtC,OAAO,CAAC,IAAI,CACV,+GAA+G,CAChH,CAAA;gBACH,CAAC,MAAM,CAAC;oBACN,OAAO,CAAC,IAAI,CAAC,+BAA+B,EAAE,WAAW,CAAC,MAAM,CAAC,CAAA;gBACnE,CAAC;YACH,CAAC,CAAC,OAAO,KAAK,EAAE,CAAC;gBACf,OAAO,CAAC,IAAI,CAAC,mBAAmB,EAAE,KAAK,CAAC,CAAA;YAC1C,CAAC;YACD,OAAO,CAAC,GAAG,CAAC,kCAAkC,CAAC,CAAA;QACjD,CAAC;QAED,OAAO,MAAM,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,QAAQ,EAAE,MAAM,EAAE,OAAO,CAAC,CAAA;IACvE,CAAC;CACF"}},
    {"offset": {"line": 4586, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/retriever/subgraph.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/retriever/subgraph.ts"],"sourcesContent":["/**\n * SubgraphRetriever - Uses a SubgraphService to find and retrieve pieces.\n */\n\nimport type { PieceCID, PieceRetriever, ProviderInfo, SubgraphRetrievalService } from '../types.ts'\nimport { createError } from '../utils/errors.ts'\nimport { fetchPiecesFromProviders } from './utils.ts'\n\nexport class SubgraphRetriever implements PieceRetriever {\n  private readonly subgraphService: SubgraphRetrievalService\n  private readonly childRetriever?: PieceRetriever\n\n  constructor(subgraphService: SubgraphRetrievalService, childRetriever?: PieceRetriever) {\n    this.subgraphService = subgraphService\n    this.childRetriever = childRetriever\n  }\n\n  /**\n   * Find providers that can serve pieces for a client\n   * @param pieceCid - The piece commitment (PieceCID) to search for.\n   * @param providerAddress - Optional specific provider to use\n   * @returns List of approved provider info\n   */\n  async findProviders(pieceCid: PieceCID, providerAddress?: string): Promise<ProviderInfo[]> {\n    if (providerAddress != null) {\n      const provider = await this.subgraphService.getProviderByAddress(providerAddress)\n      return provider !== null ? [provider] : []\n    }\n    return await this.subgraphService.getApprovedProvidersForPieceCID(pieceCid)\n  }\n\n  async fetchPiece(\n    pieceCid: PieceCID,\n    client: string,\n    options?: { providerAddress?: string; signal?: AbortSignal }\n  ): Promise<Response> {\n    // Helper function to try child retriever or throw error\n    const tryChildOrThrow = async (reason: string): Promise<Response> => {\n      if (this.childRetriever !== undefined) {\n        return await this.childRetriever.fetchPiece(pieceCid, client, options)\n      }\n      throw createError('SubgraphRetriever', 'fetchPiece', `Failed to retrieve piece ${pieceCid.toString()}: ${reason}`)\n    }\n\n    // Step 1: Find providers\n    let providersToTry: ProviderInfo[] = []\n    try {\n      providersToTry = await this.findProviders(pieceCid, options?.providerAddress)\n    } catch {\n      // Provider discovery failed - this is a critical error\n      return await tryChildOrThrow('Provider discovery failed and no additional retriever method was configured')\n    }\n\n    // Step 2: If no providers found, try child retriever\n    if (providersToTry.length === 0) {\n      return await tryChildOrThrow('No providers found and no additional retriever method was configured')\n    }\n\n    // Step 3: Try to fetch from providers\n    try {\n      return await fetchPiecesFromProviders(providersToTry, pieceCid, 'SubgraphRetriever', options?.signal)\n    } catch {\n      // All provider attempts failed\n      return await tryChildOrThrow(\n        'All provider retrieval attempts failed and no additional retriever method was configured'\n      )\n    }\n  }\n}\n"],"names":[],"mappings":";;;;AAKA,OAAO,EAAE,WAAW,EAAE,MAAM,oBAAoB,CAAA;AAChD,OAAO,EAAE,wBAAwB,EAAE,MAAM,YAAY,CAAA;;;AAE/C,MAAO,iBAAiB;IACX,eAAe,CAA0B;IACzC,cAAc,CAAiB;IAEhD,YAAY,eAAyC,EAAE,cAA+B,CAAA;QACpF,IAAI,CAAC,eAAe,GAAG,eAAe,CAAA;QACtC,IAAI,CAAC,cAAc,GAAG,cAAc,CAAA;IACtC,CAAC;IAQD,KAAK,CAAC,aAAa,CAAC,QAAkB,EAAE,eAAwB,EAAA;QAC9D,IAAI,eAAe,IAAI,IAAI,EAAE,CAAC;YAC5B,MAAM,QAAQ,GAAG,MAAM,IAAI,CAAC,eAAe,CAAC,oBAAoB,CAAC,eAAe,CAAC,CAAA;YACjF,OAAO,QAAQ,KAAK,IAAI,CAAC,CAAC,CAAC;gBAAC,QAAQ;aAAC,CAAC,CAAC,CAAC,EAAE,CAAA;QAC5C,CAAC;QACD,OAAO,MAAM,IAAI,CAAC,eAAe,CAAC,+BAA+B,CAAC,QAAQ,CAAC,CAAA;IAC7E,CAAC;IAED,KAAK,CAAC,UAAU,CACd,QAAkB,EAClB,MAAc,EACd,OAA4D,EAAA;QAG5D,MAAM,eAAe,GAAG,KAAK,EAAE,MAAc,EAAqB,EAAE;YAClE,IAAI,IAAI,CAAC,cAAc,KAAK,SAAS,EAAE,CAAC;gBACtC,OAAO,MAAM,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,QAAQ,EAAE,MAAM,EAAE,OAAO,CAAC,CAAA;YACxE,CAAC;YACD,UAAM,oNAAW,EAAC,mBAAmB,EAAE,YAAY,EAAE,CAAA,yBAAA,EAA4B,QAAQ,CAAC,QAAQ,EAAE,CAAA,EAAA,EAAK,MAAM,EAAE,CAAC,CAAA;QACpH,CAAC,CAAA;QAGD,IAAI,cAAc,GAAmB,EAAE,CAAA;QACvC,IAAI,CAAC;YACH,cAAc,GAAG,MAAM,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE,OAAO,EAAE,eAAe,CAAC,CAAA;QAC/E,CAAC,CAAC,OAAM,CAAC;YAEP,OAAO,MAAM,eAAe,CAAC,6EAA6E,CAAC,CAAA;QAC7G,CAAC;QAGD,IAAI,cAAc,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAChC,OAAO,MAAM,eAAe,CAAC,sEAAsE,CAAC,CAAA;QACtG,CAAC;QAGD,IAAI,CAAC;YACH,OAAO,UAAM,oOAAwB,EAAC,cAAc,EAAE,QAAQ,EAAE,mBAAmB,EAAE,OAAO,EAAE,MAAM,CAAC,CAAA;QACvG,CAAC,CAAC,OAAM,CAAC;YAEP,OAAO,MAAM,eAAe,CAC1B,0FAA0F,CAC3F,CAAA;QACH,CAAC;IACH,CAAC;CACF"}},
    {"offset": {"line": 4637, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/retriever/index.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/retriever/index.ts"],"sourcesContent":["/**\n * PieceRetriever implementations for flexible piece fetching\n *\n * This module provides different strategies for retrieving pieces:\n * - ChainRetriever: Queries on-chain data to find providers\n * - FilBeamRetriever: CDN optimization wrapper\n * - SubgraphRetriever: Queries a GraphQL subgraph to find providers\n */\n\nexport { ChainRetriever } from './chain.ts'\nexport { FilBeamRetriever } from './filbeam.ts'\nexport { SubgraphRetriever } from './subgraph.ts'\n"],"names":[],"mappings":";AASA,OAAO,EAAE,cAAc,EAAE,MAAM,YAAY,CAAA;AAC3C,OAAO,EAAE,gBAAgB,EAAE,MAAM,cAAc,CAAA;AAC/C,OAAO,EAAE,iBAAiB,EAAE,MAAM,eAAe,CAAA"}},
    {"offset": {"line": 4648, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/warm-storage/service.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/warm-storage/service.ts"],"sourcesContent":["/**\n * WarmStorageService - Consolidated interface for all Warm Storage contract operations\n *\n * This combines functionality for:\n * - Data set management and queries\n * - Service provider registration and management\n * - Client dataset ID tracking\n * - Data set creation verification\n * - CDN service management\n *\n * @example\n * ```typescript\n * import { WarmStorageService } from '@filoz/synapse-sdk/warm-storage'\n * import { ethers } from 'ethers'\n *\n * const provider = new ethers.JsonRpcProvider(rpcUrl)\n * const warmStorageService = new WarmStorageService(provider, warmStorageAddress, pdpVerifierAddress)\n *\n * // Get data sets for a client\n * const dataSets = await warmStorageService.getClientDataSets(clientAddress)\n * console.log(`Client has ${dataSets.length} data sets`)\n *\n * // Register as a service provider\n * const signer = await provider.getSigner()\n * await warmStorageService.registerServiceProvider(signer, pdpUrl, retrievalUrl)\n * ```\n */\n\nimport { ethers } from 'ethers'\nimport type { PaymentsService } from '../payments/service.ts'\nimport type { DataSetCreationStatusResponse, PDPServer } from '../pdp/server.ts'\nimport { PDPVerifier } from '../pdp/verifier.ts'\nimport type { DataSetInfo, EnhancedDataSetInfo } from '../types.ts'\nimport { CONTRACT_ADDRESSES, SIZE_CONSTANTS, TIME_CONSTANTS, TIMING_CONSTANTS } from '../utils/constants.ts'\nimport { CONTRACT_ABIS, createError, getFilecoinNetworkType, TOKENS } from '../utils/index.ts'\n\n/**\n * Service price information\n */\nexport interface ServicePriceInfo {\n  /** Price per TiB per month without CDN (in base units) */\n  pricePerTiBPerMonthNoCDN: bigint\n  /** CDN egress price per TiB (usage-based, in base units) */\n  pricePerTiBCdnEgress: bigint\n  /** Cache miss egress price per TiB (usage-based, in base units) */\n  pricePerTiBCacheMissEgress: bigint\n  /** Token address for payments */\n  tokenAddress: string\n  /** Number of epochs per month */\n  epochsPerMonth: bigint\n  /** Minimum monthly charge for any dataset size (in base units) */\n  minimumPricePerMonth: bigint\n}\n\n/**\n * Result of verifying data set creation on-chain\n */\nexport interface DataSetCreationVerification {\n  /** Whether the transaction has been mined */\n  transactionMined: boolean\n  /** Whether the transaction was successful */\n  transactionSuccess: boolean\n  /** The data set ID that was created (if successful) */\n  dataSetId?: number\n  /** Whether the data set exists and is live on-chain */\n  dataSetLive: boolean\n  /** Block number where the transaction was mined (if mined) */\n  blockNumber?: number\n  /** Gas used by the transaction (if mined) */\n  gasUsed?: bigint\n  /** Error message if something went wrong */\n  error?: string\n}\n\n/**\n * Combined status information from both PDP server and chain\n */\nexport interface ComprehensiveDataSetStatus {\n  /** Transaction hash */\n  txHash: string\n  /** Server-side status */\n  serverStatus: DataSetCreationStatusResponse | null\n  /** Chain verification status */\n  chainStatus: DataSetCreationVerification\n  /** Combined status summary */\n  summary: {\n    /** Whether creation is complete and successful, both on chain and on the server */\n    isComplete: boolean\n    /** Whether data set is live on chain */\n    isLive: boolean\n    /** Final data set ID if available */\n    dataSetId: number | null\n    /** Any error messages */\n    error: string | null\n  }\n}\n\nexport class WarmStorageService {\n  private readonly _provider: ethers.Provider\n  private readonly _warmStorageAddress: string\n  private _warmStorageContract: ethers.Contract | null = null\n  private _warmStorageViewContract: ethers.Contract | null = null\n  private _pdpVerifier: PDPVerifier | null = null\n\n  // All discovered addresses\n  private readonly _addresses: {\n    pdpVerifier: string\n    payments: string\n    usdfcToken: string\n    filBeamBeneficiary: string\n    viewContract: string\n    serviceProviderRegistry: string\n    sessionKeyRegistry: string\n  }\n\n  /**\n   * Private constructor - use WarmStorageService.create() instead\n   */\n  private constructor(\n    provider: ethers.Provider,\n    warmStorageAddress: string,\n    addresses: {\n      pdpVerifier: string\n      payments: string\n      usdfcToken: string\n      filBeamBeneficiary: string\n      viewContract: string\n      serviceProviderRegistry: string\n      sessionKeyRegistry: string\n    }\n  ) {\n    this._provider = provider\n    this._warmStorageAddress = warmStorageAddress\n    this._addresses = addresses\n  }\n\n  /**\n   * Create a new WarmStorageService instance with initialized addresses\n   */\n  static async create(provider: ethers.Provider, warmStorageAddress: string): Promise<WarmStorageService> {\n    // Get network from provider and validate it's a supported Filecoin network\n    const networkName = await getFilecoinNetworkType(provider)\n\n    // Initialize all contract addresses using Multicall3\n    const multicall = new ethers.Contract(\n      CONTRACT_ADDRESSES.MULTICALL3[networkName],\n      CONTRACT_ABIS.MULTICALL3,\n      provider\n    )\n\n    const iface = new ethers.Interface(CONTRACT_ABIS.WARM_STORAGE)\n\n    const calls = [\n      {\n        target: warmStorageAddress,\n        allowFailure: false,\n        callData: iface.encodeFunctionData('pdpVerifierAddress'),\n      },\n      {\n        target: warmStorageAddress,\n        allowFailure: false,\n        callData: iface.encodeFunctionData('paymentsContractAddress'),\n      },\n      {\n        target: warmStorageAddress,\n        allowFailure: false,\n        callData: iface.encodeFunctionData('usdfcTokenAddress'),\n      },\n      {\n        target: warmStorageAddress,\n        allowFailure: false,\n        callData: iface.encodeFunctionData('filBeamBeneficiaryAddress'),\n      },\n      {\n        target: warmStorageAddress,\n        allowFailure: false,\n        callData: iface.encodeFunctionData('viewContractAddress'),\n      },\n      {\n        target: warmStorageAddress,\n        allowFailure: false,\n        callData: iface.encodeFunctionData('serviceProviderRegistry'),\n      },\n      {\n        target: warmStorageAddress,\n        allowFailure: false,\n        callData: iface.encodeFunctionData('sessionKeyRegistry'),\n      },\n    ]\n\n    const results = await multicall.aggregate3.staticCall(calls)\n\n    const addresses = {\n      pdpVerifier: iface.decodeFunctionResult('pdpVerifierAddress', results[0].returnData)[0],\n      payments: iface.decodeFunctionResult('paymentsContractAddress', results[1].returnData)[0],\n      usdfcToken: iface.decodeFunctionResult('usdfcTokenAddress', results[2].returnData)[0],\n      filBeamBeneficiary: iface.decodeFunctionResult('filBeamBeneficiaryAddress', results[3].returnData)[0],\n      viewContract: iface.decodeFunctionResult('viewContractAddress', results[4].returnData)[0],\n      serviceProviderRegistry: iface.decodeFunctionResult('serviceProviderRegistry', results[5].returnData)[0],\n      sessionKeyRegistry: iface.decodeFunctionResult('sessionKeyRegistry', results[6].returnData)[0],\n    }\n\n    return new WarmStorageService(provider, warmStorageAddress, addresses)\n  }\n\n  getPDPVerifierAddress(): string {\n    return this._addresses.pdpVerifier\n  }\n\n  getPaymentsAddress(): string {\n    return this._addresses.payments\n  }\n\n  getUSDFCTokenAddress(): string {\n    return this._addresses.usdfcToken\n  }\n\n  getViewContractAddress(): string {\n    return this._addresses.viewContract\n  }\n\n  getServiceProviderRegistryAddress(): string {\n    return this._addresses.serviceProviderRegistry\n  }\n\n  getSessionKeyRegistryAddress(): string {\n    return this._addresses.sessionKeyRegistry\n  }\n\n  /**\n   * Get the provider instance\n   * @returns The ethers provider\n   */\n  getProvider(): ethers.Provider {\n    return this._provider\n  }\n\n  /**\n   * Get cached Warm Storage contract instance or create new one\n   */\n  private _getWarmStorageContract(): ethers.Contract {\n    if (this._warmStorageContract == null) {\n      this._warmStorageContract = new ethers.Contract(\n        this._warmStorageAddress,\n        CONTRACT_ABIS.WARM_STORAGE,\n        this._provider\n      )\n    }\n    return this._warmStorageContract\n  }\n\n  /**\n   * Get cached Warm Storage View contract instance or create new one\n   */\n  private _getWarmStorageViewContract(): ethers.Contract {\n    if (this._warmStorageViewContract == null) {\n      const viewAddress = this.getViewContractAddress()\n      this._warmStorageViewContract = new ethers.Contract(viewAddress, CONTRACT_ABIS.WARM_STORAGE_VIEW, this._provider)\n    }\n    return this._warmStorageViewContract\n  }\n\n  /**\n   * Get cached PDPVerifier instance or create new one\n   */\n  private _getPDPVerifier(): PDPVerifier {\n    if (this._pdpVerifier == null) {\n      const address = this.getPDPVerifierAddress()\n      this._pdpVerifier = new PDPVerifier(this._provider, address)\n    }\n    return this._pdpVerifier\n  }\n\n  // ========== Client Data Set Operations ==========\n\n  /**\n   * Get a single data set by ID\n   * @param dataSetId - The data set ID to retrieve\n   * @returns Data set information\n   * @throws Error if data set doesn't exist\n   */\n  async getDataSet(dataSetId: number): Promise<DataSetInfo> {\n    const viewContract = this._getWarmStorageViewContract()\n    const ds = await viewContract.getDataSet(dataSetId)\n\n    if (Number(ds.pdpRailId) === 0) {\n      throw createError('WarmStorageService', 'getDataSet', `Data set ${dataSetId} does not exist`)\n    }\n\n    // Convert from on-chain format to our interface\n    return {\n      pdpRailId: Number(ds.pdpRailId),\n      cacheMissRailId: Number(ds.cacheMissRailId),\n      cdnRailId: Number(ds.cdnRailId),\n      payer: ds.payer,\n      payee: ds.payee,\n      serviceProvider: ds.serviceProvider,\n      commissionBps: Number(ds.commissionBps),\n      clientDataSetId: ds.clientDataSetId,\n      pdpEndEpoch: Number(ds.pdpEndEpoch),\n      providerId: Number(ds.providerId),\n      dataSetId,\n    }\n  }\n\n  /**\n   * Get all data sets for a specific client\n   * @param clientAddress - The client address\n   * @returns Array of data set information\n   */\n  async getClientDataSets(clientAddress: string): Promise<DataSetInfo[]> {\n    try {\n      const viewContract = this._getWarmStorageViewContract()\n      const dataSetData = await viewContract.getClientDataSets(clientAddress)\n\n      // Convert from on-chain format to our interface\n      return dataSetData.map((ds: any) => ({\n        pdpRailId: Number(ds.pdpRailId),\n        cacheMissRailId: Number(ds.cacheMissRailId),\n        cdnRailId: Number(ds.cdnRailId),\n        payer: ds.payer,\n        payee: ds.payee,\n        serviceProvider: ds.serviceProvider,\n        commissionBps: Number(ds.commissionBps),\n        clientDataSetId: ds.clientDataSetId,\n        pdpEndEpoch: Number(ds.pdpEndEpoch),\n        providerId: Number(ds.providerId),\n      }))\n    } catch (error) {\n      throw new Error(`Failed to get client data sets: ${error instanceof Error ? error.message : String(error)}`)\n    }\n  }\n\n  /**\n   * Get all data sets for a client with enhanced details\n   * This includes live status and management information\n   * @param client - The client address\n   * @param onlyManaged - If true, only return data sets managed by this Warm Storage contract\n   * @returns Array of enhanced data set information\n   */\n  async getClientDataSetsWithDetails(client: string, onlyManaged: boolean = false): Promise<EnhancedDataSetInfo[]> {\n    const pdpVerifier = this._getPDPVerifier()\n    const viewContract = this._getWarmStorageViewContract()\n\n    // Query dataset IDs directly from the view contract\n    const ids: bigint[] = await viewContract.clientDataSets(client)\n    if (ids.length === 0) return []\n\n    // Enhance all in parallel using dataset IDs\n    const enhancedDataSetsPromises = ids.map(async (idBigInt) => {\n      const pdpVerifierDataSetId = Number(idBigInt)\n      try {\n        const base = await this.getDataSet(pdpVerifierDataSetId)\n\n        // Parallelize independent calls\n        const [isLive, listenerResult, metadata] = await Promise.all([\n          pdpVerifier.dataSetLive(pdpVerifierDataSetId),\n          pdpVerifier.getDataSetListener(pdpVerifierDataSetId).catch(() => null),\n          this.getDataSetMetadata(pdpVerifierDataSetId).catch(() => Object.create(null) as Record<string, string>),\n        ])\n\n        // Check if this data set is managed by our Warm Storage contract\n        const isManaged =\n          listenerResult != null && listenerResult.toLowerCase() === this._warmStorageAddress.toLowerCase()\n\n        // Skip unmanaged data sets if onlyManaged is true\n        if (onlyManaged && !isManaged) {\n          return null // Will be filtered out\n        }\n\n        // Get next piece ID only if the data set is live\n        const nextPieceId = isLive ? await pdpVerifier.getNextPieceId(pdpVerifierDataSetId) : 0n\n\n        return {\n          ...base,\n          pdpVerifierDataSetId,\n          nextPieceId: Number(nextPieceId),\n          currentPieceCount: Number(nextPieceId),\n          isLive,\n          isManaged,\n          withCDN: base.cdnRailId > 0,\n          metadata,\n        }\n      } catch (error) {\n        throw new Error(\n          `Failed to get details for data set ${pdpVerifierDataSetId}: ${error instanceof Error ? error.message : String(error)}`\n        )\n      }\n    })\n\n    // Wait for all promises to resolve\n    const results = await Promise.all(enhancedDataSetsPromises)\n\n    // Filter out null values (from skipped data sets when onlyManaged is true)\n    return results.filter((result): result is EnhancedDataSetInfo => result !== null)\n  }\n\n  /**\n   * Validate that a dataset is live and managed by this WarmStorage contract\n   *\n   * Performs validation checks in parallel:\n   * - Dataset exists and is live\n   * - Dataset is managed by this WarmStorage contract\n   *\n   * @param dataSetId - The PDPVerifier data set ID\n   * @throws if dataset is not valid for operations\n   */\n  async validateDataSet(dataSetId: number): Promise<void> {\n    const pdpVerifier = this._getPDPVerifier()\n\n    // Parallelize validation checks\n    const [isLive, listener] = await Promise.all([\n      pdpVerifier.dataSetLive(Number(dataSetId)),\n      pdpVerifier.getDataSetListener(Number(dataSetId)),\n    ])\n\n    // Check if data set exists and is live\n    if (!isLive) {\n      throw new Error(`Data set ${dataSetId} does not exist or is not live`)\n    }\n\n    // Verify this data set is managed by our Warm Storage contract\n    if (listener.toLowerCase() !== this._warmStorageAddress.toLowerCase()) {\n      throw new Error(\n        `Data set ${dataSetId} is not managed by this WarmStorage contract (${\n          this._warmStorageAddress\n        }), managed by ${String(listener)}`\n      )\n    }\n  }\n\n  /**\n   * Verify that a data set creation transaction was successful\n   * This checks both the transaction status and on-chain data set state\n   * @param txHashOrTransaction - Transaction hash or transaction object\n   * @returns Verification result with data set ID if found\n   */\n  async verifyDataSetCreation(\n    txHashOrTransaction: string | ethers.TransactionResponse\n  ): Promise<DataSetCreationVerification> {\n    try {\n      // Get transaction hash\n      const txHash = typeof txHashOrTransaction === 'string' ? txHashOrTransaction : txHashOrTransaction.hash\n\n      // Get transaction receipt\n      let receipt: ethers.TransactionReceipt | null\n      if (typeof txHashOrTransaction === 'string') {\n        receipt = await this._provider.getTransactionReceipt(txHash)\n      } else {\n        // If we have a transaction object, use its wait method which is more efficient\n        receipt = await txHashOrTransaction.wait(TIMING_CONSTANTS.TRANSACTION_CONFIRMATIONS)\n      }\n\n      if (receipt == null) {\n        // Transaction not yet mined\n        return {\n          transactionMined: false,\n          transactionSuccess: false,\n          dataSetLive: false,\n        }\n      }\n\n      // Transaction is mined, check if it was successful\n      const transactionSuccess = receipt.status === 1\n\n      if (!transactionSuccess) {\n        return {\n          transactionMined: true,\n          transactionSuccess: false,\n          dataSetLive: false,\n          blockNumber: receipt.blockNumber,\n          gasUsed: receipt.gasUsed,\n          error: 'Transaction failed',\n        }\n      }\n\n      // Extract data set ID from transaction logs\n      const pdpVerifier = this._getPDPVerifier()\n      const dataSetId = await pdpVerifier.extractDataSetIdFromReceipt(receipt)\n\n      if (dataSetId == null) {\n        return {\n          transactionMined: true,\n          transactionSuccess: true,\n          dataSetLive: false,\n          blockNumber: receipt.blockNumber,\n          gasUsed: receipt.gasUsed,\n          error: 'Could not find DataSetCreated event in transaction',\n        }\n      }\n\n      // Verify the data set exists and is live on-chain\n      const isLive = await pdpVerifier.dataSetLive(dataSetId)\n\n      return {\n        transactionMined: true,\n        transactionSuccess: true,\n        dataSetId,\n        dataSetLive: isLive,\n        blockNumber: receipt.blockNumber,\n        gasUsed: receipt.gasUsed,\n      }\n    } catch (error) {\n      // Error during verification (e.g., network issues)\n      return {\n        transactionMined: false,\n        transactionSuccess: false,\n        dataSetLive: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      }\n    }\n  }\n\n  /**\n   * Get comprehensive data set creation status combining server and chain info\n   * @param txHashOrTransaction - Transaction hash or transaction object\n   * @param pdpServer - PDP server instance for status checks\n   * @returns Combined status information\n   */\n  async getComprehensiveDataSetStatus(\n    txHashOrTransaction: string | ethers.TransactionResponse,\n    pdpServer?: PDPServer\n  ): Promise<ComprehensiveDataSetStatus> {\n    const txHash = typeof txHashOrTransaction === 'string' ? txHashOrTransaction : txHashOrTransaction.hash\n\n    // Get server status if pdpServer provided\n    let serverStatus: DataSetCreationStatusResponse | null = null\n    if (pdpServer != null) {\n      try {\n        performance.mark('synapse:pdpServer.getDataSetCreationStatus-start')\n        serverStatus = await pdpServer.getDataSetCreationStatus(txHash)\n        performance.mark('synapse:pdpServer.getDataSetCreationStatus-end')\n        performance.measure(\n          'synapse:pdpServer.getDataSetCreationStatus',\n          'synapse:pdpServer.getDataSetCreationStatus-start',\n          'synapse:pdpServer.getDataSetCreationStatus-end'\n        )\n      } catch {\n        performance.mark('synapse:pdpServer.getDataSetCreationStatus-end')\n        performance.measure(\n          'synapse:pdpServer.getDataSetCreationStatus',\n          'synapse:pdpServer.getDataSetCreationStatus-start',\n          'synapse:pdpServer.getDataSetCreationStatus-end'\n        )\n        // Server doesn't have status yet or error occurred\n      }\n    }\n\n    // Get chain status (pass through the transaction object if we have it)\n    performance.mark('synapse:verifyDataSetCreation-start')\n    const chainStatus = await this.verifyDataSetCreation(txHashOrTransaction)\n    performance.mark('synapse:verifyDataSetCreation-end')\n    performance.measure(\n      'synapse:verifyDataSetCreation',\n      'synapse:verifyDataSetCreation-start',\n      'synapse:verifyDataSetCreation-end'\n    )\n\n    // Combine into summary\n    // isComplete should be true only when BOTH chain and server have confirmed the data set creation\n    const isComplete =\n      chainStatus.transactionMined &&\n      chainStatus.transactionSuccess &&\n      chainStatus.dataSetId != null &&\n      chainStatus.dataSetLive &&\n      serverStatus != null &&\n      serverStatus.ok === true &&\n      serverStatus.dataSetCreated\n    const dataSetId = serverStatus?.dataSetId ?? chainStatus.dataSetId ?? null\n\n    // Determine error from server status or chain status\n    let error: string | null = chainStatus.error ?? null\n    if (serverStatus != null && serverStatus.ok === false) {\n      error = `Server reported transaction failed (status: ${serverStatus.txStatus})`\n    }\n\n    return {\n      txHash,\n      serverStatus,\n      chainStatus,\n      summary: {\n        isComplete,\n        isLive: chainStatus.dataSetLive,\n        dataSetId,\n        error,\n      },\n    }\n  }\n\n  /**\n   * Wait for data set creation with status updates\n   * @param txHashOrTransaction - Transaction hash or transaction object to wait for\n   * @param pdpServer - PDP server for status checks\n   * @param maxWaitTime - Maximum time to wait in milliseconds\n   * @param pollInterval - Polling interval in milliseconds\n   * @param onProgress - Optional progress callback\n   * @returns Final comprehensive status\n   */\n  async waitForDataSetCreationWithStatus(\n    txHashOrTransaction: string | ethers.TransactionResponse,\n    pdpServer: PDPServer,\n    maxWaitTime: number = TIMING_CONSTANTS.DATA_SET_CREATION_TIMEOUT_MS,\n    pollInterval: number = TIMING_CONSTANTS.DATA_SET_CREATION_POLL_INTERVAL_MS,\n    onProgress?: (status: ComprehensiveDataSetStatus, elapsedMs: number) => Promise<void>\n  ): Promise<ComprehensiveDataSetStatus> {\n    const startTime = Date.now()\n\n    while (Date.now() - startTime < maxWaitTime) {\n      const status = await this.getComprehensiveDataSetStatus(txHashOrTransaction, pdpServer)\n      const elapsedMs = Date.now() - startTime\n\n      // Fire progress callback if provided\n      if (onProgress != null) {\n        try {\n          await onProgress(status, elapsedMs)\n        } catch (error) {\n          // Don't let callback errors break the polling loop\n          console.error('Error in progress callback:', error)\n        }\n      }\n\n      // Check if complete\n      if (status.summary.isComplete) {\n        return status\n      }\n\n      // Check for errors\n      if (status.summary.error != null && status.chainStatus.transactionMined) {\n        // Transaction confirmed but failed\n        throw new Error(status.summary.error)\n      }\n\n      // Wait before next poll\n      await new Promise((resolve) => setTimeout(resolve, pollInterval))\n    }\n\n    // Timeout\n    throw new Error(`Data set creation timed out after ${maxWaitTime / 1000} seconds`)\n  }\n\n  // ========== Metadata Operations ==========\n\n  /**\n   * Get all metadata for a data set\n   * @param dataSetId - The data set ID\n   * @returns Object with metadata key-value pairs\n   */\n  async getDataSetMetadata(dataSetId: number): Promise<Record<string, string>> {\n    const viewContract = this._getWarmStorageViewContract()\n    const [keys, values] = await viewContract.getAllDataSetMetadata(dataSetId)\n\n    // Create a prototype-safe object to avoid pollution risks from arbitrary keys\n    const metadata: Record<string, string> = Object.create(null)\n    for (let i = 0; i < keys.length; i++) {\n      metadata[keys[i]] = values[i]\n    }\n    return metadata\n  }\n\n  /**\n   * Get specific metadata key for a data set\n   * @param dataSetId - The data set ID\n   * @param key - The metadata key to retrieve\n   * @returns The metadata value if it exists, null otherwise\n   */\n  async getDataSetMetadataByKey(dataSetId: number, key: string): Promise<string | null> {\n    const viewContract = this._getWarmStorageViewContract()\n    const [exists, value] = await viewContract.getDataSetMetadata(dataSetId, key)\n    return exists ? value : null\n  }\n\n  /**\n   * Get all metadata for a piece in a data set\n   * @param dataSetId - The data set ID\n   * @param pieceId - The piece ID\n   * @returns Object with metadata key-value pairs\n   */\n  async getPieceMetadata(dataSetId: number, pieceId: number): Promise<Record<string, string>> {\n    const viewContract = this._getWarmStorageViewContract()\n    const [keys, values] = await viewContract.getAllPieceMetadata(dataSetId, pieceId)\n\n    // Create a prototype-safe object to avoid pollution risks from arbitrary keys\n    const metadata: Record<string, string> = Object.create(null)\n    for (let i = 0; i < keys.length; i++) {\n      metadata[keys[i]] = values[i]\n    }\n    return metadata\n  }\n\n  /**\n   * Get specific metadata key for a piece in a data set\n   * @param dataSetId - The data set ID\n   * @param pieceId - The piece ID\n   * @param key - The metadata key to retrieve\n   * @returns The metadata value if it exists, null otherwise\n   */\n  async getPieceMetadataByKey(dataSetId: number, pieceId: number, key: string): Promise<string | null> {\n    const viewContract = this._getWarmStorageViewContract()\n    const [exists, value] = await viewContract.getPieceMetadata(dataSetId, pieceId, key)\n    return exists ? value : null\n  }\n\n  // ========== Storage Cost Operations ==========\n\n  /**\n   * Get the current service price per TiB per month\n   * @returns Service price information for both CDN and non-CDN options\n   */\n  async getServicePrice(): Promise<ServicePriceInfo> {\n    const contract = this._getWarmStorageContract()\n    const pricing = await contract.getServicePrice()\n    return {\n      pricePerTiBPerMonthNoCDN: pricing.pricePerTiBPerMonthNoCDN,\n      pricePerTiBCdnEgress: pricing.pricePerTiBCdnEgress,\n      pricePerTiBCacheMissEgress: pricing.pricePerTiBCacheMissEgress,\n      tokenAddress: pricing.tokenAddress,\n      epochsPerMonth: pricing.epochsPerMonth,\n      minimumPricePerMonth: pricing.minimumPricePerMonth,\n    }\n  }\n\n  /**\n   * Calculate storage costs for a given size\n   * @param sizeInBytes - Size of data to store in bytes\n   * @returns Cost estimates per epoch, day, and month\n   * @remarks CDN costs are usage-based (egress pricing), so withCDN field reflects base storage cost only\n   */\n  async calculateStorageCost(sizeInBytes: number): Promise<{\n    perEpoch: bigint\n    perDay: bigint\n    perMonth: bigint\n    withCDN: {\n      perEpoch: bigint\n      perDay: bigint\n      perMonth: bigint\n    }\n  }> {\n    const servicePriceInfo = await this.getServicePrice()\n\n    // Calculate price per byte per epoch (base storage cost)\n    const sizeInBytesBigint = BigInt(sizeInBytes)\n    const pricePerEpoch =\n      (servicePriceInfo.pricePerTiBPerMonthNoCDN * sizeInBytesBigint) /\n      (SIZE_CONSTANTS.TiB * servicePriceInfo.epochsPerMonth)\n\n    const costs = {\n      perEpoch: pricePerEpoch,\n      perDay: pricePerEpoch * BigInt(TIME_CONSTANTS.EPOCHS_PER_DAY),\n      perMonth: pricePerEpoch * servicePriceInfo.epochsPerMonth,\n    }\n\n    // CDN costs are usage-based (egress pricing), so withCDN returns base storage cost\n    // Actual CDN costs will be charged based on egress usage\n    return {\n      ...costs,\n      withCDN: costs,\n    }\n  }\n\n  /**\n   * Check if user has sufficient allowances for a storage operation and calculate costs\n   * @param sizeInBytes - Size of data to store\n   * @param withCDN - Whether CDN is enabled\n   * @param paymentsService - PaymentsService instance to check allowances\n   * @param lockupDays - Number of days for lockup period (defaults to 10)\n   * @returns Allowance requirement details and storage costs\n   */\n  async checkAllowanceForStorage(\n    sizeInBytes: number,\n    withCDN: boolean,\n    paymentsService: PaymentsService,\n    lockupDays?: number\n  ): Promise<{\n    rateAllowanceNeeded: bigint\n    lockupAllowanceNeeded: bigint\n    currentRateAllowance: bigint\n    currentLockupAllowance: bigint\n    currentRateUsed: bigint\n    currentLockupUsed: bigint\n    sufficient: boolean\n    message?: string\n    costs: {\n      perEpoch: bigint\n      perDay: bigint\n      perMonth: bigint\n    }\n    depositAmountNeeded: bigint\n  }> {\n    // Get current allowances and calculate costs in parallel\n    const [approval, costs] = await Promise.all([\n      paymentsService.serviceApproval(this._warmStorageAddress, TOKENS.USDFC),\n      this.calculateStorageCost(sizeInBytes),\n    ])\n\n    const selectedCosts = withCDN ? costs.withCDN : costs\n    const rateNeeded = selectedCosts.perEpoch\n\n    // Calculate lockup period based on provided days (default: 10)\n    const lockupPeriod =\n      BigInt(lockupDays ?? Number(TIME_CONSTANTS.DEFAULT_LOCKUP_DAYS)) * BigInt(TIME_CONSTANTS.EPOCHS_PER_DAY)\n    const lockupNeeded = rateNeeded * lockupPeriod\n\n    // Calculate required allowances (current usage + new requirement)\n    const totalRateNeeded = BigInt(approval.rateUsed) + rateNeeded\n    const totalLockupNeeded = BigInt(approval.lockupUsed) + lockupNeeded\n\n    // Check if allowances are sufficient\n    const sufficient = approval.rateAllowance >= totalRateNeeded && approval.lockupAllowance >= totalLockupNeeded\n\n    // Calculate how much more is needed\n    const rateAllowanceNeeded = totalRateNeeded > approval.rateAllowance ? totalRateNeeded - approval.rateAllowance : 0n\n\n    const lockupAllowanceNeeded =\n      totalLockupNeeded > approval.lockupAllowance ? totalLockupNeeded - approval.lockupAllowance : 0n\n\n    // Build optional message\n    let message: string | undefined\n    if (!sufficient) {\n      const needsRate = rateAllowanceNeeded > 0n\n      const needsLockup = lockupAllowanceNeeded > 0n\n      if (needsRate && needsLockup) {\n        message = 'Insufficient rate and lockup allowances'\n      } else if (needsRate) {\n        message = 'Insufficient rate allowance'\n      } else if (needsLockup) {\n        message = 'Insufficient lockup allowance'\n      }\n    }\n\n    return {\n      rateAllowanceNeeded,\n      lockupAllowanceNeeded,\n      currentRateAllowance: approval.rateAllowance,\n      currentLockupAllowance: approval.lockupAllowance,\n      currentRateUsed: approval.rateUsed,\n      currentLockupUsed: approval.lockupUsed,\n      sufficient,\n      message,\n      costs: selectedCosts,\n      depositAmountNeeded: lockupNeeded,\n    }\n  }\n\n  /**\n   * Prepare for storage upload by checking balances and allowances\n   *\n   * This method performs a comprehensive check of the prerequisites for storage upload,\n   * including verifying sufficient funds and service allowances. It returns a list of\n   * actions that need to be executed before the upload can proceed.\n   *\n   * @param options - Configuration options for the storage upload\n   * @param options.dataSize - Size of data to store in bytes\n   * @param options.withCDN - Whether to enable CDN for faster retrieval (optional, defaults to false)\n   * @param paymentsService - Instance of PaymentsService for handling payment operations\n   *\n   * @returns Object containing:\n   *   - estimatedCost: Breakdown of storage costs (per epoch, day, and month)\n   *   - allowanceCheck: Status of service allowances with optional message\n   *   - actions: Array of required actions (deposit, approveService) that need to be executed\n   *\n   * @example\n   * ```typescript\n   * const prep = await warmStorageService.prepareStorageUpload(\n   *   { dataSize: Number(SIZE_CONSTANTS.GiB), withCDN: true },\n   *   paymentsService\n   * )\n   *\n   * if (prep.actions.length > 0) {\n   *   for (const action of prep.actions) {\n   *     console.log(`Executing: ${action.description}`)\n   *     await action.execute()\n   *   }\n   * }\n   * ```\n   */\n  async prepareStorageUpload(\n    options: {\n      dataSize: number\n      withCDN?: boolean\n    },\n    paymentsService: PaymentsService\n  ): Promise<{\n    estimatedCost: {\n      perEpoch: bigint\n      perDay: bigint\n      perMonth: bigint\n    }\n    allowanceCheck: {\n      sufficient: boolean\n      message?: string\n    }\n    actions: Array<{\n      type: 'deposit' | 'approve' | 'approveService'\n      description: string\n      execute: () => Promise<ethers.TransactionResponse>\n    }>\n  }> {\n    // Parallelize cost calculation and allowance check\n    const [costs, allowanceCheck] = await Promise.all([\n      this.calculateStorageCost(options.dataSize),\n      this.checkAllowanceForStorage(options.dataSize, options.withCDN ?? false, paymentsService),\n    ])\n\n    // Select the appropriate costs based on CDN option\n    const selectedCosts = (options.withCDN ?? false) ? costs.withCDN : costs\n\n    const actions: Array<{\n      type: 'deposit' | 'approve' | 'approveService'\n      description: string\n      execute: () => Promise<ethers.TransactionResponse>\n    }> = []\n\n    // Check if deposit is needed\n    const accountInfo = await paymentsService.accountInfo(TOKENS.USDFC)\n    const requiredBalance = selectedCosts.perMonth // Require at least 1 month of funds\n\n    if (accountInfo.availableFunds < requiredBalance) {\n      const depositAmount = requiredBalance - accountInfo.availableFunds\n      actions.push({\n        type: 'deposit',\n        description: `Deposit ${depositAmount} USDFC to payments contract`,\n        execute: async () => await paymentsService.deposit(depositAmount, TOKENS.USDFC),\n      })\n    }\n\n    // Check if service approval is needed\n    if (!allowanceCheck.sufficient) {\n      actions.push({\n        type: 'approveService',\n        description: `Approve service with rate allowance ${allowanceCheck.rateAllowanceNeeded} and lockup allowance ${allowanceCheck.lockupAllowanceNeeded}`,\n        execute: async () =>\n          await paymentsService.approveService(\n            this._warmStorageAddress,\n            allowanceCheck.rateAllowanceNeeded,\n            allowanceCheck.lockupAllowanceNeeded,\n            TIME_CONSTANTS.EPOCHS_PER_MONTH, // 30 days max lockup period\n            TOKENS.USDFC\n          ),\n      })\n    }\n\n    return {\n      estimatedCost: {\n        perEpoch: selectedCosts.perEpoch,\n        perDay: selectedCosts.perDay,\n        perMonth: selectedCosts.perMonth,\n      },\n      allowanceCheck: {\n        sufficient: allowanceCheck.sufficient,\n        message: allowanceCheck.sufficient\n          ? undefined\n          : `Insufficient allowances: rate needed ${allowanceCheck.rateAllowanceNeeded}, lockup needed ${allowanceCheck.lockupAllowanceNeeded}`,\n      },\n      actions,\n    }\n  }\n\n  // ========== Data Set Operations ==========\n\n  /**\n   * Terminate a data set with given ID\n   * @param signer - Signer which created this dataset\n   * @param dataSetId  - ID of the data set to terminate\n   * @returns Transaction receipt\n   */\n  async terminateDataSet(signer: ethers.Signer, dataSetId: number): Promise<ethers.TransactionResponse> {\n    const contract = this._getWarmStorageContract()\n    const contractWithSigner = contract.connect(signer) as ethers.Contract\n    return await contractWithSigner.terminateService(dataSetId)\n  }\n\n  // ========== Service Provider Approval Operations ==========\n\n  /**\n   * Add an approved provider by ID (owner only)\n   * @param signer - Signer with owner permissions\n   * @param providerId - Provider ID from registry\n   * @returns Transaction response\n   */\n  async addApprovedProvider(signer: ethers.Signer, providerId: number): Promise<ethers.TransactionResponse> {\n    const contract = this._getWarmStorageContract()\n    const contractWithSigner = contract.connect(signer) as ethers.Contract\n    return await contractWithSigner.addApprovedProvider(providerId)\n  }\n\n  /**\n   * Remove an approved provider by ID (owner only)\n   * @param signer - Signer with owner permissions\n   * @param providerId - Provider ID from registry\n   * @returns Transaction response\n   */\n  async removeApprovedProvider(signer: ethers.Signer, providerId: number): Promise<ethers.TransactionResponse> {\n    const contract = this._getWarmStorageContract()\n    const contractWithSigner = contract.connect(signer) as ethers.Contract\n\n    // First, we need to find the index of this provider in the array\n    const viewContract = this._getWarmStorageViewContract()\n    const approvedIds = await viewContract.getApprovedProviders(0n, 0n)\n    const index = approvedIds.findIndex((id: bigint) => Number(id) === providerId)\n\n    if (index === -1) {\n      throw new Error(`Provider ${providerId} is not in the approved list`)\n    }\n\n    return await contractWithSigner.removeApprovedProvider(providerId, index)\n  }\n\n  /**\n   * Get list of approved provider IDs\n   * @returns Array of approved provider IDs\n   */\n  async getApprovedProviderIds(): Promise<number[]> {\n    const viewContract = this._getWarmStorageViewContract()\n    const providerIds = await viewContract.getApprovedProviders(0n, 0n)\n    return providerIds.map((id: bigint) => Number(id))\n  }\n\n  /**\n   * Check if a provider ID is approved\n   * @param providerId - Provider ID to check\n   * @returns Whether the provider is approved\n   */\n  async isProviderIdApproved(providerId: number): Promise<boolean> {\n    const viewContract = this._getWarmStorageViewContract()\n    return await viewContract.isProviderApproved(providerId)\n  }\n\n  /**\n   * Get the contract owner address\n   * @returns Owner address\n   */\n  async getOwner(): Promise<string> {\n    const contract = this._getWarmStorageContract()\n    return await contract.owner()\n  }\n\n  /**\n   * Check if a signer is the contract owner\n   * @param signer - Signer to check\n   * @returns Whether the signer is the owner\n   */\n  async isOwner(signer: ethers.Signer): Promise<boolean> {\n    const signerAddress = await signer.getAddress()\n    const ownerAddress = await this.getOwner()\n    return signerAddress.toLowerCase() === ownerAddress.toLowerCase()\n  }\n\n  // ========== Proving Period Operations ==========\n\n  /**\n   * Get the maximum proving period from the WarmStorage contract\n   * @returns Maximum proving period in epochs\n   */\n  async getMaxProvingPeriod(): Promise<number> {\n    const viewContract = this._getWarmStorageViewContract()\n    const maxPeriod = await viewContract.getMaxProvingPeriod()\n    return Number(maxPeriod)\n  }\n\n  /**\n   * Get the challenge window size from the WarmStorage contract\n   * @returns Challenge window size in epochs\n   */\n  async getChallengeWindow(): Promise<number> {\n    const viewContract = this._getWarmStorageViewContract()\n    const window = await viewContract.challengeWindow()\n    return Number(window)\n  }\n  /**\n   * Increments the fixed locked-up amounts for CDN payment rails.\n   *\n   * This method tops up the prepaid balance for CDN services by adding to the existing\n   * lockup amounts. Both CDN and cache miss rails can be incremented independently.\n   *\n   * @param dataSetId - The ID of the data set\n   * @param cdnAmountToAdd - Amount to add to the CDN rail lockup\n   * @param cacheMissAmountToAdd - Amount to add to the cache miss rail lockup\n   * @returns Transaction response\n   */\n  async topUpCDNPaymentRails(\n    signer: ethers.Signer,\n    dataSetId: number,\n    cdnAmountToAdd: bigint,\n    cacheMissAmountToAdd: bigint\n  ): Promise<ethers.TransactionResponse> {\n    if (cdnAmountToAdd < 0n || cacheMissAmountToAdd < 0n) {\n      throw new Error('Top up amounts must be positive')\n    }\n    if (cdnAmountToAdd === 0n && cacheMissAmountToAdd === 0n) {\n      throw new Error('At least one top up amount must be >0')\n    }\n\n    const contract = this._getWarmStorageContract()\n    const contractWithSigner = contract.connect(signer) as ethers.Contract\n    return await contractWithSigner.topUpCDNPaymentRails(dataSetId, cdnAmountToAdd, cacheMissAmountToAdd)\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5167, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/warm-storage/index.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/warm-storage/index.ts"],"sourcesContent":["/**\n * Exports the Warm Storage components\n *\n * @packageDocumentation\n * @module WarmStorage\n * @example\n * ```ts\n * import { WarmStorageService } from '@filoz/synapse-sdk/warm-storage'\n * ```\n */\n\nexport type {\n  ComprehensiveDataSetStatus,\n  DataSetCreationVerification,\n} from './service.ts'\nexport { WarmStorageService } from './service.ts'\n"],"names":[],"mappings":";AAeA,OAAO,EAAE,kBAAkB,EAAE,MAAM,cAAc,CAAA"}},
    {"offset": {"line": 5174, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/synapse.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/synapse.ts"],"sourcesContent":["/**\n * Main Synapse class for interacting with Filecoin storage and other on-chain services\n */\n\nimport { ethers } from 'ethers'\nimport { PaymentsService } from './payments/index.ts'\nimport { ChainRetriever, FilBeamRetriever, SubgraphRetriever } from './retriever/index.ts'\nimport { SessionKey } from './session/key.ts'\nimport { SPRegistryService } from './sp-registry/index.ts'\nimport type { StorageService } from './storage/index.ts'\nimport { StorageManager } from './storage/manager.ts'\nimport { SubgraphService } from './subgraph/service.ts'\nimport type { TelemetryService } from './telemetry/service.ts'\nimport { getGlobalTelemetry, initGlobalTelemetry } from './telemetry/singleton.ts'\nimport type {\n  FilecoinNetworkType,\n  PieceCID,\n  PieceRetriever,\n  ProviderInfo,\n  StorageInfo,\n  StorageServiceOptions,\n  SubgraphConfig,\n  SynapseOptions,\n} from './types.ts'\nimport { CHAIN_IDS, CONTRACT_ADDRESSES, getFilecoinNetworkType } from './utils/index.ts'\nimport { WarmStorageService } from './warm-storage/index.ts'\n\nexport class Synapse {\n  private readonly _signer: ethers.Signer\n  private readonly _network: FilecoinNetworkType\n  private readonly _withCDN: boolean\n  private readonly _payments: PaymentsService\n  private readonly _provider: ethers.Provider\n  private readonly _warmStorageAddress: string\n  private readonly _warmStorageService: WarmStorageService\n  private readonly _pieceRetriever: PieceRetriever\n  private readonly _storageManager: StorageManager\n  private _session: SessionKey | null = null\n\n  /**\n   * Create a new Synapse instance with async initialization.\n   * @param options - Configuration options for Synapse\n   * @returns A fully initialized Synapse instance\n   */\n  static async create(options: SynapseOptions): Promise<Synapse> {\n    // Validate options\n    const providedOptions = [options.privateKey, options.provider, options.signer].filter(Boolean).length\n    if (providedOptions !== 1) {\n      throw new Error('Must provide exactly one of: privateKey, provider, or signer')\n    }\n\n    // Detect network from chain\n    let network: FilecoinNetworkType | undefined\n\n    // Create or derive signer and provider\n    let signer: ethers.Signer\n    let provider: ethers.Provider\n\n    if (options.privateKey != null) {\n      // Handle private key input\n      const rpcURL = options.rpcURL ?? options.rpcURL\n      if (rpcURL == null) {\n        throw new Error('rpcURL is required when using privateKey')\n      }\n\n      // Sanitize private key\n      let privateKey = options.privateKey\n      if (!privateKey.startsWith('0x')) {\n        privateKey = `0x${privateKey}`\n      }\n\n      // Create provider and wallet\n      // if websockets, use correct provider\n      if (/^ws(s)?:\\/\\//i.test(rpcURL)) {\n        provider = new ethers.WebSocketProvider(rpcURL)\n      } else {\n        provider = new ethers.JsonRpcProvider(rpcURL)\n      }\n\n      network = await getFilecoinNetworkType(provider)\n\n      // Create wallet with provider - always use NonceManager unless disabled\n      const wallet = new ethers.Wallet(privateKey, provider)\n      signer = options.disableNonceManager === true ? wallet : new ethers.NonceManager(wallet)\n    } else if (options.provider != null) {\n      // Handle provider input\n      provider = options.provider\n\n      network = await getFilecoinNetworkType(provider)\n\n      // Get signer - apply NonceManager unless disabled\n      // For ethers v6, we need to check if provider has getSigner method\n      if ('getSigner' in provider && typeof provider.getSigner === 'function') {\n        const baseSigner = await (provider as any).getSigner(0)\n        signer = options.disableNonceManager === true ? baseSigner : new ethers.NonceManager(baseSigner)\n      } else {\n        throw new Error('Provider does not support signing operations')\n      }\n    } else if (options.signer != null) {\n      // Handle signer input\n      signer = options.signer\n\n      // Apply NonceManager wrapper unless disabled\n      if (options.disableNonceManager !== true && !(signer instanceof ethers.NonceManager)) {\n        signer = new ethers.NonceManager(signer)\n      }\n\n      // Get provider from signer\n      if (signer.provider == null) {\n        throw new Error('Signer must have a provider')\n      }\n      provider = signer.provider\n\n      network = await getFilecoinNetworkType(provider)\n    } else {\n      // This should never happen due to validation above\n      throw new Error('No valid authentication method provided')\n    }\n\n    // Final network validation\n    if (network !== 'mainnet' && network !== 'calibration') {\n      throw new Error(`Invalid network: ${String(network)}. Only 'mainnet' and 'calibration' are supported.`)\n    }\n\n    // Create Warm Storage service with initialized addresses\n    const warmStorageAddress = options.warmStorageAddress ?? CONTRACT_ADDRESSES.WARM_STORAGE[network]\n    if (!warmStorageAddress) {\n      throw new Error(`No Warm Storage address configured for network: ${network}`)\n    }\n    const warmStorageService = await WarmStorageService.create(provider, warmStorageAddress)\n\n    // Create payments service with discovered addresses\n    const paymentsAddress = warmStorageService.getPaymentsAddress()\n    const usdfcAddress = warmStorageService.getUSDFCTokenAddress()\n    const payments = new PaymentsService(\n      provider,\n      signer,\n      paymentsAddress,\n      usdfcAddress,\n      options.disableNonceManager === true\n    )\n\n    // Create SPRegistryService for use in retrievers\n    const registryAddress = warmStorageService.getServiceProviderRegistryAddress()\n    const spRegistry = new SPRegistryService(provider, registryAddress)\n\n    // Initialize piece retriever (use provided or create default)\n    let pieceRetriever: PieceRetriever\n    if (options.pieceRetriever != null) {\n      pieceRetriever = options.pieceRetriever\n    } else {\n      // Create default retriever chain: FilBeam wraps the base retriever\n      const chainRetriever = new ChainRetriever(warmStorageService, spRegistry)\n\n      // Check for subgraph option\n      let baseRetriever: PieceRetriever = chainRetriever\n      if (options.subgraphConfig != null || options.subgraphService != null) {\n        const subgraphService =\n          options.subgraphService != null\n            ? options.subgraphService\n            : new SubgraphService(options.subgraphConfig as SubgraphConfig)\n        baseRetriever = new SubgraphRetriever(subgraphService)\n      }\n\n      // Wrap with FilBeam retriever\n      pieceRetriever = new FilBeamRetriever(baseRetriever, network)\n    }\n\n    // Create and initialize the global TelemetryService.\n    // If telemetry is disabled, this will do nothing.\n    await initGlobalTelemetry(options.telemetry || {}, { filecoinNetwork: network })\n\n    return new Synapse(\n      signer,\n      provider,\n      network,\n      payments,\n      options.withCDN === true,\n      warmStorageAddress,\n      warmStorageService,\n      pieceRetriever,\n      options.dev === false,\n      options.withIpni\n    )\n  }\n\n  private constructor(\n    signer: ethers.Signer,\n    provider: ethers.Provider,\n    network: FilecoinNetworkType,\n    payments: PaymentsService,\n    withCDN: boolean,\n\n    warmStorageAddress: string,\n    warmStorageService: WarmStorageService,\n    pieceRetriever: PieceRetriever,\n    dev: boolean,\n    withIpni?: boolean\n  ) {\n    this._signer = signer\n    this._provider = provider\n    this._network = network\n    this._payments = payments\n    this._withCDN = withCDN\n    this._warmStorageService = warmStorageService\n    this._pieceRetriever = pieceRetriever\n    this._warmStorageAddress = warmStorageAddress\n    this._session = null\n\n    // Initialize StorageManager\n    this._storageManager = new StorageManager(\n      this,\n      this._warmStorageService,\n      this._pieceRetriever,\n      this._withCDN,\n      dev,\n      withIpni\n    )\n  }\n\n  /**\n   * Gets the current network type\n   * @returns The network type ('mainnet' or 'calibration')\n   */\n  getNetwork(): FilecoinNetworkType {\n    return this._network\n  }\n\n  /**\n   * Gets the TelemetryService for error tracking and debugging.\n   * @returns The global TelemetryService instance\n   * @example\n   * ```typescript\n   * // Get debug dump for support tickets\n   * const dump = synapse.telemetry.debugDump()\n   * console.log(JSON.stringify(dump, null, 2))\n   *\n   * // Track custom events\n   * synapse.telemetry.sentry.captureCustomEvent('user-action', { action: 'upload' })\n   * ```\n   */\n  get telemetry(): TelemetryService | null {\n    return getGlobalTelemetry()\n  }\n\n  /**\n   * Gets the signer instance, possibly a session key\n   * @returns The ethers signer\n   */\n  getSigner(): ethers.Signer {\n    if (this._session == null) {\n      return this._signer\n    } else {\n      return this._session.getSigner()\n    }\n  }\n\n  /**\n   * Gets the client signer instance\n   * @returns the ethers signer\n   */\n  getClient(): ethers.Signer {\n    return this._signer\n  }\n\n  /**\n   * Wraps the signer as a session key\n   * @param sessionKeySigner The signer for the session key\n   * @returns The SessionKey object for this signer\n   */\n  createSessionKey(sessionKeySigner: ethers.Signer): SessionKey {\n    return new SessionKey(\n      this._provider,\n      this._warmStorageService.getSessionKeyRegistryAddress(),\n      sessionKeySigner,\n      this._signer\n    )\n  }\n\n  /**\n   * Sets the signer as the session key for storage actions\n   * @param sessionKey The session key used by storage contexts\n   * @example\n   * ```typescript\n   * const sessionKey = synapse.createSessionKey(privateKey)\n   *\n   * // check for previous login\n   * const expiries = await sessionKey.fetchExpiries(PDP_PERMISSIONS)\n   * const HOUR_MILLIS = BigInt(1000 * 60 * 60)\n   * if (expiries[ADD_PIECES_TYPEHASH] * BigInt(1000) < BigInt(Date.now()) + HOUR_MILLIS) {\n   *   const DAY_MILLIS = BigInt(24) * HOUR_MILLIS\n   *   const loginTx = await sessionKey.login(BigInt(Date.now()) / BigInt(1000 + 30 * DAY_MILLIS), PDP_PERMISSIONS, \"example.com\")\n   *   const loginReceipt = await loginTx.wait()\n   * }\n   *\n   * synapse.setSession(sessionKey)\n   * const context = await synapse.storage.createContext()\n   * ```\n   */\n  setSession(sessionKey: SessionKey | null) {\n    this._session = sessionKey\n  }\n\n  /**\n   * Gets the provider instance\n   * @returns The ethers provider\n   */\n  getProvider(): ethers.Provider {\n    return this._provider\n  }\n\n  /**\n   * Gets the current chain ID\n   * @returns The numeric chain ID\n   */\n  getChainId(): number {\n    return this._network === 'mainnet' ? CHAIN_IDS.mainnet : CHAIN_IDS.calibration\n  }\n\n  /**\n   * Gets the Warm Storage service address for the current network\n   * @returns The Warm Storage service address\n   */\n  getWarmStorageAddress(): string {\n    return this._warmStorageAddress\n  }\n\n  /**\n   * Gets the Payments contract address for the current network\n   * @returns The Payments contract address\n   */\n  getPaymentsAddress(): string {\n    return this._warmStorageService.getPaymentsAddress()\n  }\n\n  /**\n   * Gets the PDPVerifier contract address for the current network\n   * @returns The PDPVerifier contract address\n   */\n  getPDPVerifierAddress(): string {\n    return this._warmStorageService.getPDPVerifierAddress()\n  }\n\n  /**\n   * Gets the payment service instance\n   * @returns The payment service\n   */\n  get payments(): PaymentsService {\n    return this._payments\n  }\n\n  /**\n   * Gets the storage manager instance\n   *\n   * @returns The storage manager for all storage operations\n   */\n  get storage(): StorageManager {\n    return this._storageManager\n  }\n\n  /**\n   * Create a storage service instance.\n   *\n   * Automatically selects the best available service provider and creates or reuses a data set.\n   *\n   * @deprecated Use synapse.storage.createContext() instead. This method will be removed in a future version.\n   * @param options - Optional storage configuration\n   * @returns A configured StorageService instance ready for uploads/downloads\n   *\n   * @example\n   * ```typescript\n   * // Basic usage - auto-selects provider\n   * const storage = await synapse.createStorage()\n   * const result = await storage.upload(data)\n   *\n   * // With specific provider\n   * const storage = await synapse.createStorage({\n   *   providerId: 123\n   * })\n   *\n   * // With CDN enabled\n   * const storage = await synapse.createStorage({\n   *   withCDN: true\n   * })\n   * ```\n   */\n  async createStorage(options: StorageServiceOptions = {}): Promise<StorageService> {\n    // Use StorageManager to create context\n    return await this._storageManager.createContext(options)\n  }\n\n  /**\n   * Download data from service providers\n   * @deprecated Use synapse.storage.download() instead. This method will be removed in a future version.\n   * @param pieceCid - The PieceCID identifier (string or PieceCID object)\n   * @param options - Download options\n   * @returns The downloaded data as Uint8Array\n   *\n   * @example\n   * ```typescript\n   * // Download by PieceCID string\n   * const data = await synapse.download('bafkzcib...')\n   *\n   * // Download from specific provider\n   * const data = await synapse.download(pieceCid, {\n   *   providerAddress: '0x123...'\n   * })\n   * ```\n   */\n  async download(\n    pieceCid: string | PieceCID,\n    options?: {\n      providerAddress?: string\n      withCDN?: boolean\n    }\n  ): Promise<Uint8Array> {\n    console.warn('synapse.download() is deprecated. Use synapse.storage.download() instead.')\n    return await this._storageManager.download(pieceCid, options)\n  }\n\n  /**\n   * Get detailed information about a specific service provider\n   * @param providerAddress - The provider's address or provider ID\n   * @returns Provider information including URLs and pricing\n   */\n  async getProviderInfo(providerAddress: string | number): Promise<ProviderInfo> {\n    try {\n      // Validate address format if string provided\n      if (typeof providerAddress === 'string') {\n        try {\n          ethers.getAddress(providerAddress) // Will throw if invalid\n        } catch {\n          throw new Error(`Invalid provider address: ${providerAddress}`)\n        }\n      }\n\n      // Create SPRegistryService\n      const registryAddress = this._warmStorageService.getServiceProviderRegistryAddress()\n      const spRegistry = new SPRegistryService(this._provider, registryAddress)\n\n      let providerInfo: ProviderInfo | null\n      if (typeof providerAddress === 'string') {\n        providerInfo = await spRegistry.getProviderByAddress(providerAddress)\n      } else {\n        providerInfo = await spRegistry.getProvider(providerAddress)\n      }\n\n      // Check if provider was found in registry\n      if (providerInfo == null) {\n        throw new Error(`Provider ${providerAddress} not found in registry`)\n      }\n\n      return providerInfo\n    } catch (error) {\n      if (error instanceof Error && error.message.includes('Invalid provider address')) {\n        throw error\n      }\n      if (error instanceof Error && error.message.includes('not found')) {\n        throw error\n      }\n      throw new Error(`Failed to get provider info: ${error instanceof Error ? error.message : String(error)}`)\n    }\n  }\n\n  /**\n   * Get comprehensive information about the storage service including\n   * approved providers, pricing, contract addresses, and current allowances\n   * @deprecated Use synapse.storage.getStorageInfo() instead. This method will be removed in a future version.\n   * @returns Complete storage service information\n   */\n  async getStorageInfo(): Promise<StorageInfo> {\n    console.warn('synapse.getStorageInfo() is deprecated. Use synapse.storage.getStorageInfo() instead.')\n    return await this._storageManager.getStorageInfo()\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 5400, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/telemetry/index.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/telemetry/index.ts"],"sourcesContent":["/**\n * Telemetry module exports\n *\n * Provides types for configuring telemetry and working with debug dumps.\n * The TelemetryService is accessed via synapse.telemetry getter.\n */\n\nexport { type DebugDump, type TelemetryConfig, TelemetryService } from './service.ts'\nexport { getGlobalTelemetry, initGlobalTelemetry } from './singleton.ts'\n"],"names":[],"mappings":";AAOA,OAAO,EAAwC,gBAAgB,EAAE,MAAM,cAAc,CAAA;AACrF,OAAO,EAAE,kBAAkB,EAAE,mBAAmB,EAAE,MAAM,gBAAgB,CAAA"}},
    {"offset": {"line": 5409, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/types.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/types.ts"],"sourcesContent":["/**\n * Synapse SDK Type Definitions\n *\n * This file contains type aliases, option objects, and data structures\n * used throughout the SDK. Concrete classes are defined in their own files.\n */\n\nimport type { PieceCID } from '@filoz/synapse-core/piece'\nimport type { ethers } from 'ethers'\nimport type { Hex } from 'viem'\nimport type { ProviderInfo } from './sp-registry/types.ts'\nimport type { TelemetryConfig } from './telemetry/service.ts'\n\n// Re-export PieceCID and ProviderInfo types\nexport type { PieceCID, ProviderInfo }\nexport type PrivateKey = string\nexport type Address = string\nexport type TokenAmount = number | bigint\nexport type DataSetId = string\nexport type ServiceProvider = string\n\n/**\n * Supported Filecoin network types\n */\nexport type FilecoinNetworkType = 'mainnet' | 'calibration'\n\n/**\n * Token identifier for balance queries\n */\nexport type TokenIdentifier = 'USDFC' | string\n\n/**\n * Options for initializing the Synapse instance\n * Must provide one of:\n * 1. privateKey + rpcURL (for server environments)\n * 2. provider (for browser environments - user handles MetaMask coupling)\n * 3. signer (for direct ethers.js integration)\n */\nexport interface SynapseOptions {\n  // Wallet Configuration (exactly one required)\n\n  /** Private key for signing transactions (requires rpcURL) */\n  privateKey?: PrivateKey\n  /** Ethers Provider instance (handles both reads and transactions) */\n  provider?: ethers.Provider\n  /** Ethers Signer instance (for direct ethers.js integration) */\n  signer?: ethers.Signer\n\n  // Network Configuration\n\n  /** RPC URL for Filecoin node (required with privateKey) */\n  rpcURL?: string\n  /** Authorization header value for API authentication (e.g., Bearer token) */\n  authorization?: string\n\n  // Advanced Configuration\n\n  /** Whether to use CDN for retrievals (default: false) */\n  withCDN?: boolean\n  /** Whether to filter providers by IPNI availability */\n  withIpni?: boolean\n  /** Whether to include providers with serviceStatus=dev in the capabilities list (default: false) */\n  dev?: boolean\n  /** Optional override for piece retrieval */\n  pieceRetriever?: PieceRetriever\n  /** Whether to disable NonceManager for automatic nonce management (default: false, meaning NonceManager is used) */\n  disableNonceManager?: boolean\n  /** Override Warm Storage service contract address (defaults to network's default) */\n  warmStorageAddress?: string\n  // Subgraph Integration (provide ONE of these options)\n  /** Optional override for default subgraph service, to enable subgraph-based retrieval. */\n  subgraphService?: SubgraphRetrievalService\n  /** Optional configuration for the default subgraph service, to enable subgraph-based retrieval. */\n  subgraphConfig?: SubgraphConfig\n\n  // Telemetry Configuration\n  /** Telemetry configuration for error tracking and debugging (enabled by default) */\n  telemetry?: TelemetryConfig\n}\n\n/**\n * Storage service options\n */\nexport interface StorageOptions {\n  /** Existing data set ID to use (optional) */\n  dataSetId?: DataSetId\n  /** Preferred service provider (optional) */\n  serviceProvider?: ServiceProvider\n}\n\n/**\n * Upload task tracking\n */\nexport interface UploadTask {\n  /** Get the PieceCID (Piece CID) once calculated */\n  pieceCid: () => Promise<PieceCID>\n  /** Get the service provider once data is stored */\n  store: () => Promise<ServiceProvider>\n  /** Wait for the entire upload process to complete, returns transaction hash */\n  done: () => Promise<string>\n}\n\n/**\n * Download options\n * Currently empty, reserved for future options\n */\n\n// biome-ignore lint/complexity/noBannedTypes: future proofing\nexport type DownloadOptions = {}\n\n/**\n * PieceRetriever interface for fetching pieces from various sources\n * Returns standard Web API Response objects for flexibility\n */\nexport interface PieceRetriever {\n  /**\n   * Fetch a piece from available sources\n   * @param pieceCid - The PieceCID identifier of the piece (validated internally)\n   * @param client - The client address requesting the piece\n   * @param options - Optional retrieval parameters\n   * @returns A Response object that can be processed for the piece data\n   */\n  fetchPiece: (\n    pieceCid: PieceCID, // Internal interface uses PieceCID type for validation\n    client: string,\n    options?: {\n      providerAddress?: string // Restrict to specific provider\n      withCDN?: boolean // Enable CDN retrieval attempts\n      signal?: AbortSignal // Optional AbortSignal for request cancellation\n    }\n  ) => Promise<Response>\n}\n\n/**\n * Configuration for the SubgraphService, determining how to connect to a\n * Synapse-compatible subgraph for provider discovery.\n */\nexport interface SubgraphConfig {\n  /** Direct GraphQL endpoint URL. Takes precedence if provided. */\n  endpoint?: string\n  /** Configuration for Goldsky subgraphs. Used if 'endpoint' is not provided. */\n  goldsky?: {\n    projectId: string\n    subgraphName: string\n    version: string\n  }\n  /** Optional API key for authenticated subgraph access */\n  apiKey?: string\n}\n\n/**\n * Defines the contract for a service that can retrieve provider information from a data source,\n * typically a Synapse-compatible subgraph.\n *\n * This interface allows for custom implementations to be provided in place of the default\n * SubgraphService. Any service that implements this interface can be used with the\n * Synapse SDK by passing it via the `subgraphService` option when creating a Synapse instance.\n *\n * This enables integration with alternative data sources or custom implementations\n * while maintaining compatibility with the SDK's retrieval system.\n */\nexport interface SubgraphRetrievalService {\n  /**\n   * Finds providers that have registered a specific data segment (PieceCID).\n   *\n   * @param pieceCid - The PieceCID of the data segment.\n   * @returns A promise that resolves to an array of `ProviderInfo` objects.\n   */\n  getApprovedProvidersForPieceCID: (pieceCid: PieceCID) => Promise<ProviderInfo[]>\n\n  /**\n   * Retrieves details for a specific provider by their address.\n   *\n   * @param address - The unique address (ID) of the provider.\n   * @returns A promise that resolves to `ProviderInfo` if found, otherwise `null`.\n   */\n  getProviderByAddress: (address: string) => Promise<ProviderInfo | null>\n}\n\n/**\n * Signature data for authenticated operations\n */\nexport interface AuthSignature {\n  /** The full signature string (0x-prefixed) */\n  signature: string\n  /** Recovery parameter */\n  v: number\n  /** R component of signature */\n  r: string\n  /** S component of signature */\n  s: string\n  /** The ABI-encoded data that was signed (for verification) */\n  signedData: string\n}\n\n/**\n * Data set information returned from Warm Storage contract\n */\nexport interface DataSetInfo {\n  /** ID of the PDP payment rail */\n  pdpRailId: number\n  /** For CDN add-on: ID of the cache miss payment rail */\n  cacheMissRailId: number\n  /** For CDN add-on: ID of the CDN payment rail */\n  cdnRailId: number\n  /** Address paying for storage */\n  payer: string\n  /** SP's beneficiary address */\n  payee: string\n  /** Service provider address (operator) */\n  serviceProvider: string\n  /** Commission rate in basis points (dynamic based on CDN usage) */\n  commissionBps: number\n  /** Client's sequential dataset ID within this Warm Storage contract */\n  clientDataSetId: bigint\n  /** Epoch when PDP payments end (0 if not terminated) */\n  pdpEndEpoch: number\n  /** Provider ID from the ServiceProviderRegistry */\n  providerId: number\n  // Legacy alias for backward compatibility\n  paymentEndEpoch?: number\n  /** PDP Data Set ID */\n  dataSetId: bigint | number\n}\n\n/**\n * Enhanced data set information with chain details and clear ID separation\n */\nexport interface EnhancedDataSetInfo extends DataSetInfo {\n  /** PDPVerifier global data set ID */\n  pdpVerifierDataSetId: number\n  /** Next piece ID to use when adding pieces */\n  nextPieceId: number\n  /** Current number of pieces in the data set */\n  currentPieceCount: number\n  /** Whether the data set is live on-chain */\n  isLive: boolean\n  /** Whether this data set is managed by the current Warm Storage contract */\n  isManaged: boolean\n  /** Whether the data set is using CDN (derived from cdnRailId > 0) */\n  withCDN: boolean\n  /** Metadata associated with this data set (key-value pairs) */\n  metadata: Record<string, string>\n}\n\n/**\n * Information about a payment rail\n */\nexport interface RailInfo {\n  /** Rail ID */\n  railId: number\n  /** Whether the rail is terminated */\n  isTerminated: boolean\n  /** End epoch (0 if not terminated) */\n  endEpoch: number\n}\n\n/**\n * Settlement result from settling a payment rail\n */\nexport interface SettlementResult {\n  /** Total amount that was settled */\n  totalSettledAmount: bigint\n  /** Net amount sent to payee after commission */\n  totalNetPayeeAmount: bigint\n  /** Commission amount for operator */\n  totalOperatorCommission: bigint\n  /** Payments contract network fee */\n  totalNetworkFee: bigint\n  /** Final epoch that was settled */\n  finalSettledEpoch: bigint\n  /** Note about the settlement */\n  note: string\n}\n\n// ============================================================================\n// Storage Context Creation Types\n// ============================================================================\n// These types are used when creating or selecting storage contexts\n// (provider + data set pairs)\n// ============================================================================\n\n/**\n * Callbacks for storage service creation process\n *\n * These callbacks provide visibility into the context creation process,\n * including provider and data set selection.\n */\nexport interface StorageContextCallbacks {\n  /**\n   * Called when a service provider has been selected\n   * @param provider - The selected provider info\n   */\n  onProviderSelected?: (provider: ProviderInfo) => void\n\n  /**\n   * Called when data set resolution is complete\n   * @param info - Information about the resolved data set\n   */\n  onDataSetResolved?: (info: { isExisting: boolean; dataSetId: number; provider: ProviderInfo }) => void\n}\n\nexport interface CreateContextsOptions {\n  /** Number of contexts to create (optional, defaults to 2) */\n  count?: number\n  /**\n   * Specific data set IDs to use\n   */\n  dataSetIds?: number[]\n  /**\n   * Specific provider IDs to use\n   */\n  providerIds?: number[]\n  /** Do not select any of these providers */\n  excludeProviderIds?: number[]\n  /** Whether to enable CDN services */\n  withCDN?: boolean\n  withIpni?: boolean\n  dev?: boolean\n  /**\n   * Custom metadata for the data sets (key-value pairs)\n   * When smart-selecting data sets, this metadata will be used to match.\n   */\n  metadata?: Record<string, string>\n  /** Create new data sets, even if candidates exist */\n  forceCreateDataSets?: boolean\n  /** Callbacks for creation process (will need to change to handle multiples) */\n  callbacks?: StorageContextCallbacks\n  /** Maximum number of uploads to process in a single batch (default: 32, minimum: 1) */\n  uploadBatchSize?: number\n}\n\n/**\n * Options for creating or selecting a storage context\n *\n * Used by StorageManager.createContext() and indirectly by StorageManager.upload()\n * when auto-creating contexts. Allows specification of:\n * - Provider selection (by ID or address)\n * - Data set selection or creation\n * - CDN enablement and metadata\n * - Creation process callbacks\n */\nexport interface StorageServiceOptions {\n  /** Specific provider ID to use (optional) */\n  providerId?: number\n  /** Do not select any of these providers */\n  excludeProviderIds?: number[]\n  /** Specific provider address to use (optional) */\n  providerAddress?: string\n  /** Specific data set ID to use (optional) */\n  dataSetId?: number\n  /** Whether to enable CDN services */\n  withCDN?: boolean\n  withIpni?: boolean\n  /** Whether to include providers with serviceStatus=dev in the capabilities list (default: false) */\n  dev?: boolean\n  /** Force creation of a new data set, even if a candidate exists */\n  forceCreateDataSet?: boolean\n  /** Maximum number of uploads to process in a single batch (default: 32, minimum: 1) */\n  uploadBatchSize?: number\n  /** Callbacks for creation process */\n  callbacks?: StorageContextCallbacks\n  /** Custom metadata for the data set (key-value pairs) */\n  metadata?: Record<string, string>\n}\n\n/**\n * Preflight information for storage uploads\n */\nexport interface PreflightInfo {\n  /** Estimated storage costs */\n  estimatedCost: {\n    perEpoch: bigint\n    perDay: bigint\n    perMonth: bigint\n  }\n  /** Allowance check results */\n  allowanceCheck: {\n    sufficient: boolean\n    message?: string\n  }\n  /** Selected service provider (null when no specific provider selected) */\n  selectedProvider: ProviderInfo | null\n  /** Selected data set ID (null when no specific dataset selected) */\n  selectedDataSetId: number | null\n}\n\n// ============================================================================\n// Upload Types\n// ============================================================================\n// The SDK provides different upload options for different use cases:\n//\n// 1. UploadCallbacks - Progress callbacks only (used by all upload methods)\n// 2. UploadOptions - For StorageContext.upload() (adds piece metadata)\n// 3. StorageManagerUploadOptions - For StorageManager.upload() (internal type\n//    that combines context creation + upload in one call)\n// ============================================================================\n\n/**\n * Callbacks for tracking upload progress\n *\n * These callbacks provide visibility into the upload process stages:\n * 1. Upload completion (piece uploaded to provider)\n * 2. Piece addition (transaction submitted to chain)\n * 3. Confirmation (transaction confirmed on-chain)\n */\nexport interface UploadCallbacks {\n  /** Called periodically during upload with bytes uploaded so far */\n  onProgress?: (bytesUploaded: number) => void\n  /** Called when upload to service provider completes */\n  onUploadComplete?: (pieceCid: PieceCID) => void\n  /** Called when the service provider has added the piece and submitted the transaction to the chain */\n  onPieceAdded?: (transaction?: Hex) => void\n  /** Called when the service provider agrees that the piece addition is confirmed on-chain */\n  onPieceConfirmed?: (pieceIds: number[]) => void\n}\n\n/**\n * Options for uploading individual pieces to an existing storage context\n *\n * Used by StorageContext.upload() for uploading data to a specific provider\n * and data set that has already been created/selected.\n */\nexport interface UploadOptions extends UploadCallbacks {\n  /** Custom metadata for this specific piece (key-value pairs) */\n  metadata?: Record<string, string>\n  /** Optional pre-calculated PieceCID to skip CommP calculation (BYO PieceCID) */\n  pieceCid?: PieceCID\n  /** Optional AbortSignal to cancel the upload */\n  signal?: AbortSignal\n}\n\n/**\n * Upload result information\n */\nexport interface UploadResult {\n  /** PieceCID of the uploaded data */\n  pieceCid: PieceCID\n  /** Size of the original data */\n  size: number\n  /** Piece ID in the data set */\n  pieceId?: number\n}\n\n/**\n * Comprehensive storage service information\n */\nexport interface StorageInfo {\n  /** Pricing information for storage services */\n  pricing: {\n    /** Pricing without CDN */\n    noCDN: {\n      /** Cost per TiB per month in token units */\n      perTiBPerMonth: bigint\n      /** Cost per TiB per day in token units */\n      perTiBPerDay: bigint\n      /** Cost per TiB per epoch in token units */\n      perTiBPerEpoch: bigint\n    }\n    /** Pricing with CDN enabled */\n    withCDN: {\n      /** Cost per TiB per month in token units */\n      perTiBPerMonth: bigint\n      /** Cost per TiB per day in token units */\n      perTiBPerDay: bigint\n      /** Cost per TiB per epoch in token units */\n      perTiBPerEpoch: bigint\n    }\n    /** Token contract address */\n    tokenAddress: string\n    /** Token symbol (always USDFC for now) */\n    tokenSymbol: string\n  }\n\n  /** List of approved service providers */\n  providers: ProviderInfo[]\n\n  /** Service configuration parameters */\n  serviceParameters: {\n    /** Network type (mainnet or calibration) */\n    network: FilecoinNetworkType\n    /** Number of epochs in a month */\n    epochsPerMonth: bigint\n    /** Number of epochs in a day */\n    epochsPerDay: bigint\n    /** Duration of each epoch in seconds */\n    epochDuration: number\n    /** Minimum allowed upload size in bytes */\n    minUploadSize: number\n    /** Maximum allowed upload size in bytes */\n    maxUploadSize: number\n    /** Warm Storage service contract address */\n    warmStorageAddress: string\n    /** Payments contract address */\n    paymentsAddress: string\n    /** PDP Verifier contract address */\n    pdpVerifierAddress: string\n  }\n\n  /** Current user allowances (null if wallet not connected) */\n  allowances: {\n    /** Whether the service operator is approved to act on behalf of the wallet */\n    isApproved: boolean\n    /** Service contract address */\n    service: string\n    /** Maximum payment rate per epoch allowed */\n    rateAllowance: bigint\n    /** Maximum lockup amount allowed */\n    lockupAllowance: bigint\n    /** Current rate allowance used */\n    rateUsed: bigint\n    /** Current lockup allowance used */\n    lockupUsed: bigint\n  } | null\n}\n\n/**\n * Data set data returned from the API\n */\nexport interface DataSetData {\n  /** The data set ID */\n  id: number\n  /** Array of piece data in the data set */\n  pieces: DataSetPieceData[]\n  /** Next challenge epoch */\n  nextChallengeEpoch: number\n}\n\n/**\n * Individual data set piece data from API\n */\nexport interface DataSetPieceData {\n  /** Piece ID within the data set */\n  pieceId: number\n  /** The piece CID */\n  pieceCid: PieceCID\n  /** Sub-piece CID (usually same as pieceCid) */\n  subPieceCid: PieceCID\n  /** Sub-piece offset */\n  subPieceOffset: number\n}\n\n/**\n * Status information for a piece stored on a provider\n * Note: Proofs are submitted for entire data sets, not individual pieces.\n * The timing information reflects the data set's status.\n */\nexport interface PieceStatus {\n  /** Whether the piece exists on the service provider */\n  exists: boolean\n  /** When the data set containing this piece was last proven on-chain (null if never proven or not yet due) */\n  dataSetLastProven: Date | null\n  /** When the next proof is due for the data set containing this piece (end of challenge window) */\n  dataSetNextProofDue: Date | null\n  /** URL where the piece can be retrieved (null if not available) */\n  retrievalUrl: string | null\n  /** The piece ID if the piece is in the data set */\n  pieceId?: number\n  /** Whether the data set is currently in a challenge window */\n  inChallengeWindow?: boolean\n  /** Time until the data set enters the challenge window (in hours) */\n  hoursUntilChallengeWindow?: number\n  /** Whether the proof is overdue (past the challenge window without being submitted) */\n  isProofOverdue?: boolean\n}\n\n/**\n * Result of provider selection and data set resolution\n */\nexport interface ProviderSelectionResult {\n  /** Selected service provider */\n  provider: ProviderInfo\n  /** Selected data set ID */\n  dataSetId: number\n  /** Whether this is an existing data set */\n  isExisting?: boolean\n  /** Data set metadata */\n  dataSetMetadata: Record<string, string>\n}\n\nexport type MetadataEntry = {\n  key: string\n  value: string\n}\n"],"names":[],"mappings":""}},
    {"offset": {"line": 5416, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/node_modules/@filoz/synapse-sdk/dist/src/index.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/node_modules/%40filoz/synapse-sdk/src/index.ts"],"sourcesContent":["/**\n * Synapse SDK - Main entry point\n *\n * @example\n * ```ts\n * import { Synapse } from '@filoz/synapse-sdk'\n * ```\n *\n * @packageDocumentation\n * @module Synapse\n */\n\n/**\n * Synapse SDK main entry point\n */\n\nexport * from './payments/index.ts'\nexport * from './pdp/index.ts'\nexport * from './session/index.ts'\nexport * from './storage/index.ts'\nexport * from './subgraph/index.ts'\nexport { Synapse } from './synapse.ts'\nexport * from './telemetry/index.ts'\nexport * from './types.ts'\nexport * from './utils/index.ts'\nexport * from './warm-storage/index.ts'\n"],"names":[],"mappings":";AAgBA,cAAc,qBAAqB,CAAA;AACnC,cAAc,gBAAgB,CAAA;AAC9B,cAAc,oBAAoB,CAAA;AAClC,cAAc,oBAAoB,CAAA;AAClC,cAAc,qBAAqB,CAAA;AACnC,OAAO,EAAE,OAAO,EAAE,MAAM,cAAc,CAAA;AACtC,cAAc,sBAAsB,CAAA;AACpC,cAAc,YAAY,CAAA;AAC1B,cAAc,kBAAkB,CAAA;AAChC,cAAc,yBAAyB,CAAA"}}]
}