{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 40, "column": 0}, "map": {"version":3,"sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-current/lib/llm-service.ts"],"sourcesContent":["/**\n * LLM Service for PoX Dashboard\n * Integrates OpenAI API with domain-specific context\n */\n\nimport OpenAI from 'openai';\nimport type { Stream } from 'openai/streaming';\n\n// Lazy initialization to avoid errors if API key is missing\nlet openai: OpenAI | null = null;\n\nfunction getOpenAI(): OpenAI {\n  if (!openai) {\n    const apiKey = process.env.OPENAI_API_KEY;\n    if (!apiKey) {\n      throw new Error(\n        'OPENAI_API_KEY is not set. Please add it to your .env.local file. ' +\n        'Get your API key from: https://platform.openai.com/api-keys'\n      );\n    }\n    openai = new OpenAI({ apiKey });\n  }\n  return openai;\n}\n\n// System prompt with PoX domain knowledge\nconst SYSTEM_PROMPT = `You are the ChimiaDAO Assistant, an AI specialized in helping scientists query and understand decentralized scientific data from the PoX (Proof-of-X) network.\n\n**Context:**\n- PoX is a blockchain-based reputation system for scientific experiments\n- Experiments (HPLC, Air Quality, NMR) are stored on Filecoin with hashes on-chain\n- The Graph indexes experiment metadata for fast queries\n- Users can have private local data AND public on-chain data\n\n**Your Capabilities:**\n1. Query The Graph subgraph for experiment metadata\n2. Explain blockchain concepts (CIDs, hashes, reputation scores)\n3. Help interpret HPLC chromatograms and scientific data\n4. Provide information about Filecoin storage deals\n5. Answer questions about the PoX protocol and fraud proofs\n\n**Tone:**\n- Precise and scientific, but approachable\n- Use technical terms when appropriate, but explain them\n- Format numbers with proper units (mAU, ppb, μg/m³)\n- Reference blockchain data when available (CIDs, addresses, block numbers)\n\n**Data Access:**\n- You receive real-time context about experiments from The Graph\n- CIDs are Filecoin piece CIDs (bafkzcib... format)\n- Difficulty scores: HPLC (7-14), Air Quality (15-24), NMR (25-70)\n- Reputation decays over time (λ=0.01/day)\n\n**Response Format:**\n- Keep responses concise (2-3 paragraphs max)\n- Use code formatting for CIDs, hashes, addresses\n- Provide specific data when available (don't be vague)\n- If data is missing, say so clearly\n\nRemember: You're helping scientists verify and understand their decentralized lab notebook.`;\n\nexport type Message = {\n  role: 'system' | 'user' | 'assistant';\n  content: string;\n};\n\nexport type ChatOptions = {\n  model?: string;\n  temperature?: number;\n  maxTokens?: number;\n  stream?: boolean;\n};\n\n/**\n * Query LLM with PoX-specific context\n * \n * @param messages - Conversation history\n * @param graphContext - Real-time data from The Graph\n * @param options - LLM configuration\n * @returns Response string or stream\n */\nexport async function queryLLM(\n  messages: Message[],\n  graphContext?: any,\n  options: ChatOptions = {}\n): Promise<string | Stream<OpenAI.Chat.Completions.ChatCompletionChunk>> {\n  const client = getOpenAI();\n  \n  const {\n    model = process.env.OPENAI_MODEL || 'gpt-4o-mini',\n    temperature = 0.7,\n    maxTokens = 500,\n    stream = false,\n  } = options;\n\n  // Inject Graph context into system message if available\n  let systemMessage = SYSTEM_PROMPT;\n  if (graphContext) {\n    systemMessage += `\\n\\n**Current Context:**\\n${formatGraphContext(graphContext)}`;\n  }\n\n  const fullMessages: OpenAI.Chat.Completions.ChatCompletionMessageParam[] = [\n    { role: 'system', content: systemMessage },\n    ...messages.map(m => ({\n      role: m.role as 'system' | 'user' | 'assistant',\n      content: m.content,\n    })),\n  ];\n\n  try {\n    const response = await client.chat.completions.create({\n      model,\n      messages: fullMessages,\n      temperature,\n      max_tokens: maxTokens,\n      stream,\n    });\n\n    if (stream) {\n      return response as Stream<OpenAI.Chat.Completions.ChatCompletionChunk>;\n    }\n\n    // Non-streaming response\n    const completion = response as OpenAI.Chat.Completions.ChatCompletion;\n    return completion.choices[0]?.message?.content || 'No response generated.';\n    \n  } catch (error: any) {\n    console.error('[LLM] Query failed:', error.message);\n    \n    // User-friendly error messages\n    if (error.status === 401) {\n      throw new Error('Invalid OpenAI API key. Please check your .env.local file.');\n    }\n    if (error.status === 429) {\n      throw new Error('OpenAI rate limit exceeded. Please try again in a moment.');\n    }\n    if (error.status === 500) {\n      throw new Error('OpenAI service error. Please try again later.');\n    }\n    \n    throw new Error(`LLM query failed: ${error.message}`);\n  }\n}\n\n/**\n * Format Graph context for LLM injection\n */\nfunction formatGraphContext(context: any): string {\n  const parts: string[] = [];\n  \n  if (context.experiments && Array.isArray(context.experiments)) {\n    parts.push(`**Recent Experiments (${context.experiments.length}):**`);\n    context.experiments.slice(0, 5).forEach((exp: any, i: number) => {\n      parts.push(\n        `${i + 1}. ${exp.sampleId || exp.id} - ` +\n        `Type: ${exp.type}, Difficulty: ${exp.difficulty}, ` +\n        `CID: ${exp.cid?.slice(0, 20)}...`\n      );\n    });\n  }\n  \n  if (context.stats) {\n    parts.push(`\\n**Network Stats:**`);\n    parts.push(`Total experiments: ${context.stats.totalExperiments || 0}`);\n    parts.push(`HPLC: ${context.stats.hplcCount || 0}, Air Quality: ${context.stats.airQualityCount || 0}, NMR: ${context.stats.nmrCount || 0}`);\n  }\n  \n  if (context.hplc) {\n    parts.push(`\\n**Active HPLC Data:**`);\n    parts.push(`Sample: ${context.hplc.sampleId}`);\n    parts.push(`Method: ${context.hplc.method}`);\n    parts.push(`Status: ${context.hplc.metrics?.status || 'Unknown'}`);\n  }\n  \n  return parts.join('\\n');\n}\n\n/**\n * Validate OpenAI API key is configured\n */\nexport function isLLMConfigured(): boolean {\n  return !!process.env.OPENAI_API_KEY;\n}\n\n/**\n * Get current model name\n */\nexport function getModelName(): string {\n  return process.env.OPENAI_MODEL || 'gpt-4o-mini';\n}\n\n/**\n * Stream-to-string helper for server-side use\n */\nexport async function streamToString(\n  stream: Stream<OpenAI.Chat.Completions.ChatCompletionChunk>\n): Promise<string> {\n  const chunks: string[] = [];\n  \n  for await (const chunk of stream) {\n    const content = chunk.choices[0]?.delta?.content;\n    if (content) {\n      chunks.push(content);\n    }\n  }\n  \n  return chunks.join('');\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 261, "column": 0}, "map": {"version":3,"sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-current/lib/validation.ts"],"sourcesContent":["/**\n * Validation utilities for PoX dashboard\n * Ensures data integrity and prevents injection attacks\n */\n\nimport { z } from 'zod';\n\n// --- CID Validation ---\n// Filecoin piece CIDs: bafkzcib... (longer than regular CIDs)\n// Regular CIDs: bafk... (CIDv1) or Qm... (CIDv0)\nconst PIECE_CID_REGEX = /^bafkzcib[a-z2-7]{100,}$/i; // Filecoin piece CIDs (commp)\nconst CID_V1_REGEX = /^bafk[a-z2-7]{49,}$/i;\nconst CID_V0_REGEX = /^Qm[1-9A-HJ-NP-Za-km-z]{44}$/;\n\nexport const cidSchema = z.string().refine(\n  (val) => PIECE_CID_REGEX.test(val) || CID_V1_REGEX.test(val) || CID_V0_REGEX.test(val),\n  { message: 'Invalid CID format. Expected CIDv0 (Qm...), CIDv1 (bafk...), or Filecoin piece CID (bafkzcib...)' }\n);\n\nexport function isValidCID(cid: string): boolean {\n  return cidSchema.safeParse(cid).success;\n}\n\n// --- Hash Validation ---\n// Ethereum hashes: 0x followed by 64 hex characters\nexport const hashSchema = z.string().regex(\n  /^0x[a-fA-F0-9]{64}$/,\n  'Invalid hash format. Expected 0x followed by 64 hex characters'\n);\n\nexport function isValidHash(hash: string): boolean {\n  return hashSchema.safeParse(hash).success;\n}\n\n// --- Address Validation ---\n// Ethereum address: 0x followed by 40 hex characters\nexport const addressSchema = z.string().regex(\n  /^0x[a-fA-F0-9]{40}$/,\n  'Invalid address format. Expected 0x followed by 40 hex characters'\n);\n\nexport function isValidAddress(address: string): boolean {\n  return addressSchema.safeParse(address).success;\n}\n\n// --- Experiment ID Validation ---\nexport const experimentIdSchema = z.number().int().nonnegative();\n\nexport function isValidExperimentId(id: number): boolean {\n  return experimentIdSchema.safeParse(id).success;\n}\n\n// --- Difficulty Score Validation ---\n// Based on PoX scoring system: 7-70 (HPLC: 7-14, Air: 15-24, NMR: 25-70)\nexport const difficultySchema = z.number().min(0).max(100);\n\nexport function isValidDifficulty(difficulty: number): boolean {\n  return difficultySchema.safeParse(difficulty).success;\n}\n\n// --- Timestamp Validation ---\n// Unix timestamp in seconds (not milliseconds)\nconst GENESIS_TIMESTAMP = 1609459200; // 2021-01-01 (reasonable min for blockchain)\nconst MAX_FUTURE_TIMESTAMP = Math.floor(Date.now() / 1000) + 86400; // 1 day future tolerance\n\nexport const timestampSchema = z.number().int()\n  .min(GENESIS_TIMESTAMP, 'Timestamp too far in the past')\n  .max(MAX_FUTURE_TIMESTAMP, 'Timestamp too far in the future');\n\nexport function isValidTimestamp(timestamp: number): boolean {\n  return timestampSchema.safeParse(timestamp).success;\n}\n\n// --- API Request Validation ---\nexport const challengeRequestSchema = z.object({\n  experimentId: experimentIdSchema,\n  computedMetricsHash: hashSchema,\n});\n\nexport type ChallengeRequest = z.infer<typeof challengeRequestSchema>;\n\n// --- Experiment Data Validation ---\nexport const onChainExperimentSchema = z.object({\n  id: experimentIdSchema,\n  submitter: addressSchema,\n  cid: cidSchema,\n  dataHash: hashSchema,\n  metricsHash: hashSchema,\n  difficulty: difficultySchema,\n  initialRV: z.number(),\n  submittedAt: timestampSchema,\n  blockExplorer: z.string().url().optional(),\n});\n\nexport type ValidatedExperiment = z.infer<typeof onChainExperimentSchema>;\n\n// --- Sanitization ---\n/**\n * Sanitize user input to prevent XSS\n * Removes script tags, event handlers, and dangerous HTML\n */\nexport function sanitizeInput(input: string): string {\n  return input\n    .replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '')\n    .replace(/on\\w+=\"[^\"]*\"/gi, '')\n    .replace(/on\\w+='[^']*'/gi, '')\n    .replace(/javascript:/gi, '')\n    .trim();\n}\n\n/**\n * Validate and sanitize CID before using in downloads\n */\nexport function validateAndSanitizeCID(cid: unknown): string {\n  if (typeof cid !== 'string') {\n    throw new Error('CID must be a string');\n  }\n  \n  const sanitized = sanitizeInput(cid);\n  \n  if (!isValidCID(sanitized)) {\n    throw new Error(`Invalid CID format: ${sanitized}`);\n  }\n  \n  return sanitized;\n}\n\n/**\n * Validate hash before using in challenges or comparisons\n */\nexport function validateHash(hash: unknown): string {\n  if (typeof hash !== 'string') {\n    throw new Error('Hash must be a string');\n  }\n  \n  const sanitized = sanitizeInput(hash);\n  \n  if (!isValidHash(sanitized)) {\n    throw new Error(`Invalid hash format: ${sanitized}`);\n  }\n  \n  return sanitized;\n}\n\n/**\n * Validate experiment data from blockchain\n * Throws if invalid, returns typed data if valid\n */\nexport function validateExperimentData(data: unknown): ValidatedExperiment {\n  try {\n    return onChainExperimentSchema.parse(data);\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      const issues = error.issues.map(i => `${i.path.join('.')}: ${i.message}`).join(', ');\n      throw new Error(`Invalid experiment data: ${issues}`);\n    }\n    throw error;\n  }\n}\n\n// --- Rate Limiting Helpers ---\nconst rateLimitStore = new Map<string, { count: number; resetAt: number }>();\n\n/**\n * Simple in-memory rate limiter\n * @param key - Identifier (IP, user, etc.)\n * @param limit - Max requests per window\n * @param windowMs - Time window in milliseconds\n */\nexport function checkRateLimit(key: string, limit: number, windowMs: number): boolean {\n  const now = Date.now();\n  const record = rateLimitStore.get(key);\n  \n  if (!record || now > record.resetAt) {\n    rateLimitStore.set(key, { count: 1, resetAt: now + windowMs });\n    return true;\n  }\n  \n  if (record.count >= limit) {\n    return false;\n  }\n  \n  record.count++;\n  return true;\n}\n\n/**\n * Clear rate limit for a key (useful for testing)\n */\nexport function clearRateLimit(key: string): void {\n  rateLimitStore.delete(key);\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 418, "column": 0}, "map": {"version":3,"sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-current/lib/web3-service.ts"],"sourcesContent":["import { ethers } from 'ethers';\nimport { validateExperimentData, isValidAddress, isValidCID } from './validation';\n\n// Contract addresses from deployment\nconst REGISTRY_ADDRESS = '0xA6Fa61924F06DB9A84B92182B69F5C08F3176554';\nconst RPC_URL = 'https://api.calibration.node.glif.io/rpc/v1';\n\n// Circuit breaker configuration\nlet failureCount = 0;\nlet circuitOpen = false;\nlet lastFailureTime = 0;\nconst MAX_FAILURES = 5;\nconst CIRCUIT_RESET_TIME = 60000; // 1 minute\n\n// Minimal ABI - just the functions we need\nconst REGISTRY_ABI = [\n  'function totalExperiments() view returns (uint256)',\n  'function getExperiment(uint256) view returns (uint256 id, address submitter, string cid, bytes32 dataHash, bytes32 metricsHash, uint256 difficulty, int256 initialRV, uint64 submittedAt)',\n];\n\nexport type OnChainExperiment = {\n  id: number;\n  submitter: string;\n  cid: string;\n  dataHash: string;\n  metricsHash: string;\n  difficulty: number;\n  initialRV: number;\n  submittedAt: number;\n  blockExplorer: string;\n};\n\nlet provider: ethers.JsonRpcProvider | null = null;\nlet registry: ethers.Contract | null = null;\n\n/**\n * Circuit breaker check - prevents hammering failed RPC\n */\nfunction checkCircuitBreaker(): void {\n  if (circuitOpen) {\n    const now = Date.now();\n    if (now - lastFailureTime > CIRCUIT_RESET_TIME) {\n      console.log('[Web3] Circuit breaker reset');\n      circuitOpen = false;\n      failureCount = 0;\n    } else {\n      throw new Error('Circuit breaker is open. RPC unavailable. Try again later.');\n    }\n  }\n}\n\n/**\n * Record failure for circuit breaker\n */\nfunction recordFailure(): void {\n  failureCount++;\n  lastFailureTime = Date.now();\n  \n  if (failureCount >= MAX_FAILURES) {\n    console.error(`[Web3] Circuit breaker triggered after ${MAX_FAILURES} failures`);\n    circuitOpen = true;\n  }\n}\n\n/**\n * Record success for circuit breaker\n */\nfunction recordSuccess(): void {\n  failureCount = 0;\n}\n\nfunction getContract() {\n  checkCircuitBreaker();\n  \n  if (!provider) {\n    provider = new ethers.JsonRpcProvider(RPC_URL, undefined, {\n      staticNetwork: true, // Optimize for read-only\n    });\n  }\n  if (!registry) {\n    registry = new ethers.Contract(REGISTRY_ADDRESS, REGISTRY_ABI, provider);\n  }\n  return registry;\n}\n\nexport async function fetchTotalExperiments(): Promise<number> {\n  try {\n    const contract = getContract();\n    const total = await contract.totalExperiments();\n    return Number(total);\n  } catch (error) {\n    console.error('Failed to fetch total experiments:', error);\n    return 0;\n  }\n}\n\nexport async function fetchExperiment(id: number): Promise<OnChainExperiment | null> {\n  try {\n    const contract = getContract();\n    const [\n      expId,\n      submitter,\n      cid,\n      dataHash,\n      metricsHash,\n      difficulty,\n      initialRV,\n      submittedAt,\n    ] = await contract.getExperiment(id);\n\n    const experiment = {\n      id: Number(expId),\n      submitter,\n      cid,\n      dataHash,\n      metricsHash,\n      difficulty: Number(difficulty),\n      initialRV: Number(initialRV),\n      submittedAt: Number(submittedAt),\n      blockExplorer: `https://calibration.filscan.io/address/${REGISTRY_ADDRESS}`,\n    };\n\n    // Validate experiment data\n    try {\n      validateExperimentData(experiment);\n    } catch (validationError: any) {\n      console.warn(`[Web3] Experiment ${id} failed validation:`, validationError.message);\n      // Return data anyway but log warning - blockchain is source of truth\n    }\n\n    recordSuccess(); // Circuit breaker: record successful call\n    return experiment;\n    \n  } catch (error: any) {\n    recordFailure(); // Circuit breaker: record failure\n    console.error(`[Web3] Failed to fetch experiment ${id}:`, error.message);\n    return null;\n  }\n}\n\nexport async function fetchAllExperiments(): Promise<OnChainExperiment[]> {\n  try {\n    const total = await fetchTotalExperiments();\n    if (total === 0) return [];\n\n    const promises = [];\n    for (let i = 0; i < total; i++) {\n      promises.push(fetchExperiment(i));\n    }\n\n    const results = await Promise.all(promises);\n    return results.filter((exp): exp is OnChainExperiment => exp !== null);\n  } catch (error) {\n    console.error('Failed to fetch all experiments:', error);\n    return [];\n  }\n}\n\nexport async function fetchLatestExperiments(count: number = 5): Promise<OnChainExperiment[]> {\n  try {\n    const total = await fetchTotalExperiments();\n    if (total === 0) return [];\n\n    const startId = Math.max(0, total - count);\n    const promises = [];\n    \n    for (let i = total - 1; i >= startId; i--) {\n      promises.push(fetchExperiment(i));\n    }\n\n    const results = await Promise.all(promises);\n    return results.filter((exp): exp is OnChainExperiment => exp !== null);\n  } catch (error) {\n    console.error('Failed to fetch latest experiments:', error);\n    return [];\n  }\n}\n\n/**\n * Fetch experiment data from IPFS gateway using CID\n * Note: Filecoin piece CIDs (bafkzcibd...) may take time to propagate to IPFS\n */\nexport async function fetchExperimentData(cid: string): Promise<any> {\n  // Skip IPFS fetch for now - Filecoin piece CIDs need special handling\n  // For demo, we'll show on-chain metadata only\n  // TODO: Implement Synapse SDK download for full data retrieval\n  \n  console.log(`[IPFS] Skipping fetch for Filecoin piece CID: ${cid.slice(0, 24)}...`);\n  return null;\n  \n  // Future implementation:\n  // const synapse = await Synapse.create({ signer: wallet });\n  // const data = await synapse.storage.download(cid);\n  // return JSON.parse(new TextDecoder().decode(data));\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 577, "column": 0}, "map": {"version":3,"sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-current/lib/filecoin-storage.ts"],"sourcesContent":["/**\n * Filecoin Storage Integration\n * Downloads experiment data from Filecoin using Synapse SDK\n * \n * Security features:\n * - CID validation before download\n * - Timeout protection (30s primary, 10s fallback)\n * - Retry logic with exponential backoff\n * - In-memory caching with size limits\n * - Error logging and user-friendly messages\n */\n\nimport { Synapse } from '@filoz/synapse-sdk';\nimport { ethers } from 'ethers';\nimport { CID } from 'multiformats/cid';\nimport { validateAndSanitizeCID } from './validation';\n\n// Cache to avoid re-downloading (with size limit)\nconst MAX_CACHE_SIZE = 100; // Max 100 experiments cached\nconst dataCache = new Map<string, any>();\n\n// Download configuration\nconst DOWNLOAD_TIMEOUT_MS = 30000; // 30 seconds\nconst FALLBACK_TIMEOUT_MS = 10000; // 10 seconds\nconst MAX_RETRIES = 3;\nconst RETRY_DELAY_MS = 1000; // Start with 1s, then exponential backoff\n\n/**\n * Retry helper with exponential backoff\n */\nasync function retryWithBackoff<T>(\n  fn: () => Promise<T>,\n  retries: number = MAX_RETRIES,\n  delay: number = RETRY_DELAY_MS\n): Promise<T> {\n  try {\n    return await fn();\n  } catch (error) {\n    if (retries === 0) throw error;\n    \n    console.log(`[Filecoin] Retry in ${delay}ms... (${retries} attempts remaining)`);\n    await new Promise(resolve => setTimeout(resolve, delay));\n    \n    return retryWithBackoff(fn, retries - 1, delay * 2); // Exponential backoff\n  }\n}\n\n/**\n * Enforce cache size limit (LRU-style)\n */\nfunction enforceCacheLimit() {\n  if (dataCache.size > MAX_CACHE_SIZE) {\n    const firstKey = dataCache.keys().next().value;\n    if (firstKey) {\n      dataCache.delete(firstKey);\n      console.log(`[Filecoin] Cache limit reached, evicted oldest entry`);\n    }\n  }\n}\n\n/**\n * Download experiment data from Filecoin using piece CID\n * Uses Synapse SDK for reliable retrieval with retry logic\n * \n * @param pieceCid - Filecoin piece CID (bafk... format)\n * @returns Parsed experiment data\n * @throws Error if download fails after retries\n */\nexport async function downloadFromFilecoin(pieceCid: string): Promise<any> {\n  // Validate and sanitize CID\n  let validatedCid: string;\n  try {\n    validatedCid = validateAndSanitizeCID(pieceCid);\n  } catch (error: any) {\n    console.error(`[Filecoin] Invalid CID:`, error.message);\n    throw new Error(`Invalid CID format: ${error.message}`);\n  }\n\n  // Check cache first\n  if (dataCache.has(validatedCid)) {\n    console.log(`[Filecoin] Cache hit for ${validatedCid.slice(0, 20)}...`);\n    return dataCache.get(validatedCid);\n  }\n\n  // Primary download attempt with retry logic\n  try {\n    console.log(`[Filecoin] Downloading ${validatedCid.slice(0, 20)}...`);\n\n    const data = await retryWithBackoff(async () => {\n      // Read-only mode - no private key needed for downloads\n      const rpcUrl = process.env.FILECOIN_CLOUD_RPC || 'https://api.calibration.node.glif.io/rpc/v1';\n      const provider = new ethers.JsonRpcProvider(rpcUrl);\n\n      // For server-side downloads, we can use a dummy signer\n      // Synapse downloads are public and don't require signatures\n      const dummyWallet = ethers.Wallet.createRandom().connect(provider);\n\n      const synapse = await Synapse.create({ \n        signer: dummyWallet,\n        timeout: DOWNLOAD_TIMEOUT_MS,\n      });\n\n      // Download data using piece CID\n      const dataBytes = await synapse.storage.download(validatedCid);\n\n      // Validate downloaded data is not empty\n      if (!dataBytes || dataBytes.length === 0) {\n        throw new Error('Downloaded data is empty');\n      }\n\n      // Convert bytes to JSON with error handling\n      try {\n        const dataStr = new TextDecoder().decode(dataBytes);\n        const parsed = JSON.parse(dataStr);\n        \n        console.log(`[Filecoin] Successfully downloaded ${validatedCid.slice(0, 20)}... (${dataBytes.length} bytes)`);\n        return parsed;\n      } catch (parseError: any) {\n        throw new Error(`Failed to parse downloaded data: ${parseError.message}`);\n      }\n    });\n\n    // Cache successful download\n    dataCache.set(validatedCid, data);\n    enforceCacheLimit();\n    \n    return data;\n\n  } catch (error: any) {\n    console.error(`[Filecoin] Download failed after retries:`, error.message);\n    \n    // Fallback: Try IPFS gateways (may not work for fresh uploads)\n    try {\n      console.log(`[Filecoin] Attempting IPFS gateway fallback...`);\n      \n      const response = await fetch(`https://ipfs.io/ipfs/${validatedCid}`, {\n        signal: AbortSignal.timeout(FALLBACK_TIMEOUT_MS),\n      });\n\n      if (!response.ok) {\n        throw new Error(`Gateway returned ${response.status}`);\n      }\n\n      const data = await response.json();\n      \n      // Cache fallback result\n      dataCache.set(validatedCid, data);\n      enforceCacheLimit();\n      \n      console.log(`[Filecoin] Gateway fallback successful`);\n      return data;\n\n    } catch (fallbackError: any) {\n      console.error(`[Filecoin] Gateway fallback also failed:`, fallbackError.message);\n      \n      // Provide user-friendly error message\n      throw new Error(\n        `Unable to retrieve experiment data. The data may not be available yet on Filecoin network. ` +\n        `Original error: ${error.message}`\n      );\n    }\n  }\n}\n\n/**\n * Batch download multiple experiments\n * Returns map of CID -> data (null for failures)\n */\nexport async function batchDownloadFromFilecoin(\n  cids: string[]\n): Promise<Map<string, any | null>> {\n  const results = new Map<string, any | null>();\n\n  // Download in parallel with concurrency limit\n  const BATCH_SIZE = 5;\n  for (let i = 0; i < cids.length; i += BATCH_SIZE) {\n    const batch = cids.slice(i, i + BATCH_SIZE);\n    \n    const promises = batch.map(async (cid) => {\n      try {\n        const data = await downloadFromFilecoin(cid);\n        return { cid, data };\n      } catch (error) {\n        console.warn(`[Filecoin] Failed to download ${cid}:`, error);\n        return { cid, data: null };\n      }\n    });\n\n    const batchResults = await Promise.all(promises);\n    batchResults.forEach(({ cid, data }) => {\n      results.set(cid, data);\n    });\n  }\n\n  return results;\n}\n\n/**\n * Check if data is available in cache\n */\nexport function isDataCached(cid: string): boolean {\n  return dataCache.has(cid);\n}\n\n/**\n * Clear cache (useful for testing)\n */\nexport function clearCache(): void {\n  dataCache.clear();\n  console.log('[Filecoin] Cache cleared');\n}\n\n/**\n * Get cache statistics\n */\nexport function getCacheStats() {\n  return {\n    size: dataCache.size,\n    cids: Array.from(dataCache.keys()).map(cid => cid.slice(0, 20) + '...'),\n  };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 754, "column": 0}, "map": {"version":3,"sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-current/lib/experiment-service.ts"],"sourcesContent":["/**\n * Unified Experiment Data Service\n * Handles both HPLC and Air Quality experiments from Filecoin\n */\n\nimport { fetchAllExperiments, OnChainExperiment } from './web3-service';\nimport { downloadFromFilecoin } from './filecoin-storage';\nimport type { AirQualityData, HplcData } from './types';\n\nexport type UnifiedExperiment = {\n  id: number;\n  type: 'HPLC' | 'AIR_QUALITY' | 'NMR';\n  sampleId: string;\n  cid: string;\n  difficulty: number;\n  submitter: string;\n  submittedAt: number;\n  data?: AirQualityData | HplcData | null;\n  loading?: boolean;\n};\n\n/**\n * Detect experiment type from difficulty score pattern\n * NMR experiments: difficulty 25-70 (peak complexity based)\n * Air quality experiments: difficulty 15-25 (AQI-based)\n * HPLC experiments: difficulty 7-14 (peak-based)\n */\nfunction detectExperimentType(difficulty: number, id: number): 'HPLC' | 'AIR_QUALITY' | 'NMR' {\n  // NMR experiments have highest difficulty (25-70)\n  if (difficulty >= 25) {\n    return 'NMR';\n  }\n  // Air quality: difficulty 15-24\n  if (difficulty >= 15) {\n    return 'AIR_QUALITY';\n  }\n  // HPLC: difficulty < 15\n  return 'HPLC';\n}\n\n/**\n * Fetch all experiments from chain and enrich with IPFS data\n */\nexport async function fetchUnifiedExperiments(includeData: boolean = false): Promise<UnifiedExperiment[]> {\n  try {\n    // Get all on-chain experiments\n    const onChainExperiments = await fetchAllExperiments();\n    \n    // Enrich with type detection and sample ID\n    const enriched = await Promise.all(onChainExperiments.map(async (exp) => {\n      const type = detectExperimentType(exp.difficulty, exp.id);\n      \n      let sampleId;\n      if (type === 'AIR_QUALITY') {\n        sampleId = `AIR-${exp.submittedAt}`;\n      } else if (type === 'NMR') {\n        sampleId = `NMR-${String(exp.id + 1).padStart(6, '0')}`;\n      } else {\n        sampleId = `HPLC-${String(exp.id + 1).padStart(4, '0')}`;\n      }\n      \n      // Optionally fetch full data from Filecoin\n      let data = null;\n      if (includeData && exp.cid) {\n        try {\n          data = await downloadFromFilecoin(exp.cid);\n        } catch (error) {\n          console.warn(`Failed to fetch data for experiment ${exp.id}:`, error);\n          data = null;\n        }\n      }\n      \n      return {\n        id: exp.id,\n        type,\n        sampleId,\n        cid: exp.cid,\n        difficulty: exp.difficulty,\n        submitter: exp.submitter,\n        submittedAt: exp.submittedAt,\n        data,\n      };\n    }));\n    \n    return enriched;\n  } catch (error) {\n    console.error('Failed to fetch unified experiments:', error);\n    return [];\n  }\n}\n\n/**\n * Fetch just air quality experiments\n */\nexport async function fetchAirQualityExperiments(): Promise<UnifiedExperiment[]> {\n  const all = await fetchUnifiedExperiments();\n  return all.filter(exp => exp.type === 'AIR_QUALITY');\n}\n\n/**\n * Fetch just HPLC experiments\n */\nexport async function fetchHplcExperiments(): Promise<UnifiedExperiment[]> {\n  const all = await fetchUnifiedExperiments();\n  return all.filter(exp => exp.type === 'HPLC');\n}\n\n/**\n * Get the latest experiment of any type\n */\nexport async function fetchLatestExperiment(): Promise<UnifiedExperiment | null> {\n  const all = await fetchUnifiedExperiments();\n  if (all.length === 0) return null;\n  \n  // Sort by ID descending (most recent first)\n  all.sort((a, b) => b.id - a.id);\n  return all[0];\n}\n\n/**\n * Format air quality data for dashboard display\n */\nexport function formatAirQualityForDisplay(data: AirQualityData) {\n  const aqiColor = getAQIColor(data.metrics.air_quality_index);\n  const aqiLabel = data.scenario.replace('_', ' ').toUpperCase();\n  \n  return {\n    title: `Air Quality - ${data.sampleId}`,\n    subtitle: `${data.location} • ${data.device}`,\n    primaryMetric: {\n      label: 'AQI',\n      value: data.metrics.air_quality_index.toFixed(1),\n      color: aqiColor,\n      status: aqiLabel,\n    },\n    sensors: data.sensors,\n    metrics: [\n      {\n        label: 'Formaldehyde',\n        value: `${data.metrics.avg_formaldehyde_ppb.toFixed(1)} ppb`,\n        max: `${data.metrics.max_formaldehyde_ppb.toFixed(1)} ppb`,\n      },\n      {\n        label: 'PM2.5',\n        value: `${data.metrics.avg_pm2_5_ugm3.toFixed(1)} μg/m³`,\n        max: `${data.metrics.max_pm2_5_ugm3.toFixed(1)} μg/m³`,\n      },\n      {\n        label: 'Temperature',\n        value: `${data.metrics.temperature_c.toFixed(1)}°C`,\n      },\n      {\n        label: 'Humidity',\n        value: `${data.metrics.humidity_rh.toFixed(1)}%`,\n      },\n    ],\n    chartData: data.dataPoints.map(point => ({\n      time: point.time,\n      formaldehyde: point.formaldehyde,\n      pm2_5: point.pm2_5,\n      light: point.light,\n    })),\n  };\n}\n\nfunction getAQIColor(aqi: number): string {\n  if (aqi < 50) return 'green';\n  if (aqi < 100) return 'yellow';\n  if (aqi < 150) return 'orange';\n  if (aqi < 200) return 'red';\n  return 'purple';\n}\n\n/**\n * Get real-time stats for dashboard header\n */\nexport async function fetchDashboardStats() {\n  try {\n    const experiments = await fetchUnifiedExperiments();\n    \n    const hplcCount = experiments.filter(e => e.type === 'HPLC').length;\n    const airQualityCount = experiments.filter(e => e.type === 'AIR_QUALITY').length;\n    const nmrCount = experiments.filter(e => e.type === 'NMR').length;\n    \n    // Get most recent upload\n    experiments.sort((a, b) => b.submittedAt - a.submittedAt);\n    const lastSync = experiments.length > 0 \n      ? new Date(experiments[0].submittedAt * 1000).toLocaleTimeString()\n      : 'Never';\n    \n    return {\n      totalExperiments: experiments.length,\n      hplcCount,\n      airQualityCount,\n      nmrCount,\n      lastSync,\n      isLive: true,\n    };\n  } catch (error) {\n    console.error('Failed to fetch dashboard stats:', error);\n    return {\n      totalExperiments: 0,\n      hplcCount: 0,\n      airQualityCount: 0,\n      nmrCount: 0,\n      lastSync: 'Error',\n      isLive: false,\n    };\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 930, "column": 0}, "map": {"version":3,"sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-current/app/api/chat/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport { headers } from 'next/headers';\nimport { queryLLM, isLLMConfigured, type Message } from '@/lib/llm-service';\nimport { fetchUnifiedExperiments, fetchDashboardStats } from '@/lib/experiment-service';\nimport { checkRateLimit } from '@/lib/validation';\n\n// Rate limiting: 20 chat requests per minute (LLM calls are expensive)\nconst RATE_LIMIT = 20;\nconst RATE_WINDOW_MS = 60000;\n\nexport async function POST(request: Request) {\n  const securityHeaders = {\n    'X-Content-Type-Options': 'nosniff',\n    'X-Frame-Options': 'DENY',\n    'Referrer-Policy': 'strict-origin-when-cross-origin',\n  };\n\n  try {\n    // Check if LLM is configured\n    if (!isLLMConfigured()) {\n      return NextResponse.json(\n        { \n          error: 'LLM not configured',\n          message: 'OpenAI API key is missing. Add OPENAI_API_KEY to .env.local'\n        },\n        { status: 503, headers: securityHeaders }\n      );\n    }\n\n    // Get client IP for rate limiting\n    const headersList = await headers();\n    const forwarded = headersList.get('x-forwarded-for');\n    const clientIp = forwarded ? forwarded.split(',')[0].trim() : 'unknown';\n\n    // Check rate limit (stricter for LLM calls)\n    if (!checkRateLimit(`api:chat:${clientIp}`, RATE_LIMIT, RATE_WINDOW_MS)) {\n      return NextResponse.json(\n        { \n          error: 'Rate limit exceeded',\n          message: 'Too many chat requests. Please wait before sending more.',\n          retryAfter: 60\n        },\n        { \n          status: 429,\n          headers: {\n            ...securityHeaders,\n            'Retry-After': '60',\n          }\n        }\n      );\n    }\n\n    // Parse request body\n    const body = await request.json();\n    const { messages, includeGraphContext = true } = body;\n\n    // Validate messages\n    if (!messages || !Array.isArray(messages)) {\n      return NextResponse.json(\n        { error: 'Invalid request', message: 'messages array is required' },\n        { status: 400, headers: securityHeaders }\n      );\n    }\n\n    // Fetch Graph context if requested\n    let graphContext: any = null;\n    if (includeGraphContext) {\n      try {\n        const [experiments, stats] = await Promise.all([\n          fetchUnifiedExperiments(),\n          fetchDashboardStats(),\n        ]);\n        \n        graphContext = {\n          experiments: experiments.slice(0, 10), // Last 10 experiments\n          stats,\n        };\n      } catch (error) {\n        console.warn('[Chat API] Failed to fetch Graph context:', error);\n        // Continue without context rather than failing\n      }\n    }\n\n    // Query LLM (non-streaming for now - can add streaming later)\n    const startTime = Date.now();\n    \n    const response = await queryLLM(messages as Message[], graphContext, {\n      stream: false,\n      maxTokens: 500,\n      temperature: 0.7,\n    });\n\n    const duration = Date.now() - startTime;\n\n    return NextResponse.json(\n      {\n        response: response as string,\n        duration,\n        graphContext: graphContext ? {\n          experimentCount: graphContext.experiments?.length || 0,\n          totalExperiments: graphContext.stats?.totalExperiments || 0,\n        } : null,\n        timestamp: Date.now(),\n      },\n      { headers: securityHeaders }\n    );\n\n  } catch (error: any) {\n    console.error('[Chat API] Error:', error.message);\n    \n    // User-friendly error messages (don't leak internals)\n    let userMessage = 'Chat service temporarily unavailable. Please try again.';\n    let status = 500;\n    \n    if (error.message.includes('API key')) {\n      userMessage = 'Chat service is not configured. Please contact support.';\n      status = 503;\n    } else if (error.message.includes('rate limit')) {\n      userMessage = 'OpenAI rate limit reached. Please try again in a moment.';\n      status = 429;\n    } else if (error.message.includes('timeout')) {\n      userMessage = 'Request timeout. Please try a shorter query.';\n      status = 504;\n    }\n    \n    return NextResponse.json(\n      { \n        error: 'Chat error',\n        message: userMessage,\n        timestamp: Date.now()\n      },\n      { status, headers: securityHeaders }\n    );\n  }\n}\n\n// Enable edge runtime for faster responses (optional)\n// export const runtime = 'edge';\n\n// Disable caching for chat (always fresh)\nexport const revalidate = 0;\nexport const dynamic = 'force-dynamic';\n"],"names":[],"mappings":"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"}}]
}