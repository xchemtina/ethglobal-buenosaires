{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry-internal/feedback/build/npm/esm/index.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry-internal/feedback/src/constants/index.ts","file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry-internal/feedback/src/core/sendFeedback.ts","file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry-internal/feedback/src/util/debug-build.ts","file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry-internal/feedback/src/util/isScreenshotSupported.ts","file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry-internal/feedback/src/util/mergeOptions.ts","file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry-internal/feedback/src/core/components/Actor.css.ts","file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry-internal/feedback/src/util/setAttributesNS.ts","file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry-internal/feedback/src/core/components/FeedbackIcon.ts","file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry-internal/feedback/src/core/components/Actor.ts","file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry-internal/feedback/src/core/createMainStyles.ts","file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry-internal/feedback/src/core/integration.ts","file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry-internal/feedback/src/core/getFeedback.ts","file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/node_modules/preact/dist/preact.mjs","file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/node_modules/preact/hooks/dist/hooks.mjs","file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry-internal/feedback/src/modal/components/SentryLogo.ts","file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry-internal/feedback/src/modal/components/DialogHeader.tsx","file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry-internal/feedback/src/util/validate.ts","file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry-internal/feedback/src/modal/components/Form.tsx","file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry-internal/feedback/src/modal/components/SuccessIcon.ts","file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry-internal/feedback/src/modal/components/Dialog.tsx","file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry-internal/feedback/src/modal/components/Dialog.css.ts","file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry-internal/feedback/src/modal/integration.tsx","file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry-internal/feedback/src/screenshot/components/IconClose.tsx","file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry-internal/feedback/src/screenshot/components/ScreenshotInput.css.ts","file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry-internal/feedback/src/screenshot/components/Toolbar.tsx","file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry-internal/feedback/src/screenshot/components/useTakeScreenshot.tsx","file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry-internal/feedback/src/screenshot/components/ScreenshotEditor.tsx","file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry-internal/feedback/src/screenshot/integration.ts"],"sourcesContent":["import { GLOBAL_OBJ } from '@sentry/core';\n\n// exporting a separate copy of `WINDOW` rather than exporting the one from `@sentry/browser`\n// prevents the browser package from being bundled in the CDN bundle, and avoids a\n// circular dependency between the browser and feedback packages\nexport const WINDOW = GLOBAL_OBJ as typeof GLOBAL_OBJ & Window;\nexport const DOCUMENT = WINDOW.document;\nexport const NAVIGATOR = WINDOW.navigator;\n\nexport const TRIGGER_LABEL = 'Report a Bug';\nexport const CANCEL_BUTTON_LABEL = 'Cancel';\nexport const SUBMIT_BUTTON_LABEL = 'Send Bug Report';\nexport const CONFIRM_BUTTON_LABEL = 'Confirm';\nexport const FORM_TITLE = 'Report a Bug';\nexport const EMAIL_PLACEHOLDER = 'your.email@example.org';\nexport const EMAIL_LABEL = 'Email';\nexport const MESSAGE_PLACEHOLDER = \"What's the bug? What did you expect?\";\nexport const MESSAGE_LABEL = 'Description';\nexport const NAME_PLACEHOLDER = 'Your Name';\nexport const NAME_LABEL = 'Name';\nexport const SUCCESS_MESSAGE_TEXT = 'Thank you for your report!';\nexport const IS_REQUIRED_LABEL = '(required)';\nexport const ADD_SCREENSHOT_LABEL = 'Add a screenshot';\nexport const REMOVE_SCREENSHOT_LABEL = 'Remove screenshot';\nexport const HIGHLIGHT_TOOL_TEXT = 'Highlight';\nexport const HIDE_TOOL_TEXT = 'Hide';\nexport const REMOVE_HIGHLIGHT_TEXT = 'Remove';\n\nexport const FEEDBACK_WIDGET_SOURCE = 'widget';\nexport const FEEDBACK_API_SOURCE = 'api';\n\nexport const SUCCESS_MESSAGE_TIMEOUT = 5000;\n","import type { Event, EventHint, SendFeedback, SendFeedbackParams, TransportMakeRequestResponse } from '@sentry/core';\nimport { captureFeedback, getClient, getCurrentScope, getLocationHref } from '@sentry/core';\nimport { FEEDBACK_API_SOURCE } from '../constants';\n\n/**\n * Public API to send a Feedback item to Sentry\n */\nexport const sendFeedback: SendFeedback = (\n  params: SendFeedbackParams,\n  hint: EventHint & { includeReplay?: boolean } = { includeReplay: true },\n): Promise<string> => {\n  if (!params.message) {\n    throw new Error('Unable to submit feedback with empty message');\n  }\n\n  // We want to wait for the feedback to be sent (or not)\n  const client = getClient();\n\n  if (!client) {\n    throw new Error('No client setup, cannot send feedback.');\n  }\n\n  if (params.tags && Object.keys(params.tags).length) {\n    getCurrentScope().setTags(params.tags);\n  }\n  const eventId = captureFeedback(\n    {\n      source: FEEDBACK_API_SOURCE,\n      url: getLocationHref(),\n      ...params,\n    },\n    hint,\n  );\n\n  // We want to wait for the feedback to be sent (or not)\n  return new Promise<string>((resolve, reject) => {\n    // After 30s, we want to clear anyhow\n    const timeout = setTimeout(() => reject('Unable to determine if Feedback was correctly sent.'), 30_000);\n\n    const cleanup = client.on('afterSendEvent', (event: Event, response: TransportMakeRequestResponse) => {\n      if (event.event_id !== eventId) {\n        return;\n      }\n\n      clearTimeout(timeout);\n      cleanup();\n\n      // Require valid status codes, otherwise can assume feedback was not sent successfully\n      if (response?.statusCode && response.statusCode >= 200 && response.statusCode < 300) {\n        return resolve(eventId);\n      }\n\n      if (response?.statusCode === 403) {\n        return reject(\n          'Unable to send feedback. This could be because this domain is not in your list of allowed domains.',\n        );\n      }\n\n      return reject(\n        'Unable to send feedback. This could be because of network issues, or because you are using an ad-blocker.',\n      );\n    });\n  });\n};\n\n/*\n * For reference, the fully built event looks something like this:\n * {\n *     \"type\": \"feedback\",\n *     \"event_id\": \"d2132d31b39445f1938d7e21b6bf0ec4\",\n *     \"timestamp\": 1597977777.6189718,\n *     \"dist\": \"1.12\",\n *     \"platform\": \"javascript\",\n *     \"environment\": \"production\",\n *     \"release\": 42,\n *     \"tags\": {\"transaction\": \"/organizations/:orgId/performance/:eventSlug/\"},\n *     \"sdk\": {\"name\": \"name\", \"version\": \"version\"},\n *     \"user\": {\n *         \"id\": \"123\",\n *         \"username\": \"user\",\n *         \"email\": \"user@site.com\",\n *         \"ip_address\": \"192.168.11.12\",\n *     },\n *     \"request\": {\n *         \"url\": None,\n *         \"headers\": {\n *             \"user-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.5 Safari/605.1.15\"\n *         },\n *     },\n *     \"contexts\": {\n *         \"feedback\": {\n *             \"message\": \"test message\",\n *             \"contact_email\": \"test@example.com\",\n *             \"type\": \"feedback\",\n *         },\n *         \"trace\": {\n *             \"trace_id\": \"4C79F60C11214EB38604F4AE0781BFB2\",\n *             \"span_id\": \"FA90FDEAD5F74052\",\n *             \"type\": \"trace\",\n *         },\n *         \"replay\": {\n *             \"replay_id\": \"e2d42047b1c5431c8cba85ee2a8ab25d\",\n *         },\n *     },\n *   }\n */\n","declare const __DEBUG_BUILD__: boolean;\n\n/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nexport const DEBUG_BUILD = __DEBUG_BUILD__;\n","import { NAVIGATOR } from '../constants';\n\n/**\n * Mobile browsers do not support `mediaDevices.getDisplayMedia` even though they have the api implemented\n * Instead they return things like `NotAllowedError` when called.\n *\n * It's simpler for us to browser sniff first, and avoid loading the integration if we can.\n *\n * https://stackoverflow.com/a/58879212\n * https://stackoverflow.com/a/3540295\n *\n * `mediaDevices.getDisplayMedia` is also only supported in secure contexts, and return a `mediaDevices is not supported` error, so we should also avoid loading the integration if we can.\n *\n * https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getDisplayMedia\n */\nexport function isScreenshotSupported(): boolean {\n  if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(NAVIGATOR.userAgent)) {\n    return false;\n  }\n  /**\n   * User agent on iPads show as Macintosh, so we need extra checks\n   *\n   * https://forums.developer.apple.com/forums/thread/119186\n   * https://stackoverflow.com/questions/60482650/how-to-detect-ipad-useragent-on-safari-browser\n   */\n  if (/Macintosh/i.test(NAVIGATOR.userAgent) && NAVIGATOR.maxTouchPoints && NAVIGATOR.maxTouchPoints > 1) {\n    return false;\n  }\n  if (!isSecureContext) {\n    return false;\n  }\n  return true;\n}\n","import type { FeedbackFormData, FeedbackInternalOptions } from '@sentry/core';\nimport type { OptionalFeedbackConfiguration } from '../core/types';\n\n/**\n * Quick and dirty deep merge for the Feedback integration options\n */\nexport function mergeOptions(\n  defaultOptions: FeedbackInternalOptions,\n  optionOverrides: OptionalFeedbackConfiguration,\n): FeedbackInternalOptions {\n  return {\n    ...defaultOptions,\n    ...optionOverrides,\n    tags: {\n      ...defaultOptions.tags,\n      ...optionOverrides.tags,\n    },\n    onFormOpen: () => {\n      optionOverrides.onFormOpen?.();\n      defaultOptions.onFormOpen?.();\n    },\n    onFormClose: () => {\n      optionOverrides.onFormClose?.();\n      defaultOptions.onFormClose?.();\n    },\n    onSubmitSuccess: (data: FeedbackFormData, eventId: string) => {\n      optionOverrides.onSubmitSuccess?.(data, eventId);\n      defaultOptions.onSubmitSuccess?.(data, eventId);\n    },\n    onSubmitError: (error: Error) => {\n      optionOverrides.onSubmitError?.(error);\n      defaultOptions.onSubmitError?.(error);\n    },\n    onFormSubmitted: () => {\n      optionOverrides.onFormSubmitted?.();\n      defaultOptions.onFormSubmitted?.();\n    },\n    themeDark: {\n      ...defaultOptions.themeDark,\n      ...optionOverrides.themeDark,\n    },\n    themeLight: {\n      ...defaultOptions.themeLight,\n      ...optionOverrides.themeLight,\n    },\n  };\n}\n","import { DOCUMENT } from '../../constants';\n\n/**\n * Creates <style> element for widget actor (button that opens the dialog)\n */\nexport function createActorStyles(styleNonce?: string): HTMLStyleElement {\n  const style = DOCUMENT.createElement('style');\n  style.textContent = `\n.widget__actor {\n  position: fixed;\n  z-index: var(--z-index);\n  margin: var(--page-margin);\n  inset: var(--actor-inset);\n\n  display: flex;\n  align-items: center;\n  gap: 8px;\n  padding: 16px;\n\n  font-family: inherit;\n  font-size: var(--font-size);\n  font-weight: 600;\n  line-height: 1.14em;\n  text-decoration: none;\n\n  background: var(--actor-background, var(--background));\n  border-radius: var(--actor-border-radius, 1.7em/50%);\n  border: var(--actor-border, var(--border));\n  box-shadow: var(--actor-box-shadow, var(--box-shadow));\n  color: var(--actor-color, var(--foreground));\n  fill: var(--actor-color, var(--foreground));\n  cursor: pointer;\n  opacity: 1;\n  transition: transform 0.2s ease-in-out;\n  transform: translate(0, 0) scale(1);\n}\n.widget__actor[aria-hidden=\"true\"] {\n  opacity: 0;\n  pointer-events: none;\n  visibility: hidden;\n  transform: translate(0, 16px) scale(0.98);\n}\n\n.widget__actor:hover {\n  background: var(--actor-hover-background, var(--background));\n  filter: var(--interactive-filter);\n}\n\n.widget__actor svg {\n  width: 1.14em;\n  height: 1.14em;\n}\n\n@media (max-width: 600px) {\n  .widget__actor span {\n    display: none;\n  }\n}\n`;\n\n  if (styleNonce) {\n    style.setAttribute('nonce', styleNonce);\n  }\n\n  return style;\n}\n","/**\n * Helper function to set a dict of attributes on element (w/ specified namespace)\n */\nexport function setAttributesNS<T extends SVGElement>(el: T, attributes: Record<string, string>): T {\n  Object.entries(attributes).forEach(([key, val]) => {\n    el.setAttributeNS(null, key, val);\n  });\n  return el;\n}\n","import { WINDOW } from '../../constants';\nimport { setAttributesNS } from '../../util/setAttributesNS';\n\nconst SIZE = 20;\nconst XMLNS = 'http://www.w3.org/2000/svg';\n\n/**\n * Feedback Icon\n */\nexport function FeedbackIcon(): SVGElement {\n  const createElementNS = <K extends keyof SVGElementTagNameMap>(tagName: K): SVGElementTagNameMap[K] =>\n    WINDOW.document.createElementNS(XMLNS, tagName);\n  const svg = setAttributesNS(createElementNS('svg'), {\n    width: `${SIZE}`,\n    height: `${SIZE}`,\n    viewBox: `0 0 ${SIZE} ${SIZE}`,\n    fill: 'var(--actor-color, var(--foreground))',\n  });\n\n  const g = setAttributesNS(createElementNS('g'), {\n    clipPath: 'url(#clip0_57_80)',\n  });\n\n  const path = setAttributesNS(createElementNS('path'), {\n    ['fill-rule']: 'evenodd',\n    ['clip-rule']: 'evenodd',\n    d: 'M15.6622 15H12.3997C12.2129 14.9959 12.031 14.9396 11.8747 14.8375L8.04965 12.2H7.49956V19.1C7.4875 19.3348 7.3888 19.5568 7.22256 19.723C7.05632 19.8892 6.83435 19.9879 6.59956 20H2.04956C1.80193 19.9968 1.56535 19.8969 1.39023 19.7218C1.21511 19.5467 1.1153 19.3101 1.11206 19.0625V12.2H0.949652C0.824431 12.2017 0.700142 12.1783 0.584123 12.1311C0.468104 12.084 0.362708 12.014 0.274155 11.9255C0.185602 11.8369 0.115689 11.7315 0.0685419 11.6155C0.0213952 11.4995 -0.00202913 11.3752 -0.00034808 11.25V3.75C-0.00900498 3.62067 0.0092504 3.49095 0.0532651 3.36904C0.0972798 3.24712 0.166097 3.13566 0.255372 3.04168C0.344646 2.94771 0.452437 2.87327 0.571937 2.82307C0.691437 2.77286 0.82005 2.74798 0.949652 2.75H8.04965L11.8747 0.1625C12.031 0.0603649 12.2129 0.00407221 12.3997 0H15.6622C15.9098 0.00323746 16.1464 0.103049 16.3215 0.278167C16.4966 0.453286 16.5964 0.689866 16.5997 0.9375V3.25269C17.3969 3.42959 18.1345 3.83026 18.7211 4.41679C19.5322 5.22788 19.9878 6.32796 19.9878 7.47502C19.9878 8.62209 19.5322 9.72217 18.7211 10.5333C18.1345 11.1198 17.3969 11.5205 16.5997 11.6974V14.0125C16.6047 14.1393 16.5842 14.2659 16.5395 14.3847C16.4948 14.5035 16.4268 14.6121 16.3394 14.7042C16.252 14.7962 16.147 14.8698 16.0307 14.9206C15.9144 14.9714 15.7891 14.9984 15.6622 15ZM1.89695 10.325H1.88715V4.625H8.33715C8.52423 4.62301 8.70666 4.56654 8.86215 4.4625L12.6872 1.875H14.7247V13.125H12.6872L8.86215 10.4875C8.70666 10.3835 8.52423 10.327 8.33715 10.325H2.20217C2.15205 10.3167 2.10102 10.3125 2.04956 10.3125C1.9981 10.3125 1.94708 10.3167 1.89695 10.325ZM2.98706 12.2V18.1625H5.66206V12.2H2.98706ZM16.5997 9.93612V5.01393C16.6536 5.02355 16.7072 5.03495 16.7605 5.04814C17.1202 5.13709 17.4556 5.30487 17.7425 5.53934C18.0293 5.77381 18.2605 6.06912 18.4192 6.40389C18.578 6.73866 18.6603 7.10452 18.6603 7.47502C18.6603 7.84552 18.578 8.21139 18.4192 8.54616C18.2605 8.88093 18.0293 9.17624 17.7425 9.41071C17.4556 9.64518 17.1202 9.81296 16.7605 9.90191C16.7072 9.91509 16.6536 9.9265 16.5997 9.93612Z',\n  });\n  svg.appendChild(g).appendChild(path);\n\n  const speakerDefs = createElementNS('defs');\n  const speakerClipPathDef = setAttributesNS(createElementNS('clipPath'), {\n    id: 'clip0_57_80',\n  });\n\n  const speakerRect = setAttributesNS(createElementNS('rect'), {\n    width: `${SIZE}`,\n    height: `${SIZE}`,\n    fill: 'white',\n  });\n\n  speakerClipPathDef.appendChild(speakerRect);\n  speakerDefs.appendChild(speakerClipPathDef);\n\n  svg.appendChild(speakerDefs).appendChild(speakerClipPathDef).appendChild(speakerRect);\n\n  return svg;\n}\n","import { DOCUMENT, TRIGGER_LABEL } from '../../constants';\nimport { createActorStyles } from './Actor.css';\nimport { FeedbackIcon } from './FeedbackIcon';\n\nexport interface ActorProps {\n  triggerLabel: string;\n  triggerAriaLabel: string;\n  shadow: ShadowRoot;\n  styleNonce?: string;\n}\n\nexport interface ActorComponent {\n  el: HTMLElement;\n\n  appendToDom: () => void;\n\n  removeFromDom: () => void;\n\n  show: () => void;\n\n  hide: () => void;\n}\n\n/**\n * The sentry-provided button to open the feedback modal\n */\nexport function Actor({ triggerLabel, triggerAriaLabel, shadow, styleNonce }: ActorProps): ActorComponent {\n  const el = DOCUMENT.createElement('button');\n  el.type = 'button';\n  el.className = 'widget__actor';\n  el.ariaHidden = 'false';\n  el.ariaLabel = triggerAriaLabel || triggerLabel || TRIGGER_LABEL;\n  el.appendChild(FeedbackIcon());\n  if (triggerLabel) {\n    const label = DOCUMENT.createElement('span');\n    label.appendChild(DOCUMENT.createTextNode(triggerLabel));\n    el.appendChild(label);\n  }\n\n  const style = createActorStyles(styleNonce);\n\n  return {\n    el,\n    appendToDom(): void {\n      shadow.appendChild(style);\n      shadow.appendChild(el);\n    },\n    removeFromDom(): void {\n      el.remove();\n      style.remove();\n    },\n    show(): void {\n      el.ariaHidden = 'false';\n    },\n    hide(): void {\n      el.ariaHidden = 'true';\n    },\n  };\n}\n","import type { FeedbackInternalOptions } from '@sentry/core';\nimport { DOCUMENT } from '../constants';\n\nconst PURPLE = 'rgba(88, 74, 192, 1)';\n\ninterface InternalTheme extends NonNullable<FeedbackInternalOptions['themeLight']> {\n  border: string;\n  interactiveFilter: string;\n}\n\nconst DEFAULT_LIGHT: InternalTheme = {\n  foreground: '#2b2233',\n  background: '#ffffff',\n  accentForeground: 'white',\n  accentBackground: PURPLE,\n  successColor: '#268d75',\n  errorColor: '#df3338',\n  border: '1.5px solid rgba(41, 35, 47, 0.13)',\n  boxShadow: '0px 4px 24px 0px rgba(43, 34, 51, 0.12)',\n  outline: '1px auto var(--accent-background)',\n  interactiveFilter: 'brightness(95%)',\n};\nconst DEFAULT_DARK: InternalTheme = {\n  foreground: '#ebe6ef',\n  background: '#29232f',\n  accentForeground: 'white',\n  accentBackground: PURPLE,\n  successColor: '#2da98c',\n  errorColor: '#f55459',\n  border: '1.5px solid rgba(235, 230, 239, 0.15)',\n  boxShadow: '0px 4px 24px 0px rgba(43, 34, 51, 0.12)',\n  outline: '1px auto var(--accent-background)',\n  interactiveFilter: 'brightness(150%)',\n};\n\nfunction getThemedCssVariables(theme: InternalTheme): string {\n  return `\n  --foreground: ${theme.foreground};\n  --background: ${theme.background};\n  --accent-foreground: ${theme.accentForeground};\n  --accent-background: ${theme.accentBackground};\n  --success-color: ${theme.successColor};\n  --error-color: ${theme.errorColor};\n  --border: ${theme.border};\n  --box-shadow: ${theme.boxShadow};\n  --outline: ${theme.outline};\n  --interactive-filter: ${theme.interactiveFilter};\n  `;\n}\n\n/**\n * Creates <style> element for widget actor (button that opens the dialog)\n */\nexport function createMainStyles({\n  colorScheme,\n  themeDark,\n  themeLight,\n  styleNonce,\n}: FeedbackInternalOptions): HTMLStyleElement {\n  const style = DOCUMENT.createElement('style');\n  style.textContent = `\n:host {\n  --font-family: system-ui, 'Helvetica Neue', Arial, sans-serif;\n  --font-size: 14px;\n  --z-index: 100000;\n\n  --page-margin: 16px;\n  --inset: auto 0 0 auto;\n  --actor-inset: var(--inset);\n\n  font-family: var(--font-family);\n  font-size: var(--font-size);\n\n  ${colorScheme !== 'system' ? 'color-scheme: only light;' : ''}\n\n  ${getThemedCssVariables(\n    colorScheme === 'dark' ? { ...DEFAULT_DARK, ...themeDark } : { ...DEFAULT_LIGHT, ...themeLight },\n  )}\n}\n\n${\n  colorScheme === 'system'\n    ? `\n@media (prefers-color-scheme: dark) {\n  :host {\n    ${getThemedCssVariables({ ...DEFAULT_DARK, ...themeDark })}\n  }\n}`\n    : ''\n}\n}\n`;\n\n  if (styleNonce) {\n    style.setAttribute('nonce', styleNonce);\n  }\n\n  return style;\n}\n","/* eslint-disable max-lines */\n\nimport type {\n  FeedbackInternalOptions,\n  FeedbackModalIntegration,\n  FeedbackScreenshotIntegration,\n  Integration,\n  IntegrationFn,\n} from '@sentry/core';\nimport { addIntegration, debug, isBrowser } from '@sentry/core';\nimport {\n  ADD_SCREENSHOT_LABEL,\n  CANCEL_BUTTON_LABEL,\n  CONFIRM_BUTTON_LABEL,\n  DOCUMENT,\n  EMAIL_LABEL,\n  EMAIL_PLACEHOLDER,\n  FORM_TITLE,\n  HIDE_TOOL_TEXT,\n  HIGHLIGHT_TOOL_TEXT,\n  IS_REQUIRED_LABEL,\n  MESSAGE_LABEL,\n  MESSAGE_PLACEHOLDER,\n  NAME_LABEL,\n  NAME_PLACEHOLDER,\n  REMOVE_HIGHLIGHT_TEXT,\n  REMOVE_SCREENSHOT_LABEL,\n  SUBMIT_BUTTON_LABEL,\n  SUCCESS_MESSAGE_TEXT,\n  TRIGGER_LABEL,\n} from '../constants';\nimport { DEBUG_BUILD } from '../util/debug-build';\nimport { isScreenshotSupported } from '../util/isScreenshotSupported';\nimport { mergeOptions } from '../util/mergeOptions';\nimport type { ActorComponent } from './components/Actor';\nimport { Actor } from './components/Actor';\nimport { createMainStyles } from './createMainStyles';\nimport { sendFeedback } from './sendFeedback';\nimport type { OptionalFeedbackConfiguration, OverrideFeedbackConfiguration } from './types';\n\ntype Unsubscribe = () => void;\n\n/**\n * Allow users to capture user feedback and send it to Sentry.\n */\n\ntype BuilderOptions =\n  | {\n      lazyLoadIntegration?: never;\n      getModalIntegration: () => IntegrationFn;\n      getScreenshotIntegration: () => IntegrationFn;\n    }\n  | {\n      // The type here should be `keyof typeof LazyLoadableIntegrations`, but that'll cause a cicrular\n      // dependency with @sentry/core\n      lazyLoadIntegration: (\n        name: 'feedbackModalIntegration' | 'feedbackScreenshotIntegration',\n        scriptNonce?: string,\n      ) => Promise<IntegrationFn>;\n      getModalIntegration?: never;\n      getScreenshotIntegration?: never;\n    };\n\nexport const buildFeedbackIntegration = ({\n  lazyLoadIntegration,\n  getModalIntegration,\n  getScreenshotIntegration,\n}: BuilderOptions): IntegrationFn<\n  Integration & {\n    attachTo(el: Element | string, optionOverrides?: OverrideFeedbackConfiguration): Unsubscribe;\n    createForm(\n      optionOverrides?: OverrideFeedbackConfiguration,\n    ): Promise<ReturnType<FeedbackModalIntegration['createDialog']>>;\n    createWidget(optionOverrides?: OverrideFeedbackConfiguration): ActorComponent;\n    remove(): void;\n  }\n> => {\n  const feedbackIntegration = (({\n    // FeedbackGeneralConfiguration\n    id = 'sentry-feedback',\n    autoInject = true,\n    showBranding = true,\n    isEmailRequired = false,\n    isNameRequired = false,\n    showEmail = true,\n    showName = true,\n    enableScreenshot = true,\n    useSentryUser = {\n      email: 'email',\n      name: 'username',\n    },\n    tags,\n    styleNonce,\n    scriptNonce,\n\n    // FeedbackThemeConfiguration\n    colorScheme = 'system',\n    themeLight = {},\n    themeDark = {},\n\n    // FeedbackTextConfiguration\n    addScreenshotButtonLabel = ADD_SCREENSHOT_LABEL,\n    cancelButtonLabel = CANCEL_BUTTON_LABEL,\n    confirmButtonLabel = CONFIRM_BUTTON_LABEL,\n    emailLabel = EMAIL_LABEL,\n    emailPlaceholder = EMAIL_PLACEHOLDER,\n    formTitle = FORM_TITLE,\n    isRequiredLabel = IS_REQUIRED_LABEL,\n    messageLabel = MESSAGE_LABEL,\n    messagePlaceholder = MESSAGE_PLACEHOLDER,\n    nameLabel = NAME_LABEL,\n    namePlaceholder = NAME_PLACEHOLDER,\n    removeScreenshotButtonLabel = REMOVE_SCREENSHOT_LABEL,\n    submitButtonLabel = SUBMIT_BUTTON_LABEL,\n    successMessageText = SUCCESS_MESSAGE_TEXT,\n    triggerLabel = TRIGGER_LABEL,\n    triggerAriaLabel = '',\n    highlightToolText = HIGHLIGHT_TOOL_TEXT,\n    hideToolText = HIDE_TOOL_TEXT,\n    removeHighlightText = REMOVE_HIGHLIGHT_TEXT,\n\n    // FeedbackCallbacks\n    onFormOpen,\n    onFormClose,\n    onSubmitSuccess,\n    onSubmitError,\n    onFormSubmitted,\n  }: OptionalFeedbackConfiguration = {}) => {\n    const _options = {\n      id,\n      autoInject,\n      showBranding,\n      isEmailRequired,\n      isNameRequired,\n      showEmail,\n      showName,\n      enableScreenshot,\n      useSentryUser,\n      tags,\n      styleNonce,\n      scriptNonce,\n\n      colorScheme,\n      themeDark,\n      themeLight,\n\n      triggerLabel,\n      triggerAriaLabel,\n      cancelButtonLabel,\n      submitButtonLabel,\n      confirmButtonLabel,\n      formTitle,\n      emailLabel,\n      emailPlaceholder,\n      messageLabel,\n      messagePlaceholder,\n      nameLabel,\n      namePlaceholder,\n      successMessageText,\n      isRequiredLabel,\n      addScreenshotButtonLabel,\n      removeScreenshotButtonLabel,\n      highlightToolText,\n      hideToolText,\n      removeHighlightText,\n\n      onFormClose,\n      onFormOpen,\n      onSubmitError,\n      onSubmitSuccess,\n      onFormSubmitted,\n    };\n\n    let _shadow: ShadowRoot | null = null;\n    let _subscriptions: Unsubscribe[] = [];\n\n    /**\n     * Get the shadow root where we will append css\n     */\n    const _createShadow = (options: FeedbackInternalOptions): ShadowRoot => {\n      if (!_shadow) {\n        const host = DOCUMENT.createElement('div');\n        host.id = String(options.id);\n        DOCUMENT.body.appendChild(host);\n\n        _shadow = host.attachShadow({ mode: 'open' });\n        _shadow.appendChild(createMainStyles(options));\n      }\n      return _shadow;\n    };\n\n    const _loadAndRenderDialog = async (\n      options: FeedbackInternalOptions,\n    ): Promise<ReturnType<FeedbackModalIntegration['createDialog']>> => {\n      const screenshotRequired = options.enableScreenshot && isScreenshotSupported();\n\n      let modalIntegration: FeedbackModalIntegration;\n      let screenshotIntegration: FeedbackScreenshotIntegration | undefined;\n\n      try {\n        const modalIntegrationFn = getModalIntegration\n          ? getModalIntegration()\n          : await lazyLoadIntegration('feedbackModalIntegration', scriptNonce);\n        modalIntegration = modalIntegrationFn() as FeedbackModalIntegration;\n        addIntegration(modalIntegration);\n      } catch {\n        DEBUG_BUILD &&\n          debug.error(\n            '[Feedback] Error when trying to load feedback integrations. Try using `feedbackSyncIntegration` in your `Sentry.init`.',\n          );\n        throw new Error('[Feedback] Missing feedback modal integration!');\n      }\n\n      try {\n        const screenshotIntegrationFn = screenshotRequired\n          ? getScreenshotIntegration\n            ? getScreenshotIntegration()\n            : await lazyLoadIntegration('feedbackScreenshotIntegration', scriptNonce)\n          : undefined;\n\n        if (screenshotIntegrationFn) {\n          screenshotIntegration = screenshotIntegrationFn() as FeedbackScreenshotIntegration;\n          addIntegration(screenshotIntegration);\n        }\n      } catch {\n        DEBUG_BUILD &&\n          debug.error('[Feedback] Missing feedback screenshot integration. Proceeding without screenshots.');\n      }\n\n      const dialog = modalIntegration.createDialog({\n        options: {\n          ...options,\n          onFormClose: () => {\n            dialog?.close();\n            options.onFormClose?.();\n          },\n          onFormSubmitted: () => {\n            dialog?.close();\n            options.onFormSubmitted?.();\n          },\n        },\n        screenshotIntegration,\n        sendFeedback,\n        shadow: _createShadow(options),\n      });\n\n      return dialog;\n    };\n\n    const _attachTo = (el: Element | string, optionOverrides: OverrideFeedbackConfiguration = {}): Unsubscribe => {\n      const mergedOptions = mergeOptions(_options, optionOverrides);\n\n      const targetEl =\n        typeof el === 'string' ? DOCUMENT.querySelector(el) : typeof el.addEventListener === 'function' ? el : null;\n\n      if (!targetEl) {\n        DEBUG_BUILD && debug.error('[Feedback] Unable to attach to target element');\n        throw new Error('Unable to attach to target element');\n      }\n\n      let dialog: ReturnType<FeedbackModalIntegration['createDialog']> | null = null;\n      const handleClick = async (): Promise<void> => {\n        if (!dialog) {\n          dialog = await _loadAndRenderDialog({\n            ...mergedOptions,\n            onFormSubmitted: () => {\n              dialog?.removeFromDom();\n              mergedOptions.onFormSubmitted?.();\n            },\n          });\n        }\n        dialog.appendToDom();\n        dialog.open();\n      };\n      targetEl.addEventListener('click', handleClick);\n      const unsubscribe = (): void => {\n        _subscriptions = _subscriptions.filter(sub => sub !== unsubscribe);\n        dialog?.removeFromDom();\n        dialog = null;\n        targetEl.removeEventListener('click', handleClick);\n      };\n      _subscriptions.push(unsubscribe);\n      return unsubscribe;\n    };\n\n    const _createActor = (optionOverrides: OverrideFeedbackConfiguration = {}): ActorComponent => {\n      const mergedOptions = mergeOptions(_options, optionOverrides);\n      const shadow = _createShadow(mergedOptions);\n      const actor = Actor({\n        triggerLabel: mergedOptions.triggerLabel,\n        triggerAriaLabel: mergedOptions.triggerAriaLabel,\n        shadow,\n        styleNonce,\n      });\n      _attachTo(actor.el, {\n        ...mergedOptions,\n        onFormOpen() {\n          actor.hide();\n        },\n        onFormClose() {\n          actor.show();\n        },\n        onFormSubmitted() {\n          actor.show();\n        },\n      });\n      return actor;\n    };\n\n    return {\n      name: 'Feedback',\n      setupOnce() {\n        if (!isBrowser() || !_options.autoInject) {\n          return;\n        }\n\n        if (DOCUMENT.readyState === 'loading') {\n          DOCUMENT.addEventListener('DOMContentLoaded', () => _createActor().appendToDom());\n        } else {\n          _createActor().appendToDom();\n        }\n      },\n\n      /**\n       * Adds click listener to the element to open a feedback dialog\n       *\n       * The returned function can be used to remove the click listener\n       */\n      attachTo: _attachTo,\n\n      /**\n       * Creates a new widget which is composed of a Button which triggers a Dialog.\n       * Accepts partial options to override any options passed to constructor.\n       */\n      createWidget(optionOverrides: OverrideFeedbackConfiguration = {}): ActorComponent {\n        const actor = _createActor(mergeOptions(_options, optionOverrides));\n        actor.appendToDom();\n        return actor;\n      },\n\n      /**\n       * Creates a new Form which you can\n       * Accepts partial options to override any options passed to constructor.\n       */\n      async createForm(\n        optionOverrides: OverrideFeedbackConfiguration = {},\n      ): Promise<ReturnType<FeedbackModalIntegration['createDialog']>> {\n        return _loadAndRenderDialog(mergeOptions(_options, optionOverrides));\n      },\n\n      /**\n       * Removes the Feedback integration (including host, shadow DOM, and all widgets)\n       */\n      remove(): void {\n        if (_shadow) {\n          _shadow.parentElement?.remove();\n          _shadow = null;\n        }\n        // Remove any lingering subscriptions\n        _subscriptions.forEach(sub => sub());\n        _subscriptions = [];\n      },\n    };\n  }) satisfies IntegrationFn;\n\n  return feedbackIntegration;\n};\n","import { getClient } from '@sentry/core';\nimport type { buildFeedbackIntegration } from './integration';\n\ntype FeedbackIntegration = ReturnType<typeof buildFeedbackIntegration>;\n\n/**\n * This is a small utility to get a type-safe instance of the Feedback integration.\n */\nexport function getFeedback(): ReturnType<FeedbackIntegration> | undefined {\n  const client = getClient();\n  return client?.getIntegrationByName<ReturnType<FeedbackIntegration>>('Feedback');\n}\n","var n,l,u,t,i,o,r,f,e,c={},s=[],a=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i,h=Array.isArray;function v(n,l){for(var u in l)n[u]=l[u];return n}function p(n){var l=n.parentNode;l&&l.removeChild(n)}function y(l,u,t){var i,o,r,f={};for(r in u)\"key\"==r?i=u[r]:\"ref\"==r?o=u[r]:f[r]=u[r];if(arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):t),\"function\"==typeof l&&null!=l.defaultProps)for(r in l.defaultProps)void 0===f[r]&&(f[r]=l.defaultProps[r]);return d(l,f,i,o,null)}function d(n,t,i,o,r){var f={type:n,props:t,key:i,ref:o,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,constructor:void 0,__v:null==r?++u:r,__i:-1,__u:0};return null==r&&null!=l.vnode&&l.vnode(f),f}function _(){return{current:null}}function g(n){return n.children}function b(n,l){this.props=n,this.context=l}function m(n,l){if(null==l)return n.__?m(n.__,n.__i+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return\"function\"==typeof n.type?m(n):null}function w(n,u,t){var i,o=n.__v,r=o.__e,f=n.__P;if(f)return(i=v({},o)).__v=o.__v+1,l.vnode&&l.vnode(i),M(f,i,o,n.__n,void 0!==f.ownerSVGElement,32&o.__u?[r]:null,u,null==r?m(o):r,!!(32&o.__u),t),i.__.__k[i.__i]=i,i.__d=void 0,i.__e!=r&&k(i),i}function k(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return k(n)}}function x(n){(!n.__d&&(n.__d=!0)&&i.push(n)&&!C.__r++||o!==l.debounceRendering)&&((o=l.debounceRendering)||r)(C)}function C(){var n,u,t,o=[],r=[];for(i.sort(f);n=i.shift();)n.__d&&(t=i.length,u=w(n,o,r)||u,0===t||i.length>t?(j(o,u,r),r.length=o.length=0,u=void 0,i.sort(f)):u&&l.__c&&l.__c(u,s));u&&j(o,u,r),C.__r=0}function P(n,l,u,t,i,o,r,f,e,a,h){var v,p,y,d,_,g=t&&t.__k||s,b=l.length;for(u.__d=e,S(u,l,g),e=u.__d,v=0;v<b;v++)null!=(y=u.__k[v])&&\"boolean\"!=typeof y&&\"function\"!=typeof y&&(p=-1===y.__i?c:g[y.__i]||c,y.__i=v,M(n,y,p,i,o,r,f,e,a,h),d=y.__e,y.ref&&p.ref!=y.ref&&(p.ref&&N(p.ref,null,y),h.push(y.ref,y.__c||d,y)),null==_&&null!=d&&(_=d),65536&y.__u||p.__k===y.__k?e=$(y,e,n):\"function\"==typeof y.type&&void 0!==y.__d?e=y.__d:d&&(e=d.nextSibling),y.__d=void 0,y.__u&=-196609);u.__d=e,u.__e=_}function S(n,l,u){var t,i,o,r,f,e=l.length,c=u.length,s=c,a=0;for(n.__k=[],t=0;t<e;t++)null!=(i=n.__k[t]=null==(i=l[t])||\"boolean\"==typeof i||\"function\"==typeof i?null:\"string\"==typeof i||\"number\"==typeof i||\"bigint\"==typeof i||i.constructor==String?d(null,i,null,null,i):h(i)?d(g,{children:i},null,null,null):void 0===i.constructor&&i.__b>0?d(i.type,i.props,i.key,i.ref?i.ref:null,i.__v):i)?(i.__=n,i.__b=n.__b+1,f=I(i,u,r=t+a,s),i.__i=f,o=null,-1!==f&&(s--,(o=u[f])&&(o.__u|=131072)),null==o||null===o.__v?(-1==f&&a--,\"function\"!=typeof i.type&&(i.__u|=65536)):f!==r&&(f===r+1?a++:f>r?s>e-r?a+=f-r:a--:a=f<r&&f==r-1?f-r:0,f!==t+a&&(i.__u|=65536))):(o=u[t])&&null==o.key&&o.__e&&(o.__e==n.__d&&(n.__d=m(o)),O(o,o,!1),u[t]=null,s--);if(s)for(t=0;t<c;t++)null!=(o=u[t])&&0==(131072&o.__u)&&(o.__e==n.__d&&(n.__d=m(o)),O(o,o))}function $(n,l,u){var t,i;if(\"function\"==typeof n.type){for(t=n.__k,i=0;t&&i<t.length;i++)t[i]&&(t[i].__=n,l=$(t[i],l,u));return l}n.__e!=l&&(u.insertBefore(n.__e,l||null),l=n.__e);do{l=l&&l.nextSibling}while(null!=l&&8===l.nodeType);return l}function H(n,l){return l=l||[],null==n||\"boolean\"==typeof n||(h(n)?n.some(function(n){H(n,l)}):l.push(n)),l}function I(n,l,u,t){var i=n.key,o=n.type,r=u-1,f=u+1,e=l[u];if(null===e||e&&i==e.key&&o===e.type)return u;if(t>(null!=e&&0==(131072&e.__u)?1:0))for(;r>=0||f<l.length;){if(r>=0){if((e=l[r])&&0==(131072&e.__u)&&i==e.key&&o===e.type)return r;r--}if(f<l.length){if((e=l[f])&&0==(131072&e.__u)&&i==e.key&&o===e.type)return f;f++}}return-1}function T(n,l,u){\"-\"===l[0]?n.setProperty(l,null==u?\"\":u):n[l]=null==u?\"\":\"number\"!=typeof u||a.test(l)?u:u+\"px\"}function A(n,l,u,t,i){var o;n:if(\"style\"===l)if(\"string\"==typeof u)n.style.cssText=u;else{if(\"string\"==typeof t&&(n.style.cssText=t=\"\"),t)for(l in t)u&&l in u||T(n.style,l,\"\");if(u)for(l in u)t&&u[l]===t[l]||T(n.style,l,u[l])}else if(\"o\"===l[0]&&\"n\"===l[1])o=l!==(l=l.replace(/(PointerCapture)$|Capture$/i,\"$1\")),l=l.toLowerCase()in n?l.toLowerCase().slice(2):l.slice(2),n.l||(n.l={}),n.l[l+o]=u,u?t?u.u=t.u:(u.u=Date.now(),n.addEventListener(l,o?L:D,o)):n.removeEventListener(l,o?L:D,o);else{if(i)l=l.replace(/xlink(H|:h)/,\"h\").replace(/sName$/,\"s\");else if(\"width\"!==l&&\"height\"!==l&&\"href\"!==l&&\"list\"!==l&&\"form\"!==l&&\"tabIndex\"!==l&&\"download\"!==l&&\"rowSpan\"!==l&&\"colSpan\"!==l&&\"role\"!==l&&l in n)try{n[l]=null==u?\"\":u;break n}catch(n){}\"function\"==typeof u||(null==u||!1===u&&\"-\"!==l[4]?n.removeAttribute(l):n.setAttribute(l,u))}}function D(n){if(this.l){var u=this.l[n.type+!1];if(n.t){if(n.t<=u.u)return}else n.t=Date.now();return u(l.event?l.event(n):n)}}function L(n){if(this.l)return this.l[n.type+!0](l.event?l.event(n):n)}function M(n,u,t,i,o,r,f,e,c,s){var a,p,y,d,_,m,w,k,x,C,S,$,H,I,T,A=u.type;if(void 0!==u.constructor)return null;128&t.__u&&(c=!!(32&t.__u),r=[e=u.__e=t.__e]),(a=l.__b)&&a(u);n:if(\"function\"==typeof A)try{if(k=u.props,x=(a=A.contextType)&&i[a.__c],C=a?x?x.props.value:a.__:i,t.__c?w=(p=u.__c=t.__c).__=p.__E:(\"prototype\"in A&&A.prototype.render?u.__c=p=new A(k,C):(u.__c=p=new b(k,C),p.constructor=A,p.render=q),x&&x.sub(p),p.props=k,p.state||(p.state={}),p.context=C,p.__n=i,y=p.__d=!0,p.__h=[],p._sb=[]),null==p.__s&&(p.__s=p.state),null!=A.getDerivedStateFromProps&&(p.__s==p.state&&(p.__s=v({},p.__s)),v(p.__s,A.getDerivedStateFromProps(k,p.__s))),d=p.props,_=p.state,p.__v=u,y)null==A.getDerivedStateFromProps&&null!=p.componentWillMount&&p.componentWillMount(),null!=p.componentDidMount&&p.__h.push(p.componentDidMount);else{if(null==A.getDerivedStateFromProps&&k!==d&&null!=p.componentWillReceiveProps&&p.componentWillReceiveProps(k,C),!p.__e&&(null!=p.shouldComponentUpdate&&!1===p.shouldComponentUpdate(k,p.__s,C)||u.__v===t.__v)){for(u.__v!==t.__v&&(p.props=k,p.state=p.__s,p.__d=!1),u.__e=t.__e,u.__k=t.__k,u.__k.forEach(function(n){n&&(n.__=u)}),S=0;S<p._sb.length;S++)p.__h.push(p._sb[S]);p._sb=[],p.__h.length&&f.push(p);break n}null!=p.componentWillUpdate&&p.componentWillUpdate(k,p.__s,C),null!=p.componentDidUpdate&&p.__h.push(function(){p.componentDidUpdate(d,_,m)})}if(p.context=C,p.props=k,p.__P=n,p.__e=!1,$=l.__r,H=0,\"prototype\"in A&&A.prototype.render){for(p.state=p.__s,p.__d=!1,$&&$(u),a=p.render(p.props,p.state,p.context),I=0;I<p._sb.length;I++)p.__h.push(p._sb[I]);p._sb=[]}else do{p.__d=!1,$&&$(u),a=p.render(p.props,p.state,p.context),p.state=p.__s}while(p.__d&&++H<25);p.state=p.__s,null!=p.getChildContext&&(i=v(v({},i),p.getChildContext())),y||null==p.getSnapshotBeforeUpdate||(m=p.getSnapshotBeforeUpdate(d,_)),P(n,h(T=null!=a&&a.type===g&&null==a.key?a.props.children:a)?T:[T],u,t,i,o,r,f,e,c,s),p.base=u.__e,u.__u&=-161,p.__h.length&&f.push(p),w&&(p.__E=p.__=null)}catch(n){u.__v=null,c||null!=r?(u.__e=e,u.__u|=c?160:32,r[r.indexOf(e)]=null):(u.__e=t.__e,u.__k=t.__k),l.__e(n,u,t)}else null==r&&u.__v===t.__v?(u.__k=t.__k,u.__e=t.__e):u.__e=z(t.__e,u,t,i,o,r,f,c,s);(a=l.diffed)&&a(u)}function j(n,u,t){for(var i=0;i<t.length;i++)N(t[i],t[++i],t[++i]);l.__c&&l.__c(u,n),n.some(function(u){try{n=u.__h,u.__h=[],n.some(function(n){n.call(u)})}catch(n){l.__e(n,u.__v)}})}function z(l,u,t,i,o,r,f,e,s){var a,v,y,d,_,g,b,w=t.props,k=u.props,x=u.type;if(\"svg\"===x&&(o=!0),null!=r)for(a=0;a<r.length;a++)if((_=r[a])&&\"setAttribute\"in _==!!x&&(x?_.localName===x:3===_.nodeType)){l=_,r[a]=null;break}if(null==l){if(null===x)return document.createTextNode(k);l=o?document.createElementNS(\"http://www.w3.org/2000/svg\",x):document.createElement(x,k.is&&k),r=null,e=!1}if(null===x)w===k||e&&l.data===k||(l.data=k);else{if(r=r&&n.call(l.childNodes),w=t.props||c,!e&&null!=r)for(w={},a=0;a<l.attributes.length;a++)w[(_=l.attributes[a]).name]=_.value;for(a in w)_=w[a],\"children\"==a||(\"dangerouslySetInnerHTML\"==a?y=_:\"key\"===a||a in k||A(l,a,null,_,o));for(a in k)_=k[a],\"children\"==a?d=_:\"dangerouslySetInnerHTML\"==a?v=_:\"value\"==a?g=_:\"checked\"==a?b=_:\"key\"===a||e&&\"function\"!=typeof _||w[a]===_||A(l,a,_,w[a],o);if(v)e||y&&(v.__html===y.__html||v.__html===l.innerHTML)||(l.innerHTML=v.__html),u.__k=[];else if(y&&(l.innerHTML=\"\"),P(l,h(d)?d:[d],u,t,i,o&&\"foreignObject\"!==x,r,f,r?r[0]:t.__k&&m(t,0),e,s),null!=r)for(a=r.length;a--;)null!=r[a]&&p(r[a]);e||(a=\"value\",void 0!==g&&(g!==l[a]||\"progress\"===x&&!g||\"option\"===x&&g!==w[a])&&A(l,a,g,w[a],!1),a=\"checked\",void 0!==b&&b!==l[a]&&A(l,a,b,w[a],!1))}return l}function N(n,u,t){try{\"function\"==typeof n?n(u):n.current=u}catch(n){l.__e(n,t)}}function O(n,u,t){var i,o;if(l.unmount&&l.unmount(n),(i=n.ref)&&(i.current&&i.current!==n.__e||N(i,null,u)),null!=(i=n.__c)){if(i.componentWillUnmount)try{i.componentWillUnmount()}catch(n){l.__e(n,u)}i.base=i.__P=null,n.__c=void 0}if(i=n.__k)for(o=0;o<i.length;o++)i[o]&&O(i[o],u,t||\"function\"!=typeof n.type);t||null==n.__e||p(n.__e),n.__=n.__e=n.__d=void 0}function q(n,l,u){return this.constructor(n,u)}function B(u,t,i){var o,r,f,e;l.__&&l.__(u,t),r=(o=\"function\"==typeof i)?null:i&&i.__k||t.__k,f=[],e=[],M(t,u=(!o&&i||t).__k=y(g,null,[u]),r||c,c,void 0!==t.ownerSVGElement,!o&&i?[i]:r?null:t.firstChild?n.call(t.childNodes):null,f,!o&&i?i:r?r.__e:t.firstChild,o,e),u.__d=void 0,j(f,u,e)}function E(n,l){B(n,l,E)}function F(l,u,t){var i,o,r,f,e=v({},l.props);for(r in l.type&&l.type.defaultProps&&(f=l.type.defaultProps),u)\"key\"==r?i=u[r]:\"ref\"==r?o=u[r]:e[r]=void 0===u[r]&&void 0!==f?f[r]:u[r];return arguments.length>2&&(e.children=arguments.length>3?n.call(arguments,2):t),d(l.type,e,i||l.key,o||l.ref,null)}function G(n,l){var u={__c:l=\"__cC\"+e++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var u,t;return this.getChildContext||(u=[],(t={})[l]=this,this.getChildContext=function(){return t},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(function(n){n.__e=!0,x(n)})},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u.splice(u.indexOf(n),1),l&&l.call(n)}}),n.children}};return u.Provider.__=u.Consumer.contextType=u}n=s.slice,l={__e:function(n,l,u,t){for(var i,o,r;l=l.__;)if((i=l.__c)&&!i.__)try{if((o=i.constructor)&&null!=o.getDerivedStateFromError&&(i.setState(o.getDerivedStateFromError(n)),r=i.__d),null!=i.componentDidCatch&&(i.componentDidCatch(n,t||{}),r=i.__d),r)return i.__E=i}catch(l){n=l}throw n}},u=0,t=function(n){return null!=n&&null==n.constructor},b.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=v({},this.state),\"function\"==typeof n&&(n=n(v({},u),this.props)),n&&v(u,n),null!=n&&this.__v&&(l&&this._sb.push(l),x(this))},b.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),x(this))},b.prototype.render=g,i=[],r=\"function\"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,f=function(n,l){return n.__v.__b-l.__v.__b},C.__r=0,e=0;export{b as Component,g as Fragment,F as cloneElement,G as createContext,y as createElement,_ as createRef,y as h,E as hydrate,t as isValidElement,l as options,B as render,H as toChildArray};\n//# sourceMappingURL=preact.module.js.map\n","import{options as n}from\"preact\";var t,r,u,i,o=0,f=[],c=[],e=n,a=e.__b,v=e.__r,l=e.diffed,m=e.__c,s=e.unmount,d=e.__;function h(n,t){e.__h&&e.__h(r,n,o||t),o=0;var u=r.__H||(r.__H={__:[],__h:[]});return n>=u.__.length&&u.__.push({__V:c}),u.__[n]}function p(n){return o=1,y(D,n)}function y(n,u,i){var o=h(t++,2);if(o.t=n,!o.__c&&(o.__=[i?i(u):D(void 0,u),function(n){var t=o.__N?o.__N[0]:o.__[0],r=o.t(t,n);t!==r&&(o.__N=[r,o.__[1]],o.__c.setState({}))}],o.__c=r,!r.u)){var f=function(n,t,r){if(!o.__c.__H)return!0;var u=o.__c.__H.__.filter(function(n){return!!n.__c});if(u.every(function(n){return!n.__N}))return!c||c.call(this,n,t,r);var i=!1;return u.forEach(function(n){if(n.__N){var t=n.__[0];n.__=n.__N,n.__N=void 0,t!==n.__[0]&&(i=!0)}}),!(!i&&o.__c.props===n)&&(!c||c.call(this,n,t,r))};r.u=!0;var c=r.shouldComponentUpdate,e=r.componentWillUpdate;r.componentWillUpdate=function(n,t,r){if(this.__e){var u=c;c=void 0,f(n,t,r),c=u}e&&e.call(this,n,t,r)},r.shouldComponentUpdate=f}return o.__N||o.__}function _(n,u){var i=h(t++,3);!e.__s&&C(i.__H,u)&&(i.__=n,i.i=u,r.__H.__h.push(i))}function A(n,u){var i=h(t++,4);!e.__s&&C(i.__H,u)&&(i.__=n,i.i=u,r.__h.push(i))}function F(n){return o=5,q(function(){return{current:n}},[])}function T(n,t,r){o=6,A(function(){return\"function\"==typeof n?(n(t()),function(){return n(null)}):n?(n.current=t(),function(){return n.current=null}):void 0},null==r?r:r.concat(n))}function q(n,r){var u=h(t++,7);return C(u.__H,r)?(u.__V=n(),u.i=r,u.__h=n,u.__V):u.__}function x(n,t){return o=8,q(function(){return n},t)}function P(n){var u=r.context[n.__c],i=h(t++,9);return i.c=n,u?(null==i.__&&(i.__=!0,u.sub(r)),u.props.value):n.__}function V(n,t){e.useDebugValue&&e.useDebugValue(t?t(n):n)}function b(n){var u=h(t++,10),i=p();return u.__=n,r.componentDidCatch||(r.componentDidCatch=function(n,t){u.__&&u.__(n,t),i[1](n)}),[i[0],function(){i[1](void 0)}]}function g(){var n=h(t++,11);if(!n.__){for(var u=r.__v;null!==u&&!u.__m&&null!==u.__;)u=u.__;var i=u.__m||(u.__m=[0,0]);n.__=\"P\"+i[0]+\"-\"+i[1]++}return n.__}function j(){for(var n;n=f.shift();)if(n.__P&&n.__H)try{n.__H.__h.forEach(z),n.__H.__h.forEach(B),n.__H.__h=[]}catch(t){n.__H.__h=[],e.__e(t,n.__v)}}e.__b=function(n){r=null,a&&a(n)},e.__=function(n,t){t.__k&&t.__k.__m&&(n.__m=t.__k.__m),d&&d(n,t)},e.__r=function(n){v&&v(n),t=0;var i=(r=n.__c).__H;i&&(u===r?(i.__h=[],r.__h=[],i.__.forEach(function(n){n.__N&&(n.__=n.__N),n.__V=c,n.__N=n.i=void 0})):(i.__h.forEach(z),i.__h.forEach(B),i.__h=[],t=0)),u=r},e.diffed=function(n){l&&l(n);var t=n.__c;t&&t.__H&&(t.__H.__h.length&&(1!==f.push(t)&&i===e.requestAnimationFrame||((i=e.requestAnimationFrame)||w)(j)),t.__H.__.forEach(function(n){n.i&&(n.__H=n.i),n.__V!==c&&(n.__=n.__V),n.i=void 0,n.__V=c})),u=r=null},e.__c=function(n,t){t.some(function(n){try{n.__h.forEach(z),n.__h=n.__h.filter(function(n){return!n.__||B(n)})}catch(r){t.some(function(n){n.__h&&(n.__h=[])}),t=[],e.__e(r,n.__v)}}),m&&m(n,t)},e.unmount=function(n){s&&s(n);var t,r=n.__c;r&&r.__H&&(r.__H.__.forEach(function(n){try{z(n)}catch(n){t=n}}),r.__H=void 0,t&&e.__e(t,r.__v))};var k=\"function\"==typeof requestAnimationFrame;function w(n){var t,r=function(){clearTimeout(u),k&&cancelAnimationFrame(t),setTimeout(n)},u=setTimeout(r,100);k&&(t=requestAnimationFrame(r))}function z(n){var t=r,u=n.__c;\"function\"==typeof u&&(n.__c=void 0,u()),r=t}function B(n){var t=r;n.__c=n.__(),r=t}function C(n,t){return!n||n.length!==t.length||t.some(function(t,r){return t!==n[r]})}function D(n,t){return\"function\"==typeof t?t(n):t}export{x as useCallback,P as useContext,V as useDebugValue,_ as useEffect,b as useErrorBoundary,g as useId,T as useImperativeHandle,A as useLayoutEffect,q as useMemo,y as useReducer,F as useRef,p as useState};\n//# sourceMappingURL=hooks.module.js.map\n","import { DOCUMENT } from '../../constants';\nimport { setAttributesNS } from '../../util/setAttributesNS';\n\nconst XMLNS = 'http://www.w3.org/2000/svg';\n\n/**\n * Sentry Logo\n */\nexport function SentryLogo(): SVGElement {\n  const createElementNS = <K extends keyof SVGElementTagNameMap>(tagName: K): SVGElementTagNameMap[K] =>\n    DOCUMENT.createElementNS(XMLNS, tagName);\n  const svg = setAttributesNS(createElementNS('svg'), {\n    width: '32',\n    height: '30',\n    viewBox: '0 0 72 66',\n    fill: 'inherit',\n  });\n\n  const path = setAttributesNS(createElementNS('path'), {\n    transform: 'translate(11, 11)',\n    d: 'M29,2.26a4.67,4.67,0,0,0-8,0L14.42,13.53A32.21,32.21,0,0,1,32.17,40.19H27.55A27.68,27.68,0,0,0,12.09,17.47L6,28a15.92,15.92,0,0,1,9.23,12.17H4.62A.76.76,0,0,1,4,39.06l2.94-5a10.74,10.74,0,0,0-3.36-1.9l-2.91,5a4.54,4.54,0,0,0,1.69,6.24A4.66,4.66,0,0,0,4.62,44H19.15a19.4,19.4,0,0,0-8-17.31l2.31-4A23.87,23.87,0,0,1,23.76,44H36.07a35.88,35.88,0,0,0-16.41-31.8l4.67-8a.77.77,0,0,1,1.05-.27c.53.29,20.29,34.77,20.66,35.17a.76.76,0,0,1-.68,1.13H40.6q.09,1.91,0,3.81h4.78A4.59,4.59,0,0,0,50,39.43a4.49,4.49,0,0,0-.62-2.28Z',\n  });\n  svg.appendChild(path);\n\n  return svg;\n}\n","import type { FeedbackInternalOptions } from '@sentry/core';\nimport type { VNode } from 'preact';\nimport { h } from 'preact'; // eslint-disable-line @typescript-eslint/no-unused-vars\nimport { useMemo } from 'preact/hooks';\nimport { SentryLogo } from './SentryLogo';\n\nexport interface Props {\n  options: FeedbackInternalOptions;\n}\n\nexport function DialogHeader({ options }: Props): VNode {\n  const logoHtml = useMemo(() => ({ __html: SentryLogo().outerHTML }), []);\n\n  return (\n    <h2 class=\"dialog__header\">\n      <span class=\"dialog__title\">{options.formTitle}</span>\n      {options.showBranding ? (\n        <a\n          class=\"brand-link\"\n          target=\"_blank\"\n          href=\"https://sentry.io/welcome/\"\n          title=\"Powered by Sentry\"\n          rel=\"noopener noreferrer\"\n          dangerouslySetInnerHTML={logoHtml}\n        />\n      ) : null}\n    </h2>\n  );\n}\n","import type { FeedbackFormData, FeedbackInternalOptions } from '@sentry/core';\n\nexport type Props = Pick<\n  FeedbackInternalOptions,\n  'emailLabel' | 'isEmailRequired' | 'isNameRequired' | 'messageLabel' | 'nameLabel'\n>;\n\n/**\n * Validate that a given feedback submission has the required fields\n */\nexport function getMissingFields(feedback: FeedbackFormData, props: Props): string[] {\n  const emptyFields = [];\n  if (props.isNameRequired && !feedback.name) {\n    emptyFields.push(props.nameLabel);\n  }\n  if (props.isEmailRequired && !feedback.email) {\n    emptyFields.push(props.emailLabel);\n  }\n  if (!feedback.message) {\n    emptyFields.push(props.messageLabel);\n  }\n\n  return emptyFields;\n}\n","import type {\n  FeedbackFormData,\n  FeedbackInternalOptions,\n  FeedbackScreenshotIntegration,\n  SendFeedback,\n} from '@sentry/core';\nimport { debug } from '@sentry/core';\nimport type { JSX, VNode } from 'preact';\nimport { h } from 'preact'; // eslint-disable-line @typescript-eslint/no-unused-vars\nimport { useCallback, useState } from 'preact/hooks';\nimport { FEEDBACK_WIDGET_SOURCE } from '../../constants';\nimport { DEBUG_BUILD } from '../../util/debug-build';\nimport { getMissingFields } from '../../util/validate';\n\nexport interface Props extends Pick<FeedbackInternalOptions, 'showEmail' | 'showName'> {\n  options: FeedbackInternalOptions;\n  defaultEmail: string;\n  defaultName: string;\n  onFormClose: () => void;\n  onSubmit: SendFeedback;\n  onSubmitSuccess: (data: FeedbackFormData, eventId: string) => void;\n  onSubmitError: (error: Error) => void;\n  screenshotInput: ReturnType<FeedbackScreenshotIntegration['createInput']> | undefined;\n}\n\nfunction retrieveStringValue(formData: FormData, key: string): string {\n  const value = formData.get(key);\n  if (typeof value === 'string') {\n    return value.trim();\n  }\n  return '';\n}\n\nexport function Form({\n  options,\n  defaultEmail,\n  defaultName,\n\n  onFormClose,\n  onSubmit,\n  onSubmitSuccess,\n  onSubmitError,\n  showEmail,\n  showName,\n  screenshotInput,\n}: Props): VNode {\n  const {\n    tags,\n    addScreenshotButtonLabel,\n    removeScreenshotButtonLabel,\n    cancelButtonLabel,\n    emailLabel,\n    emailPlaceholder,\n    isEmailRequired,\n    isNameRequired,\n    messageLabel,\n    messagePlaceholder,\n    nameLabel,\n    namePlaceholder,\n    submitButtonLabel,\n    isRequiredLabel,\n  } = options;\n  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);\n  // TODO: set a ref on the form, and whenever an input changes call processForm() and setError()\n  const [error, setError] = useState<null | string>(null);\n\n  const [showScreenshotInput, setShowScreenshotInput] = useState(false);\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const ScreenshotInputComponent: any = screenshotInput?.input;\n\n  const [screenshotError, setScreenshotError] = useState<null | Error>(null);\n  const onScreenshotError = useCallback((error: Error) => {\n    setScreenshotError(error);\n    setShowScreenshotInput(false);\n  }, []);\n\n  const hasAllRequiredFields = useCallback(\n    (data: FeedbackFormData) => {\n      const missingFields = getMissingFields(data, {\n        emailLabel,\n        isEmailRequired,\n        isNameRequired,\n        messageLabel,\n        nameLabel,\n      });\n\n      if (missingFields.length > 0) {\n        setError(`Please enter in the following required fields: ${missingFields.join(', ')}`);\n      } else {\n        setError(null);\n      }\n\n      return missingFields.length === 0;\n    },\n    [emailLabel, isEmailRequired, isNameRequired, messageLabel, nameLabel],\n  );\n\n  const handleSubmit = useCallback(\n    async (e: JSX.TargetedSubmitEvent<HTMLFormElement>) => {\n      setIsSubmitting(true);\n      try {\n        e.preventDefault();\n        if (!(e.target instanceof HTMLFormElement)) {\n          return;\n        }\n        const formData = new FormData(e.target);\n        const attachment = await (screenshotInput && showScreenshotInput ? screenshotInput.value() : undefined);\n\n        const data: FeedbackFormData = {\n          name: retrieveStringValue(formData, 'name'),\n          email: retrieveStringValue(formData, 'email'),\n          message: retrieveStringValue(formData, 'message'),\n          attachments: attachment ? [attachment] : undefined,\n        };\n\n        if (!hasAllRequiredFields(data)) {\n          return;\n        }\n\n        try {\n          const eventId = await onSubmit(\n            {\n              name: data.name,\n              email: data.email,\n              message: data.message,\n              source: FEEDBACK_WIDGET_SOURCE,\n              tags,\n            },\n            { attachments: data.attachments },\n          );\n          onSubmitSuccess(data, eventId);\n        } catch (error) {\n          DEBUG_BUILD && debug.error(error);\n          setError(error as string);\n          onSubmitError(error as Error);\n        }\n      } finally {\n        setIsSubmitting(false);\n      }\n    },\n    [screenshotInput && showScreenshotInput, onSubmitSuccess, onSubmitError],\n  );\n\n  return (\n    <form class=\"form\" onSubmit={handleSubmit}>\n      {ScreenshotInputComponent && showScreenshotInput ? (\n        <ScreenshotInputComponent onError={onScreenshotError} />\n      ) : null}\n\n      <fieldset class=\"form__right\" data-sentry-feedback={true} disabled={isSubmitting}>\n        <div class=\"form__top\">\n          {error ? <div class=\"form__error-container\">{error}</div> : null}\n\n          {showName ? (\n            <label for=\"name\" class=\"form__label\">\n              <LabelText label={nameLabel} isRequiredLabel={isRequiredLabel} isRequired={isNameRequired} />\n              <input\n                class=\"form__input\"\n                defaultValue={defaultName}\n                id=\"name\"\n                name=\"name\"\n                placeholder={namePlaceholder}\n                required={isNameRequired}\n                type=\"text\"\n              />\n            </label>\n          ) : (\n            <input aria-hidden value={defaultName} name=\"name\" type=\"hidden\" />\n          )}\n\n          {showEmail ? (\n            <label for=\"email\" class=\"form__label\">\n              <LabelText label={emailLabel} isRequiredLabel={isRequiredLabel} isRequired={isEmailRequired} />\n              <input\n                class=\"form__input\"\n                defaultValue={defaultEmail}\n                id=\"email\"\n                name=\"email\"\n                placeholder={emailPlaceholder}\n                required={isEmailRequired}\n                type=\"email\"\n              ></input>\n            </label>\n          ) : (\n            <input aria-hidden value={defaultEmail} name=\"email\" type=\"hidden\" />\n          )}\n\n          <label for=\"message\" class=\"form__label\">\n            <LabelText label={messageLabel} isRequiredLabel={isRequiredLabel} isRequired />\n            <textarea\n              autoFocus\n              class=\"form__input form__input--textarea\"\n              id=\"message\"\n              name=\"message\"\n              placeholder={messagePlaceholder}\n              required={true}\n              rows={5}\n            />\n          </label>\n\n          {ScreenshotInputComponent ? (\n            <label for=\"screenshot\" class=\"form__label\">\n              <button\n                class=\"btn btn--default\"\n                disabled={isSubmitting}\n                type=\"button\"\n                onClick={() => {\n                  setScreenshotError(null);\n                  setShowScreenshotInput(prev => !prev);\n                }}\n              >\n                {showScreenshotInput ? removeScreenshotButtonLabel : addScreenshotButtonLabel}\n              </button>\n              {screenshotError ? <div class=\"form__error-container\">{screenshotError.message}</div> : null}\n            </label>\n          ) : null}\n        </div>\n        <div class=\"btn-group\">\n          <button class=\"btn btn--primary\" disabled={isSubmitting} type=\"submit\">\n            {submitButtonLabel}\n          </button>\n          <button class=\"btn btn--default\" disabled={isSubmitting} type=\"button\" onClick={onFormClose}>\n            {cancelButtonLabel}\n          </button>\n        </div>\n      </fieldset>\n    </form>\n  );\n}\n\nfunction LabelText({\n  label,\n  isRequired,\n  isRequiredLabel,\n}: {\n  label: string;\n  isRequired: boolean;\n  isRequiredLabel: string;\n}): VNode {\n  return (\n    <span class=\"form__label__text\">\n      {label}\n      {isRequired && <span class=\"form__label__text--required\">{isRequiredLabel}</span>}\n    </span>\n  );\n}\n","import { WINDOW } from '../../constants';\nimport { setAttributesNS } from '../../util/setAttributesNS';\n\nconst WIDTH = 16;\nconst HEIGHT = 17;\nconst XMLNS = 'http://www.w3.org/2000/svg';\n\n/**\n * Success Icon (checkmark)\n */\nexport function SuccessIcon(): SVGElement {\n  const createElementNS = <K extends keyof SVGElementTagNameMap>(tagName: K): SVGElementTagNameMap[K] =>\n    WINDOW.document.createElementNS(XMLNS, tagName);\n  const svg = setAttributesNS(createElementNS('svg'), {\n    width: `${WIDTH}`,\n    height: `${HEIGHT}`,\n    viewBox: `0 0 ${WIDTH} ${HEIGHT}`,\n    fill: 'inherit',\n  });\n\n  const g = setAttributesNS(createElementNS('g'), {\n    clipPath: 'url(#clip0_57_156)',\n  });\n\n  const path2 = setAttributesNS(createElementNS('path'), {\n    ['fill-rule']: 'evenodd',\n    ['clip-rule']: 'evenodd',\n    d: 'M3.55544 15.1518C4.87103 16.0308 6.41775 16.5 8 16.5C10.1217 16.5 12.1566 15.6571 13.6569 14.1569C15.1571 12.6566 16 10.6217 16 8.5C16 6.91775 15.5308 5.37103 14.6518 4.05544C13.7727 2.73985 12.5233 1.71447 11.0615 1.10897C9.59966 0.503466 7.99113 0.34504 6.43928 0.653721C4.88743 0.962403 3.46197 1.72433 2.34315 2.84315C1.22433 3.96197 0.462403 5.38743 0.153721 6.93928C-0.15496 8.49113 0.00346625 10.0997 0.608967 11.5615C1.21447 13.0233 2.23985 14.2727 3.55544 15.1518ZM4.40546 3.1204C5.46945 2.40946 6.72036 2.03 8 2.03C9.71595 2.03 11.3616 2.71166 12.575 3.92502C13.7883 5.13838 14.47 6.78405 14.47 8.5C14.47 9.77965 14.0905 11.0306 13.3796 12.0945C12.6687 13.1585 11.6582 13.9878 10.476 14.4775C9.29373 14.9672 7.99283 15.0953 6.73777 14.8457C5.48271 14.596 4.32987 13.9798 3.42502 13.075C2.52018 12.1701 1.90397 11.0173 1.65432 9.76224C1.40468 8.50718 1.5328 7.20628 2.0225 6.02404C2.5122 4.8418 3.34148 3.83133 4.40546 3.1204Z',\n  });\n  const path = setAttributesNS(createElementNS('path'), {\n    d: 'M6.68775 12.4297C6.78586 12.4745 6.89218 12.4984 7 12.5C7.11275 12.4955 7.22315 12.4664 7.32337 12.4145C7.4236 12.3627 7.51121 12.2894 7.58 12.2L12 5.63999C12.0848 5.47724 12.1071 5.28902 12.0625 5.11098C12.0178 4.93294 11.9095 4.77744 11.7579 4.67392C11.6064 4.57041 11.4221 4.52608 11.24 4.54931C11.0579 4.57254 10.8907 4.66173 10.77 4.79999L6.88 10.57L5.13 8.56999C5.06508 8.49566 4.98613 8.43488 4.89768 8.39111C4.80922 8.34735 4.713 8.32148 4.61453 8.31498C4.51605 8.30847 4.41727 8.32147 4.32382 8.35322C4.23038 8.38497 4.14413 8.43484 4.07 8.49999C3.92511 8.63217 3.83692 8.81523 3.82387 9.01092C3.81083 9.2066 3.87393 9.39976 4 9.54999L6.43 12.24C6.50187 12.3204 6.58964 12.385 6.68775 12.4297Z',\n  });\n\n  svg.appendChild(g).append(path, path2);\n\n  const speakerDefs = createElementNS('defs');\n  const speakerClipPathDef = setAttributesNS(createElementNS('clipPath'), {\n    id: 'clip0_57_156',\n  });\n\n  const speakerRect = setAttributesNS(createElementNS('rect'), {\n    width: `${WIDTH}`,\n    height: `${WIDTH}`,\n    fill: 'white',\n    transform: 'translate(0 0.5)',\n  });\n\n  speakerClipPathDef.appendChild(speakerRect);\n  speakerDefs.appendChild(speakerClipPathDef);\n\n  svg.appendChild(speakerDefs).appendChild(speakerClipPathDef).appendChild(speakerRect);\n\n  return svg;\n}\n","import type { FeedbackFormData, FeedbackInternalOptions } from '@sentry/core';\nimport type { VNode } from 'preact';\nimport { Fragment, h } from 'preact'; // eslint-disable-line @typescript-eslint/no-unused-vars\nimport { useCallback, useMemo, useState } from 'preact/hooks';\nimport { SUCCESS_MESSAGE_TIMEOUT } from '../../constants';\nimport type { Props as HeaderProps } from './DialogHeader';\nimport { DialogHeader } from './DialogHeader';\nimport type { Props as FormProps } from './Form';\nimport { Form } from './Form';\nimport { SuccessIcon } from './SuccessIcon';\n\ninterface Props extends HeaderProps, FormProps {\n  onFormSubmitted: () => void;\n  open: boolean;\n  options: FeedbackInternalOptions;\n}\n\nexport function Dialog({ open, onFormSubmitted, ...props }: Props): VNode {\n  const options = props.options;\n  const successIconHtml = useMemo(() => ({ __html: SuccessIcon().outerHTML }), []);\n\n  const [timeoutId, setTimeoutId] = useState<NodeJS.Timeout | null>(null);\n\n  const handleOnSuccessClick = useCallback(() => {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n      setTimeoutId(null);\n    }\n    onFormSubmitted();\n  }, [timeoutId]);\n\n  const onSubmitSuccess = useCallback(\n    (data: FeedbackFormData, eventId: string) => {\n      props.onSubmitSuccess(data, eventId);\n      setTimeoutId(\n        setTimeout(() => {\n          onFormSubmitted();\n          setTimeoutId(null);\n        }, SUCCESS_MESSAGE_TIMEOUT),\n      );\n    },\n    [onFormSubmitted],\n  );\n\n  return (\n    <Fragment>\n      {timeoutId ? (\n        <div class=\"success__position\" onClick={handleOnSuccessClick}>\n          <div class=\"success__content\">\n            {options.successMessageText}\n            <span class=\"success__icon\" dangerouslySetInnerHTML={successIconHtml} />\n          </div>\n        </div>\n      ) : (\n        <dialog class=\"dialog\" onClick={options.onFormClose} open={open}>\n          <div class=\"dialog__position\">\n            <div\n              class=\"dialog__content\"\n              onClick={e => {\n                // Stop event propagation so clicks on content modal do not propagate to dialog (which will close dialog)\n                e.stopPropagation();\n              }}\n            >\n              <DialogHeader options={options} />\n              <Form {...props} onSubmitSuccess={onSubmitSuccess} />\n            </div>\n          </div>\n        </dialog>\n      )}\n    </Fragment>\n  );\n}\n","import { DOCUMENT } from '../../constants';\n\nconst DIALOG = `\n.dialog {\n  position: fixed;\n  z-index: var(--z-index);\n  margin: 0;\n  inset: 0;\n\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  padding: 0;\n  height: 100vh;\n  width: 100vw;\n\n  color: var(--dialog-color, var(--foreground));\n  fill: var(--dialog-color, var(--foreground));\n  line-height: 1.75em;\n\n  background-color: rgba(0, 0, 0, 0.05);\n  border: none;\n  inset: 0;\n  opacity: 1;\n  transition: opacity 0.2s ease-in-out;\n}\n\n.dialog__position {\n  position: fixed;\n  z-index: var(--z-index);\n  inset: var(--dialog-inset);\n  padding: var(--page-margin);\n  display: flex;\n  max-height: calc(100vh - (2 * var(--page-margin)));\n}\n@media (max-width: 600px) {\n  .dialog__position {\n    inset: var(--page-margin);\n    padding: 0;\n  }\n}\n\n.dialog__position:has(.editor) {\n  inset: var(--page-margin);\n  padding: 0;\n}\n\n.dialog:not([open]) {\n  opacity: 0;\n  pointer-events: none;\n  visibility: hidden;\n}\n.dialog:not([open]) .dialog__content {\n  transform: translate(0, -16px) scale(0.98);\n}\n\n.dialog__content {\n  display: flex;\n  flex-direction: column;\n  gap: 16px;\n  padding: var(--dialog-padding, 24px);\n  max-width: 100%;\n  width: 100%;\n  max-height: 100%;\n  overflow: auto;\n\n  background: var(--dialog-background, var(--background));\n  border-radius: var(--dialog-border-radius, 20px);\n  border: var(--dialog-border, var(--border));\n  box-shadow: var(--dialog-box-shadow, var(--box-shadow));\n  transform: translate(0, 0) scale(1);\n  transition: transform 0.2s ease-in-out;\n}\n\n`;\n\nconst DIALOG_HEADER = `\n.dialog__header {\n  display: flex;\n  gap: 4px;\n  justify-content: space-between;\n  font-weight: var(--dialog-header-weight, 600);\n  margin: 0;\n}\n.dialog__title {\n  align-self: center;\n  width: var(--form-width, 272px);\n}\n\n@media (max-width: 600px) {\n  .dialog__title {\n    width: auto;\n  }\n}\n\n.dialog__position:has(.editor) .dialog__title {\n  width: auto;\n}\n\n\n.brand-link {\n  display: inline-flex;\n}\n.brand-link:focus-visible {\n  outline: var(--outline);\n}\n`;\n\nconst FORM = `\n.form {\n  display: flex;\n  overflow: auto;\n  flex-direction: row;\n  gap: 16px;\n  flex: 1 0;\n}\n\n.form fieldset {\n  border: none;\n  margin: 0;\n  padding: 0;\n}\n\n.form__right {\n  flex: 0 0 auto;\n  display: flex;\n  overflow: auto;\n  flex-direction: column;\n  justify-content: space-between;\n  gap: 20px;\n  width: var(--form-width, 100%);\n}\n\n.dialog__position:has(.editor) .form__right {\n  width: var(--form-width, 272px);\n}\n\n.form__top {\n  display: flex;\n  flex-direction: column;\n  gap: 8px;\n}\n\n.form__error-container {\n  color: var(--error-color);\n  fill: var(--error-color);\n}\n\n.form__label {\n  display: flex;\n  flex-direction: column;\n  gap: 4px;\n  margin: 0px;\n}\n\n.form__label__text {\n  display: flex;\n  gap: 4px;\n  align-items: center;\n}\n\n.form__label__text--required {\n  font-size: 0.85em;\n}\n\n.form__input {\n  font-family: inherit;\n  line-height: inherit;\n  background: transparent;\n  box-sizing: border-box;\n  border: var(--input-border, var(--border));\n  border-radius: var(--input-border-radius, 6px);\n  color: var(--input-color, inherit);\n  fill: var(--input-color, inherit);\n  font-size: var(--input-font-size, inherit);\n  font-weight: var(--input-font-weight, 500);\n  padding: 6px 12px;\n}\n\n.form__input::placeholder {\n  opacity: 0.65;\n  color: var(--input-placeholder-color, inherit);\n  filter: var(--interactive-filter);\n}\n\n.form__input:focus-visible {\n  outline: var(--input-focus-outline, var(--outline));\n}\n\n.form__input--textarea {\n  font-family: inherit;\n  resize: vertical;\n}\n\n.error {\n  color: var(--error-color);\n  fill: var(--error-color);\n}\n`;\n\nconst BUTTON = `\n.btn-group {\n  display: grid;\n  gap: 8px;\n}\n\n.btn {\n  line-height: inherit;\n  border: var(--button-border, var(--border));\n  border-radius: var(--button-border-radius, 6px);\n  cursor: pointer;\n  font-family: inherit;\n  font-size: var(--button-font-size, inherit);\n  font-weight: var(--button-font-weight, 600);\n  padding: var(--button-padding, 6px 16px);\n}\n.btn[disabled] {\n  opacity: 0.6;\n  pointer-events: none;\n}\n\n.btn--primary {\n  color: var(--button-primary-color, var(--accent-foreground));\n  fill: var(--button-primary-color, var(--accent-foreground));\n  background: var(--button-primary-background, var(--accent-background));\n  border: var(--button-primary-border, var(--border));\n  border-radius: var(--button-primary-border-radius, 6px);\n  font-weight: var(--button-primary-font-weight, 500);\n}\n.btn--primary:hover {\n  color: var(--button-primary-hover-color, var(--accent-foreground));\n  fill: var(--button-primary-hover-color, var(--accent-foreground));\n  background: var(--button-primary-hover-background, var(--accent-background));\n  filter: var(--interactive-filter);\n}\n.btn--primary:focus-visible {\n  background: var(--button-primary-hover-background, var(--accent-background));\n  filter: var(--interactive-filter);\n  outline: var(--button-primary-focus-outline, var(--outline));\n}\n\n.btn--default {\n  color: var(--button-color, var(--foreground));\n  fill: var(--button-color, var(--foreground));\n  background: var(--button-background, var(--background));\n  border: var(--button-border, var(--border));\n  border-radius: var(--button-border-radius, 6px);\n  font-weight: var(--button-font-weight, 500);\n}\n.btn--default:hover {\n  color: var(--button-color, var(--foreground));\n  fill: var(--button-color, var(--foreground));\n  background: var(--button-hover-background, var(--background));\n  filter: var(--interactive-filter);\n}\n.btn--default:focus-visible {\n  background: var(--button-hover-background, var(--background));\n  filter: var(--interactive-filter);\n  outline: var(--button-focus-outline, var(--outline));\n}\n`;\n\nconst SUCCESS = `\n.success__position {\n  position: fixed;\n  inset: var(--dialog-inset);\n  padding: var(--page-margin);\n  z-index: var(--z-index);\n}\n.success__content {\n  background: var(--success-background, var(--background));\n  border: var(--success-border, var(--border));\n  border-radius: var(--success-border-radius, 1.7em/50%);\n  box-shadow: var(--success-box-shadow, var(--box-shadow));\n  font-weight: var(--success-font-weight, 600);\n  color: var(--success-color);\n  fill: var(--success-color);\n  padding: 12px 24px;\n  line-height: 1.75em;\n\n  display: grid;\n  align-items: center;\n  grid-auto-flow: column;\n  gap: 6px;\n  cursor: default;\n}\n\n.success__icon {\n  display: flex;\n}\n`;\n\n/**\n * Creates <style> element for widget dialog\n */\nexport function createDialogStyles(styleNonce?: string): HTMLStyleElement {\n  const style = DOCUMENT.createElement('style');\n\n  style.textContent = `\n:host {\n  --dialog-inset: var(--inset);\n}\n\n${DIALOG}\n${DIALOG_HEADER}\n${FORM}\n${BUTTON}\n${SUCCESS}\n`;\n\n  if (styleNonce) {\n    style.setAttribute('nonce', styleNonce);\n  }\n\n  return style;\n}\n","import type { FeedbackFormData, FeedbackModalIntegration, IntegrationFn, User } from '@sentry/core';\nimport { getClient, getCurrentScope, getGlobalScope, getIsolationScope } from '@sentry/core';\nimport { h, render } from 'preact';\nimport * as hooks from 'preact/hooks';\nimport { DOCUMENT } from '../constants';\nimport { Dialog } from './components/Dialog';\nimport { createDialogStyles } from './components/Dialog.css';\n\nfunction getUser(): User | undefined {\n  const currentUser = getCurrentScope().getUser();\n  const isolationUser = getIsolationScope().getUser();\n  const globalUser = getGlobalScope().getUser();\n  if (currentUser && Object.keys(currentUser).length) {\n    return currentUser;\n  }\n  if (isolationUser && Object.keys(isolationUser).length) {\n    return isolationUser;\n  }\n  return globalUser;\n}\n\nexport const feedbackModalIntegration = ((): FeedbackModalIntegration => {\n  return {\n    name: 'FeedbackModal',\n    setupOnce() {},\n    createDialog: ({ options, screenshotIntegration, sendFeedback, shadow }) => {\n      const shadowRoot = shadow as ShadowRoot;\n      const userKey = options.useSentryUser;\n      const user = getUser();\n\n      const el = DOCUMENT.createElement('div');\n      const style = createDialogStyles(options.styleNonce);\n\n      let originalOverflow = '';\n      const dialog: ReturnType<FeedbackModalIntegration['createDialog']> = {\n        get el() {\n          return el;\n        },\n        appendToDom(): void {\n          if (!shadowRoot.contains(style) && !shadowRoot.contains(el)) {\n            shadowRoot.appendChild(style);\n            shadowRoot.appendChild(el);\n          }\n        },\n        removeFromDom(): void {\n          el.remove();\n          style.remove();\n          DOCUMENT.body.style.overflow = originalOverflow;\n        },\n        open() {\n          renderContent(true);\n          options.onFormOpen?.();\n          getClient()?.emit('openFeedbackWidget');\n          originalOverflow = DOCUMENT.body.style.overflow;\n          DOCUMENT.body.style.overflow = 'hidden';\n        },\n        close() {\n          renderContent(false);\n          DOCUMENT.body.style.overflow = originalOverflow;\n        },\n      };\n\n      const screenshotInput = screenshotIntegration?.createInput({ h, hooks, dialog, options });\n\n      const renderContent = (open: boolean): void => {\n        render(\n          <Dialog\n            options={options}\n            screenshotInput={screenshotInput}\n            showName={options.showName || options.isNameRequired}\n            showEmail={options.showEmail || options.isEmailRequired}\n            defaultName={(userKey && user?.[userKey.name]) || ''}\n            defaultEmail={(userKey && user?.[userKey.email]) || ''}\n            onFormClose={() => {\n              renderContent(false);\n              options.onFormClose?.();\n            }}\n            onSubmit={sendFeedback}\n            onSubmitSuccess={(data: FeedbackFormData, eventId: string) => {\n              renderContent(false);\n              options.onSubmitSuccess?.(data, eventId);\n            }}\n            onSubmitError={(error: Error) => {\n              options.onSubmitError?.(error);\n            }}\n            onFormSubmitted={() => {\n              options.onFormSubmitted?.();\n            }}\n            open={open}\n          />,\n          el,\n        );\n      };\n\n      return dialog;\n    },\n  };\n}) satisfies IntegrationFn;\n","import type { h as hType, VNode } from 'preact';\n\ninterface FactoryParams {\n  h: typeof hType;\n}\n\nexport default function IconCloseFactory({\n  h, // eslint-disable-line @typescript-eslint/no-unused-vars\n}: FactoryParams) {\n  return function IconClose(): VNode {\n    return (\n      <svg data-test-id=\"icon-close\" viewBox=\"0 0 16 16\" fill=\"#2B2233\" height=\"25px\" width=\"25px\">\n        <circle r=\"7\" cx=\"8\" cy=\"8\" fill=\"white\" />\n        <path\n          strokeWidth=\"1.5\"\n          d=\"M8,16a8,8,0,1,1,8-8A8,8,0,0,1,8,16ZM8,1.53A6.47,6.47,0,1,0,14.47,8,6.47,6.47,0,0,0,8,1.53Z\"\n        ></path>\n        <path\n          strokeWidth=\"1.5\"\n          d=\"M5.34,11.41a.71.71,0,0,1-.53-.22.74.74,0,0,1,0-1.06l5.32-5.32a.75.75,0,0,1,1.06,1.06L5.87,11.19A.74.74,0,0,1,5.34,11.41Z\"\n        ></path>\n        <path\n          strokeWidth=\"1.5\"\n          d=\"M10.66,11.41a.74.74,0,0,1-.53-.22L4.81,5.87A.75.75,0,0,1,5.87,4.81l5.32,5.32a.74.74,0,0,1,0,1.06A.71.71,0,0,1,10.66,11.41Z\"\n        ></path>\n      </svg>\n    );\n  };\n}\n","import { DOCUMENT } from '../../constants';\n\n/**\n * Creates <style> element for widget dialog\n */\nexport function createScreenshotInputStyles(styleNonce?: string): HTMLStyleElement {\n  const style = DOCUMENT.createElement('style');\n\n  const surface200 = '#1A141F';\n  const gray100 = '#302735';\n\n  style.textContent = `\n.editor {\n  display: flex;\n  flex-grow: 1;\n  flex-direction: column;\n}\n\n.editor__image-container {\n  justify-items: center;\n  padding: 15px;\n  position: relative;\n  height: 100%;\n  border-radius: var(--menu-border-radius, 6px);\n\n  background-color: ${surface200};\n  background-image: repeating-linear-gradient(\n      -145deg,\n      transparent,\n      transparent 8px,\n      ${surface200} 8px,\n      ${surface200} 11px\n    ),\n    repeating-linear-gradient(\n      -45deg,\n      transparent,\n      transparent 15px,\n      ${gray100} 15px,\n      ${gray100} 16px\n    );\n}\n\n.editor__canvas-container {\n  width: 100%;\n  height: 100%;\n  position: relative;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.editor__canvas-container > * {\n  object-fit: contain;\n  position: absolute;\n}\n\n.editor__tool-container {\n  padding-top: 8px;\n  display: flex;\n  justify-content: center;\n}\n\n.editor__tool-bar {\n  display: flex;\n  gap: 8px;\n}\n\n.editor__tool {\n  display: flex;\n  padding: 8px 12px;\n  justify-content: center;\n  align-items: center;\n  border: var(--button-border, var(--border));\n  border-radius: var(--button-border-radius, 6px);\n  background: var(--button-background, var(--background));\n  color: var(--button-color, var(--foreground));\n}\n\n.editor__tool--active {\n  background: var(--button-primary-background, var(--accent-background));\n  color: var(--button-primary-color, var(--accent-foreground));\n}\n\n.editor__rect {\n  position: absolute;\n  z-index: 2;\n}\n\n.editor__rect button {\n  opacity: 0;\n  position: absolute;\n  top: -12px;\n  right: -12px;\n  cursor: pointer;\n  padding: 0;\n  z-index: 3;\n  border: none;\n  background: none;\n}\n\n.editor__rect:hover button {\n  opacity: 1;\n}\n`;\n\n  if (styleNonce) {\n    style.setAttribute('nonce', styleNonce);\n  }\n\n  return style;\n}\n","import type { FeedbackInternalOptions } from '@sentry/core';\nimport type { h as hType, VNode } from 'preact';\nimport type * as Hooks from 'preact/hooks';\n\ninterface FactoryParams {\n  h: typeof hType;\n}\n\nexport default function ToolbarFactory({\n  h, // eslint-disable-line @typescript-eslint/no-unused-vars\n}: FactoryParams) {\n  return function Toolbar({\n    action,\n    setAction,\n    options,\n  }: {\n    action: 'highlight' | 'hide' | '';\n    setAction: Hooks.StateUpdater<'highlight' | 'hide' | ''>;\n    options: FeedbackInternalOptions;\n  }): VNode {\n    return (\n      <div class=\"editor__tool-container\">\n        <div class=\"editor__tool-bar\">\n          <button\n            type=\"button\"\n            class={`editor__tool ${action === 'highlight' ? 'editor__tool--active' : ''}`}\n            onClick={() => {\n              setAction(action === 'highlight' ? '' : 'highlight');\n            }}\n          >\n            {options.highlightToolText}\n          </button>\n          <button\n            type=\"button\"\n            class={`editor__tool ${action === 'hide' ? 'editor__tool--active' : ''}`}\n            onClick={() => {\n              setAction(action === 'hide' ? '' : 'hide');\n            }}\n          >\n            {options.hideToolText}\n          </button>\n        </div>\n      </div>\n    );\n  };\n}\n","import type * as Hooks from 'preact/hooks';\nimport { DOCUMENT, NAVIGATOR, WINDOW } from '../../constants';\n\ninterface FactoryParams {\n  hooks: typeof Hooks;\n}\n\ninterface Props {\n  onBeforeScreenshot: () => void;\n  onScreenshot: (imageSource: HTMLVideoElement, dpi: number) => void;\n  onAfterScreenshot: () => void;\n  onError: (error: Error) => void;\n}\n\ntype UseTakeScreenshot = ({ onBeforeScreenshot, onScreenshot, onAfterScreenshot, onError }: Props) => void;\n\nexport function useTakeScreenshotFactory({ hooks }: FactoryParams): UseTakeScreenshot {\n  function useDpi(): number {\n    const [dpi, setDpi] = hooks.useState<number>(WINDOW.devicePixelRatio ?? 1);\n    hooks.useEffect(() => {\n      const onChange = (): void => {\n        setDpi(WINDOW.devicePixelRatio);\n      };\n      const media = matchMedia(`(resolution: ${WINDOW.devicePixelRatio}dppx)`);\n      media.addEventListener('change', onChange);\n      return () => {\n        media.removeEventListener('change', onChange);\n      };\n    }, []);\n\n    return dpi;\n  }\n\n  return function useTakeScreenshot({ onBeforeScreenshot, onScreenshot, onAfterScreenshot, onError }: Props) {\n    const dpi = useDpi();\n\n    hooks.useEffect(() => {\n      const takeScreenshot = async (): Promise<void> => {\n        onBeforeScreenshot();\n\n        // Chrome will animate a top-bar which can shrink the window height by a\n        // few pixels. The exact amount depends on how fast it takes to exec\n        // the onloadedmetadata callback.\n        // https://stackoverflow.com/q/75833049\n        const stream = await NAVIGATOR.mediaDevices.getDisplayMedia({\n          video: {\n            width: WINDOW.innerWidth * dpi,\n            height: WINDOW.innerHeight * dpi,\n          },\n          audio: false,\n          // @ts-expect-error experimental flags: https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getDisplayMedia#prefercurrenttab\n          monitorTypeSurfaces: 'exclude',\n          preferCurrentTab: true,\n          selfBrowserSurface: 'include',\n          surfaceSwitching: 'exclude',\n        });\n\n        const video = DOCUMENT.createElement('video');\n        await new Promise<void>((resolve, reject) => {\n          video.srcObject = stream;\n          video.onloadedmetadata = () => {\n            onScreenshot(video, dpi);\n            stream.getTracks().forEach(track => track.stop());\n            resolve();\n          };\n          video.play().catch(reject);\n        });\n        onAfterScreenshot();\n      };\n\n      takeScreenshot().catch(onError);\n    }, []);\n  };\n}\n","import type { FeedbackInternalOptions, FeedbackModalIntegration } from '@sentry/core';\nimport type { ComponentType, h as hType, VNode } from 'preact';\nimport { h } from 'preact'; // eslint-disable-line @typescript-eslint/no-unused-vars\nimport type * as Hooks from 'preact/hooks';\nimport { DOCUMENT, WINDOW } from '../../constants';\nimport IconCloseFactory from './IconClose';\nimport { createScreenshotInputStyles } from './ScreenshotInput.css';\nimport ToolbarFactory from './Toolbar';\nimport { useTakeScreenshotFactory } from './useTakeScreenshot';\n\ninterface FactoryParams {\n  h: typeof hType;\n  hooks: typeof Hooks;\n\n  /**\n   * A ref to a Canvas Element that serves as our \"value\" or image output.\n   */\n  outputBuffer: HTMLCanvasElement;\n\n  /**\n   * A reference to the whole dialog (the parent of this component) so that we\n   * can show/hide it and take a clean screenshot of the webpage.\n   */\n  dialog: ReturnType<FeedbackModalIntegration['createDialog']>;\n\n  /**\n   * The whole options object.\n   *\n   * Needed to set nonce and id values for editor specific styles\n   */\n  options: FeedbackInternalOptions;\n}\n\ninterface Props {\n  onError: (error: Error) => void;\n}\n\ntype MaybeCanvas = HTMLCanvasElement | null;\ntype Screenshot = { canvas: HTMLCanvasElement; dpi: number };\n\ntype DrawType = 'highlight' | 'hide' | '';\ninterface DrawCommand {\n  type: DrawType;\n  x: number;\n  y: number;\n  h: number;\n  w: number;\n}\n\nfunction drawRect(command: DrawCommand, ctx: CanvasRenderingContext2D, color: string): void {\n  switch (command.type) {\n    case 'highlight': {\n      // creates a shadow around\n      ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';\n      ctx.shadowBlur = 50;\n\n      // draws a rectangle first with a shadow\n      ctx.fillStyle = color;\n      ctx.fillRect(command.x - 1, command.y - 1, command.w + 2, command.h + 2);\n\n      // cut out the inside of the rectangle\n      ctx.clearRect(command.x, command.y, command.w, command.h);\n\n      break;\n    }\n    case 'hide':\n      ctx.fillStyle = 'rgb(0, 0, 0)';\n      ctx.fillRect(command.x, command.y, command.w, command.h);\n\n      break;\n    default:\n      break;\n  }\n}\n\nfunction with2dContext(\n  canvas: MaybeCanvas,\n  options: CanvasRenderingContext2DSettings,\n  callback: (canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D) => void,\n): void {\n  if (!canvas) {\n    return;\n  }\n  const ctx = canvas.getContext('2d', options);\n  if (!ctx) {\n    return;\n  }\n  callback(canvas, ctx);\n}\n\nfunction paintImage(maybeDest: MaybeCanvas, source: HTMLCanvasElement): void {\n  with2dContext(maybeDest, { alpha: true }, (destCanvas, destCtx) => {\n    destCtx.drawImage(source, 0, 0, source.width, source.height, 0, 0, destCanvas.width, destCanvas.height);\n  });\n}\n\n// Paint the array of drawCommands into a canvas.\n// Assuming this is the canvas foreground, and the background is cleaned.\nfunction paintForeground(maybeCanvas: MaybeCanvas, strokeColor: string, drawCommands: DrawCommand[]): void {\n  with2dContext(maybeCanvas, { alpha: true }, (canvas, ctx) => {\n    // If there's anything to draw, then we'll first clear the canvas with\n    // a transparent grey background\n    if (drawCommands.length) {\n      ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n\n    drawCommands.forEach(command => {\n      drawRect(command, ctx, strokeColor);\n    });\n  });\n}\n\nexport function ScreenshotEditorFactory({\n  h,\n  hooks,\n  outputBuffer,\n  dialog,\n  options,\n}: FactoryParams): ComponentType<Props> {\n  const useTakeScreenshot = useTakeScreenshotFactory({ hooks });\n  const Toolbar = ToolbarFactory({ h });\n  const IconClose = IconCloseFactory({ h });\n  const editorStyleInnerText = { __html: createScreenshotInputStyles(options.styleNonce).innerText };\n\n  const dialogStyle = (dialog.el as HTMLElement).style;\n\n  const ScreenshotEditor = ({ screenshot }: { screenshot: Screenshot }): VNode => {\n    // Data for rendering:\n    const [action, setAction] = hooks.useState<DrawType>('highlight');\n    const [drawCommands, setDrawCommands] = hooks.useState<DrawCommand[]>([]);\n\n    // Refs to our html components:\n    const measurementRef = hooks.useRef<HTMLDivElement | null>(null);\n    const backgroundRef = hooks.useRef<MaybeCanvas>(null);\n    const foregroundRef = hooks.useRef<MaybeCanvas>(null);\n    const mouseRef = hooks.useRef<HTMLDivElement | null>(null);\n\n    // The size of our window, relative to the imageSource\n    const [scaleFactor, setScaleFactor] = hooks.useState<number>(1);\n\n    const strokeColor = hooks.useMemo((): string => {\n      const sentryFeedback = DOCUMENT.getElementById(options.id);\n      if (!sentryFeedback) {\n        return 'white';\n      }\n      const computedStyle = getComputedStyle(sentryFeedback);\n      return (\n        computedStyle.getPropertyValue('--button-primary-background') ||\n        computedStyle.getPropertyValue('--accent-background')\n      );\n    }, [options.id]);\n\n    // The initial resize, to measure the area and set the children to the correct size\n    hooks.useLayoutEffect(() => {\n      const handleResize = (): void => {\n        const measurementDiv = measurementRef.current;\n        if (!measurementDiv) {\n          return;\n        }\n\n        with2dContext(screenshot.canvas, { alpha: false }, canvas => {\n          const scale = Math.min(\n            measurementDiv.clientWidth / canvas.width,\n            measurementDiv.clientHeight / canvas.height,\n          );\n          setScaleFactor(scale);\n        });\n\n        // For Firefox, the canvas is not yet measured, so we need to wait for it to get the correct size\n        if (measurementDiv.clientHeight === 0 || measurementDiv.clientWidth === 0) {\n          setTimeout(handleResize, 0);\n        }\n      };\n\n      handleResize();\n      WINDOW.addEventListener('resize', handleResize);\n      return () => {\n        WINDOW.removeEventListener('resize', handleResize);\n      };\n    }, [screenshot]);\n\n    // Set the size of the canvas element to match our screenshot\n    const setCanvasSize = hooks.useCallback(\n      (maybeCanvas: MaybeCanvas, scale: number): void => {\n        with2dContext(maybeCanvas, { alpha: true }, (canvas, ctx) => {\n          // Must call `scale()` before setting `width` & `height`\n          ctx.scale(scale, scale);\n          canvas.width = screenshot.canvas.width;\n          canvas.height = screenshot.canvas.height;\n        });\n      },\n      [screenshot],\n    );\n\n    // Draw the screenshot into the background\n    hooks.useEffect(() => {\n      setCanvasSize(backgroundRef.current, screenshot.dpi);\n      paintImage(backgroundRef.current, screenshot.canvas);\n    }, [screenshot]);\n\n    // Draw the commands into the foreground\n    hooks.useEffect(() => {\n      setCanvasSize(foregroundRef.current, screenshot.dpi);\n      with2dContext(foregroundRef.current, { alpha: true }, (canvas, ctx) => {\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n      });\n      paintForeground(foregroundRef.current, strokeColor, drawCommands);\n    }, [drawCommands, strokeColor]);\n\n    // Draw into the output outputBuffer\n    hooks.useEffect(() => {\n      setCanvasSize(outputBuffer, screenshot.dpi);\n      paintImage(outputBuffer, screenshot.canvas);\n      with2dContext(DOCUMENT.createElement('canvas'), { alpha: true }, (foreground, ctx) => {\n        ctx.scale(screenshot.dpi, screenshot.dpi); // The scale needs to be set before we set the width/height and paint\n        foreground.width = screenshot.canvas.width;\n        foreground.height = screenshot.canvas.height;\n        paintForeground(foreground, strokeColor, drawCommands);\n        paintImage(outputBuffer, foreground);\n      });\n    }, [drawCommands, screenshot, strokeColor]);\n\n    const handleMouseDown = (e: MouseEvent): void => {\n      if (!action || !mouseRef.current) {\n        return;\n      }\n\n      const boundingRect = mouseRef.current.getBoundingClientRect();\n      const startingPoint: DrawCommand = {\n        type: action,\n        x: e.offsetX / scaleFactor,\n        y: e.offsetY / scaleFactor,\n        w: 0,\n        h: 0,\n      };\n\n      const getDrawCommand = (startingPoint: DrawCommand, e: MouseEvent): DrawCommand => {\n        const x = (e.clientX - boundingRect.x) / scaleFactor;\n        const y = (e.clientY - boundingRect.y) / scaleFactor;\n        return {\n          type: startingPoint.type,\n          x: Math.min(startingPoint.x, x),\n          y: Math.min(startingPoint.y, y),\n          w: Math.abs(x - startingPoint.x),\n          h: Math.abs(y - startingPoint.y),\n        } as DrawCommand;\n      };\n\n      const handleMouseMove = (e: MouseEvent): void => {\n        with2dContext(foregroundRef.current, { alpha: true }, (canvas, ctx) => {\n          ctx.clearRect(0, 0, canvas.width, canvas.height);\n        });\n        paintForeground(foregroundRef.current, strokeColor, [...drawCommands, getDrawCommand(startingPoint, e)]);\n      };\n\n      const handleMouseUp = (e: MouseEvent): void => {\n        const drawCommand = getDrawCommand(startingPoint, e);\n\n        // Prevent just clicking onto the canvas, mouse has to move at least 1 pixel\n        if (drawCommand.w * scaleFactor >= 1 && drawCommand.h * scaleFactor >= 1) {\n          setDrawCommands(prev => [...prev, drawCommand]);\n        }\n        DOCUMENT.removeEventListener('mousemove', handleMouseMove);\n        DOCUMENT.removeEventListener('mouseup', handleMouseUp);\n      };\n\n      DOCUMENT.addEventListener('mousemove', handleMouseMove);\n      DOCUMENT.addEventListener('mouseup', handleMouseUp);\n    };\n\n    const deleteRect = hooks.useCallback((index: number): hType.JSX.MouseEventHandler<HTMLButtonElement> => {\n      return (e: MouseEvent): void => {\n        e.preventDefault();\n        e.stopPropagation();\n        setDrawCommands(prev => {\n          const updatedRects = [...prev];\n          updatedRects.splice(index, 1);\n          return updatedRects;\n        });\n      };\n    }, []);\n\n    const dimensions = {\n      width: `${screenshot.canvas.width * scaleFactor}px`,\n      height: `${screenshot.canvas.height * scaleFactor}px`,\n    };\n\n    const handleStopPropagation = (e: MouseEvent): void => {\n      e.stopPropagation();\n    };\n\n    return (\n      <div class=\"editor\">\n        <style nonce={options.styleNonce} dangerouslySetInnerHTML={editorStyleInnerText} />\n        <div class=\"editor__image-container\">\n          <div class=\"editor__canvas-container\" ref={measurementRef}>\n            <canvas ref={backgroundRef} id=\"background\" style={dimensions} />\n            <canvas ref={foregroundRef} id=\"foreground\" style={dimensions} />\n            <div ref={mouseRef} onMouseDown={handleMouseDown} style={dimensions}>\n              {drawCommands.map((rect, index) => (\n                <div\n                  key={index}\n                  class=\"editor__rect\"\n                  style={{\n                    top: `${rect.y * scaleFactor}px`,\n                    left: `${rect.x * scaleFactor}px`,\n                    width: `${rect.w * scaleFactor}px`,\n                    height: `${rect.h * scaleFactor}px`,\n                  }}\n                >\n                  <button\n                    aria-label={options.removeHighlightText}\n                    onClick={deleteRect(index)}\n                    onMouseDown={handleStopPropagation}\n                    onMouseUp={handleStopPropagation}\n                    type=\"button\"\n                  >\n                    <IconClose />\n                  </button>\n                </div>\n              ))}\n            </div>\n          </div>\n        </div>\n        <Toolbar options={options} action={action} setAction={setAction} />\n      </div>\n    );\n  };\n\n  return function Wrapper({ onError }: Props): VNode {\n    const [screenshot, setScreenshot] = hooks.useState<undefined | Screenshot>();\n\n    useTakeScreenshot({\n      onBeforeScreenshot: hooks.useCallback(() => {\n        dialogStyle.display = 'none';\n      }, []),\n      onScreenshot: hooks.useCallback((screenshotVideo: HTMLVideoElement, dpi: number) => {\n        // Stash the original screenshot image so we can (re)draw it multiple times\n        with2dContext(DOCUMENT.createElement('canvas'), { alpha: false }, (canvas, ctx) => {\n          ctx.scale(dpi, dpi); // The scale needs to be set before we set the width/height and paint\n          canvas.width = screenshotVideo.videoWidth;\n          canvas.height = screenshotVideo.videoHeight;\n          ctx.drawImage(screenshotVideo, 0, 0, canvas.width, canvas.height);\n\n          setScreenshot({ canvas, dpi });\n        });\n\n        // The output buffer, we only need to set the width/height on this once, it stays the same forever\n        outputBuffer.width = screenshotVideo.videoWidth;\n        outputBuffer.height = screenshotVideo.videoHeight;\n      }, []),\n      onAfterScreenshot: hooks.useCallback(() => {\n        dialogStyle.display = 'block';\n      }, []),\n      onError: hooks.useCallback(error => {\n        dialogStyle.display = 'block';\n        onError(error);\n      }, []),\n    });\n\n    if (screenshot) {\n      return <ScreenshotEditor screenshot={screenshot} />;\n    }\n\n    return <div />;\n  };\n}\n","import type { Attachment, FeedbackScreenshotIntegration, IntegrationFn } from '@sentry/core';\nimport type { h as hType } from 'preact';\nimport type * as Hooks from 'preact/hooks';\nimport { DOCUMENT } from '../constants';\nimport { ScreenshotEditorFactory } from './components/ScreenshotEditor';\n\nexport const feedbackScreenshotIntegration = ((): FeedbackScreenshotIntegration => {\n  return {\n    name: 'FeedbackScreenshot',\n    setupOnce() {},\n    createInput: ({ h, hooks, dialog, options }) => {\n      const outputBuffer = DOCUMENT.createElement('canvas');\n\n      return {\n        input: ScreenshotEditorFactory({\n          h: h as typeof hType,\n          hooks: hooks as typeof Hooks,\n          outputBuffer,\n          dialog,\n          options,\n        }) as any, // eslint-disable-line @typescript-eslint/no-explicit-any\n\n        value: async () => {\n          const blob = await new Promise<Parameters<BlobCallback>[0]>(resolve => {\n            outputBuffer.toBlob(resolve, 'image/png');\n          });\n          if (blob) {\n            const data = new Uint8Array(await blob.arrayBuffer());\n            const attachment: Attachment = {\n              data,\n              filename: 'screenshot.png',\n              contentType: 'application/png',\n              // attachmentType?: string;\n            };\n            return attachment;\n          }\n          return undefined;\n        },\n      };\n    },\n  };\n}) satisfies IntegrationFn;\n"],"names":["XMLNS","l","u","i","o","r","f","c","s","a","h","v","p","y","d","g","b","m","w","k","x","C","j","P","T","A","D","q","z","B","n","useMemo","useState","useCallback","Fragment","render"],"mappings":"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"}},
    {"offset": {"line": 2374, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry-internal/replay-canvas/build/npm/esm/index.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/node_modules/%40sentry-internal/rrweb/dist/rrweb.js","file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry-internal/replay-canvas/src/canvas.ts"],"sourcesContent":["var __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar NodeType$2 = /* @__PURE__ */ ((NodeType2) => {\n  NodeType2[NodeType2[\"Document\"] = 0] = \"Document\";\n  NodeType2[NodeType2[\"DocumentType\"] = 1] = \"DocumentType\";\n  NodeType2[NodeType2[\"Element\"] = 2] = \"Element\";\n  NodeType2[NodeType2[\"Text\"] = 3] = \"Text\";\n  NodeType2[NodeType2[\"CDATA\"] = 4] = \"CDATA\";\n  NodeType2[NodeType2[\"Comment\"] = 5] = \"Comment\";\n  return NodeType2;\n})(NodeType$2 || {});\nfunction isElement(n2) {\n  return n2.nodeType === n2.ELEMENT_NODE;\n}\nfunction isShadowRoot(n2) {\n  const host = n2?.host;\n  return Boolean(host?.shadowRoot === n2);\n}\nfunction isNativeShadowDom(shadowRoot) {\n  return Object.prototype.toString.call(shadowRoot) === \"[object ShadowRoot]\";\n}\nfunction fixBrowserCompatibilityIssuesInCSS(cssText) {\n  if (cssText.includes(\" background-clip: text;\") && !cssText.includes(\" -webkit-background-clip: text;\")) {\n    cssText = cssText.replace(\n      /\\sbackground-clip:\\s*text;/g,\n      \" -webkit-background-clip: text; background-clip: text;\"\n    );\n  }\n  return cssText;\n}\nfunction escapeImportStatement(rule) {\n  const { cssText } = rule;\n  if (cssText.split('\"').length < 3) return cssText;\n  const statement = [\"@import\", `url(${JSON.stringify(rule.href)})`];\n  if (rule.layerName === \"\") {\n    statement.push(`layer`);\n  } else if (rule.layerName) {\n    statement.push(`layer(${rule.layerName})`);\n  }\n  if (rule.supportsText) {\n    statement.push(`supports(${rule.supportsText})`);\n  }\n  if (rule.media.length) {\n    statement.push(rule.media.mediaText);\n  }\n  return statement.join(\" \") + \";\";\n}\nfunction stringifyStylesheet(s2) {\n  try {\n    const rules2 = s2.rules || s2.cssRules;\n    return rules2 ? fixBrowserCompatibilityIssuesInCSS(\n      Array.from(rules2, stringifyRule).join(\"\")\n    ) : null;\n  } catch (error) {\n    return null;\n  }\n}\nfunction fixAllCssProperty(rule) {\n  let styles = \"\";\n  for (let i2 = 0; i2 < rule.style.length; i2++) {\n    const styleDeclaration = rule.style;\n    const attribute = styleDeclaration[i2];\n    const isImportant = styleDeclaration.getPropertyPriority(attribute);\n    styles += `${attribute}:${styleDeclaration.getPropertyValue(attribute)}${isImportant ? ` !important` : \"\"};`;\n  }\n  return `${rule.selectorText} { ${styles} }`;\n}\nfunction stringifyRule(rule) {\n  let importStringified;\n  if (isCSSImportRule(rule)) {\n    try {\n      importStringified = // for same-origin stylesheets,\n      // we can access the imported stylesheet rules directly\n      stringifyStylesheet(rule.styleSheet) || // work around browser issues with the raw string `@import url(...)` statement\n      escapeImportStatement(rule);\n    } catch (error) {\n    }\n  } else if (isCSSStyleRule(rule)) {\n    let cssText = rule.cssText;\n    const needsSafariColonFix = rule.selectorText.includes(\":\");\n    const needsAllFix = typeof rule.style[\"all\"] === \"string\" && rule.style[\"all\"];\n    if (needsAllFix) {\n      cssText = fixAllCssProperty(rule);\n    }\n    if (needsSafariColonFix) {\n      cssText = fixSafariColons(cssText);\n    }\n    if (needsSafariColonFix || needsAllFix) {\n      return cssText;\n    }\n  }\n  return importStringified || rule.cssText;\n}\nfunction fixSafariColons(cssStringified) {\n  const regex = /(\\[(?:[\\w-]+)[^\\\\])(:(?:[\\w-]+)\\])/gm;\n  return cssStringified.replace(regex, \"$1\\\\$2\");\n}\nfunction isCSSImportRule(rule) {\n  return \"styleSheet\" in rule;\n}\nfunction isCSSStyleRule(rule) {\n  return \"selectorText\" in rule;\n}\nclass Mirror {\n  constructor() {\n    __publicField$1(this, \"idNodeMap\", /* @__PURE__ */ new Map());\n    __publicField$1(this, \"nodeMetaMap\", /* @__PURE__ */ new WeakMap());\n  }\n  getId(n2) {\n    if (!n2) return -1;\n    const id = this.getMeta(n2)?.id;\n    return id ?? -1;\n  }\n  getNode(id) {\n    return this.idNodeMap.get(id) || null;\n  }\n  getIds() {\n    return Array.from(this.idNodeMap.keys());\n  }\n  getMeta(n2) {\n    return this.nodeMetaMap.get(n2) || null;\n  }\n  // removes the node from idNodeMap\n  // doesn't remove the node from nodeMetaMap\n  removeNodeFromMap(n2) {\n    const id = this.getId(n2);\n    this.idNodeMap.delete(id);\n    if (n2.childNodes) {\n      n2.childNodes.forEach(\n        (childNode) => this.removeNodeFromMap(childNode)\n      );\n    }\n  }\n  has(id) {\n    return this.idNodeMap.has(id);\n  }\n  hasNode(node) {\n    return this.nodeMetaMap.has(node);\n  }\n  add(n2, meta) {\n    const id = meta.id;\n    this.idNodeMap.set(id, n2);\n    this.nodeMetaMap.set(n2, meta);\n  }\n  replace(id, n2) {\n    const oldNode = this.getNode(id);\n    if (oldNode) {\n      const meta = this.nodeMetaMap.get(oldNode);\n      if (meta) this.nodeMetaMap.set(n2, meta);\n    }\n    this.idNodeMap.set(id, n2);\n  }\n  reset() {\n    this.idNodeMap = /* @__PURE__ */ new Map();\n    this.nodeMetaMap = /* @__PURE__ */ new WeakMap();\n  }\n}\nfunction createMirror$2() {\n  return new Mirror();\n}\nfunction shouldMaskInput({\n  maskInputOptions,\n  tagName,\n  type\n}) {\n  if (tagName === \"OPTION\") {\n    tagName = \"SELECT\";\n  }\n  return Boolean(\n    maskInputOptions[tagName.toLowerCase()] || type && maskInputOptions[type] || type === \"password\" || // Default to \"text\" option for inputs without a \"type\" attribute defined\n    tagName === \"INPUT\" && !type && maskInputOptions[\"text\"]\n  );\n}\nfunction maskInputValue({\n  isMasked,\n  element,\n  value,\n  maskInputFn\n}) {\n  let text = value || \"\";\n  if (!isMasked) {\n    return text;\n  }\n  if (maskInputFn) {\n    text = maskInputFn(text, element);\n  }\n  return \"*\".repeat(text.length);\n}\nfunction toLowerCase(str) {\n  return str.toLowerCase();\n}\nfunction toUpperCase(str) {\n  return str.toUpperCase();\n}\nconst ORIGINAL_ATTRIBUTE_NAME = \"__rrweb_original__\";\nfunction is2DCanvasBlank(canvas) {\n  const ctx = canvas.getContext(\"2d\");\n  if (!ctx) return true;\n  const chunkSize = 50;\n  for (let x = 0; x < canvas.width; x += chunkSize) {\n    for (let y = 0; y < canvas.height; y += chunkSize) {\n      const getImageData = ctx.getImageData;\n      const originalGetImageData = ORIGINAL_ATTRIBUTE_NAME in getImageData ? getImageData[ORIGINAL_ATTRIBUTE_NAME] : getImageData;\n      const pixelBuffer = new Uint32Array(\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access\n        originalGetImageData.call(\n          ctx,\n          x,\n          y,\n          Math.min(chunkSize, canvas.width - x),\n          Math.min(chunkSize, canvas.height - y)\n        ).data.buffer\n      );\n      if (pixelBuffer.some((pixel) => pixel !== 0)) return false;\n    }\n  }\n  return true;\n}\nfunction isNodeMetaEqual(a2, b) {\n  if (!a2 || !b || a2.type !== b.type) return false;\n  if (a2.type === NodeType$2.Document)\n    return a2.compatMode === b.compatMode;\n  else if (a2.type === NodeType$2.DocumentType)\n    return a2.name === b.name && a2.publicId === b.publicId && a2.systemId === b.systemId;\n  else if (a2.type === NodeType$2.Comment || a2.type === NodeType$2.Text || a2.type === NodeType$2.CDATA)\n    return a2.textContent === b.textContent;\n  else if (a2.type === NodeType$2.Element)\n    return a2.tagName === b.tagName && JSON.stringify(a2.attributes) === JSON.stringify(b.attributes) && a2.isSVG === b.isSVG && a2.needBlock === b.needBlock;\n  return false;\n}\nfunction getInputType(element) {\n  const type = element.type;\n  return element.hasAttribute(\"data-rr-is-password\") ? \"password\" : type ? (\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    toLowerCase(type)\n  ) : null;\n}\nfunction getInputValue(el, tagName, type) {\n  if (tagName === \"INPUT\" && (type === \"radio\" || type === \"checkbox\")) {\n    return el.getAttribute(\"value\") || \"\";\n  }\n  return el.value;\n}\nfunction extractFileExtension(path, baseURL) {\n  let url;\n  try {\n    url = new URL(path, baseURL ?? window.location.href);\n  } catch (err) {\n    return null;\n  }\n  const regex = /\\.([0-9a-z]+)(?:$)/i;\n  const match = url.pathname.match(regex);\n  return match?.[1] ?? null;\n}\nconst cachedImplementations$1 = {};\nfunction getImplementation$1(name) {\n  const cached = cachedImplementations$1[name];\n  if (cached) {\n    return cached;\n  }\n  const document2 = window.document;\n  let impl = window[name];\n  if (document2 && typeof document2.createElement === \"function\") {\n    try {\n      const sandbox = document2.createElement(\"iframe\");\n      sandbox.hidden = true;\n      document2.head.appendChild(sandbox);\n      const contentWindow = sandbox.contentWindow;\n      if (contentWindow && contentWindow[name]) {\n        impl = // eslint-disable-next-line @typescript-eslint/unbound-method\n        contentWindow[name];\n      }\n      document2.head.removeChild(sandbox);\n    } catch (e2) {\n    }\n  }\n  return cachedImplementations$1[name] = impl.bind(\n    window\n  );\n}\nfunction setTimeout$2(...rest) {\n  return getImplementation$1(\"setTimeout\")(...rest);\n}\nfunction clearTimeout$1(...rest) {\n  return getImplementation$1(\"clearTimeout\")(...rest);\n}\nfunction getIframeContentDocument(iframe) {\n  try {\n    return iframe.contentDocument;\n  } catch (e2) {\n  }\n}\nlet _id = 1;\nconst tagNameRegex = new RegExp(\"[^a-z0-9-_:]\");\nconst IGNORED_NODE = -2;\nfunction genId() {\n  return _id++;\n}\nfunction getValidTagName$1(element) {\n  if (element instanceof HTMLFormElement) {\n    return \"form\";\n  }\n  const processedTagName = toLowerCase(element.tagName);\n  if (tagNameRegex.test(processedTagName)) {\n    return \"div\";\n  }\n  return processedTagName;\n}\nfunction extractOrigin(url) {\n  let origin = \"\";\n  if (url.indexOf(\"//\") > -1) {\n    origin = url.split(\"/\").slice(0, 3).join(\"/\");\n  } else {\n    origin = url.split(\"/\")[0];\n  }\n  origin = origin.split(\"?\")[0];\n  return origin;\n}\nlet canvasService;\nlet canvasCtx;\nconst URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")(.*?)\"|([^)]*))\\)/gm;\nconst URL_PROTOCOL_MATCH = /^(?:[a-z+]+:)?\\/\\//i;\nconst URL_WWW_MATCH = /^www\\..*/i;\nconst DATA_URI = /^(data:)([^,]*),(.*)/i;\nfunction filterCSSPropertiesFromInlineStyle(cssText, ignoredProperties) {\n  if (!cssText || ignoredProperties.size === 0) {\n    return cssText;\n  }\n  try {\n    const properties = cssText.split(\";\");\n    const filteredProperties = [];\n    for (let property of properties) {\n      property = property.trim();\n      if (!property) continue;\n      const colonIndex = property.indexOf(\":\");\n      if (colonIndex === -1) {\n        filteredProperties.push(property);\n        continue;\n      }\n      const propertyName = property.slice(0, colonIndex).trim();\n      if (!ignoredProperties.has(propertyName)) {\n        filteredProperties.push(property);\n      }\n    }\n    return filteredProperties.join(\"; \") + (filteredProperties.length > 0 && cssText.endsWith(\";\") ? \";\" : \"\");\n  } catch (error) {\n    console.warn(\"Error filtering CSS properties:\", error);\n    return cssText;\n  }\n}\nfunction absoluteToStylesheet(cssText, href) {\n  return (cssText || \"\").replace(\n    URL_IN_CSS_REF,\n    (origin, quote1, path1, quote2, path2, path3) => {\n      const filePath = path1 || path2 || path3;\n      const maybeQuote = quote1 || quote2 || \"\";\n      if (!filePath) {\n        return origin;\n      }\n      if (URL_PROTOCOL_MATCH.test(filePath) || URL_WWW_MATCH.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (DATA_URI.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (filePath[0] === \"/\") {\n        return `url(${maybeQuote}${extractOrigin(href) + filePath}${maybeQuote})`;\n      }\n      const stack = href.split(\"/\");\n      const parts = filePath.split(\"/\");\n      stack.pop();\n      for (const part of parts) {\n        if (part === \".\") {\n          continue;\n        } else if (part === \"..\") {\n          stack.pop();\n        } else {\n          stack.push(part);\n        }\n      }\n      return `url(${maybeQuote}${stack.join(\"/\")}${maybeQuote})`;\n    }\n  );\n}\nconst SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/;\nconst SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\nfunction getAbsoluteSrcsetString(doc, attributeValue) {\n  if (attributeValue.trim() === \"\") {\n    return attributeValue;\n  }\n  let pos = 0;\n  function collectCharacters(regEx) {\n    let chars2;\n    const match = regEx.exec(attributeValue.substring(pos));\n    if (match) {\n      chars2 = match[0];\n      pos += chars2.length;\n      return chars2;\n    }\n    return \"\";\n  }\n  const output = [];\n  while (true) {\n    collectCharacters(SRCSET_COMMAS_OR_SPACES);\n    if (pos >= attributeValue.length) {\n      break;\n    }\n    let url = collectCharacters(SRCSET_NOT_SPACES);\n    if (url.slice(-1) === \",\") {\n      url = absoluteToDoc(doc, url.substring(0, url.length - 1));\n      output.push(url);\n    } else {\n      let descriptorsStr = \"\";\n      url = absoluteToDoc(doc, url);\n      let inParens = false;\n      while (true) {\n        const c2 = attributeValue.charAt(pos);\n        if (c2 === \"\") {\n          output.push((url + descriptorsStr).trim());\n          break;\n        } else if (!inParens) {\n          if (c2 === \",\") {\n            pos += 1;\n            output.push((url + descriptorsStr).trim());\n            break;\n          } else if (c2 === \"(\") {\n            inParens = true;\n          }\n        } else {\n          if (c2 === \")\") {\n            inParens = false;\n          }\n        }\n        descriptorsStr += c2;\n        pos += 1;\n      }\n    }\n  }\n  return output.join(\", \");\n}\nconst cachedDocument = /* @__PURE__ */ new WeakMap();\nfunction absoluteToDoc(doc, attributeValue) {\n  if (!attributeValue || attributeValue.trim() === \"\") {\n    return attributeValue;\n  }\n  return getHref(doc, attributeValue);\n}\nfunction isSVGElement(el) {\n  return Boolean(el.tagName === \"svg\" || el.ownerSVGElement);\n}\nfunction getHref(doc, customHref) {\n  let a2 = cachedDocument.get(doc);\n  if (!a2) {\n    a2 = doc.createElement(\"a\");\n    cachedDocument.set(doc, a2);\n  }\n  if (!customHref) {\n    customHref = \"\";\n  } else if (customHref.startsWith(\"blob:\") || customHref.startsWith(\"data:\")) {\n    return customHref;\n  }\n  a2.setAttribute(\"href\", customHref);\n  return a2.href;\n}\nfunction transformAttribute(doc, tagName, name, value, element, maskAttributeFn, ignoreCSSAttributes) {\n  if (!value) {\n    return value;\n  }\n  if (name === \"src\" || name === \"href\" && !(tagName === \"use\" && value[0] === \"#\")) {\n    return absoluteToDoc(doc, value);\n  } else if (name === \"xlink:href\" && value[0] !== \"#\") {\n    return absoluteToDoc(doc, value);\n  } else if (name === \"background\" && (tagName === \"table\" || tagName === \"td\" || tagName === \"th\")) {\n    return absoluteToDoc(doc, value);\n  } else if (name === \"srcset\") {\n    return getAbsoluteSrcsetString(doc, value);\n  } else if (name === \"style\") {\n    let processedStyle = absoluteToStylesheet(value, getHref(doc));\n    if (ignoreCSSAttributes && ignoreCSSAttributes.size > 0) {\n      processedStyle = filterCSSPropertiesFromInlineStyle(\n        processedStyle,\n        ignoreCSSAttributes\n      );\n    }\n    return processedStyle;\n  } else if (tagName === \"object\" && name === \"data\") {\n    return absoluteToDoc(doc, value);\n  }\n  if (typeof maskAttributeFn === \"function\") {\n    return maskAttributeFn(name, value, element);\n  }\n  return value;\n}\nfunction ignoreAttribute(tagName, name, _value) {\n  return (tagName === \"video\" || tagName === \"audio\") && name === \"autoplay\";\n}\nfunction _isBlockedElement(element, blockClass, blockSelector, unblockSelector) {\n  try {\n    if (unblockSelector && element.matches(unblockSelector)) {\n      return false;\n    }\n    if (typeof blockClass === \"string\") {\n      if (element.classList.contains(blockClass)) {\n        return true;\n      }\n    } else {\n      for (let eIndex = element.classList.length; eIndex--; ) {\n        const className = element.classList[eIndex];\n        if (blockClass.test(className)) {\n          return true;\n        }\n      }\n    }\n    if (blockSelector) {\n      return element.matches(blockSelector);\n    }\n  } catch (e2) {\n  }\n  return false;\n}\nfunction elementClassMatchesRegex(el, regex) {\n  for (let eIndex = el.classList.length; eIndex--; ) {\n    const className = el.classList[eIndex];\n    if (regex.test(className)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction distanceToMatch(node, matchPredicate, limit = Infinity, distance = 0) {\n  if (!node) return -1;\n  if (node.nodeType !== node.ELEMENT_NODE) return -1;\n  if (distance > limit) return -1;\n  if (matchPredicate(node)) return distance;\n  return distanceToMatch(node.parentNode, matchPredicate, limit, distance + 1);\n}\nfunction createMatchPredicate(className, selector) {\n  return (node) => {\n    const el = node;\n    if (el === null) return false;\n    try {\n      if (className) {\n        if (typeof className === \"string\") {\n          if (el.matches(`.${className}`)) return true;\n        } else if (elementClassMatchesRegex(el, className)) {\n          return true;\n        }\n      }\n      if (selector && el.matches(selector)) return true;\n      return false;\n    } catch {\n      return false;\n    }\n  };\n}\nfunction needMaskingText(node, maskTextClass, maskTextSelector, unmaskTextClass, unmaskTextSelector, maskAllText) {\n  try {\n    const el = node.nodeType === node.ELEMENT_NODE ? node : node.parentElement;\n    if (el === null) return false;\n    if (el.tagName === \"INPUT\") {\n      const autocomplete = el.getAttribute(\"autocomplete\");\n      const disallowedAutocompleteValues = [\n        \"current-password\",\n        \"new-password\",\n        \"cc-number\",\n        \"cc-exp\",\n        \"cc-exp-month\",\n        \"cc-exp-year\",\n        \"cc-csc\"\n      ];\n      if (disallowedAutocompleteValues.includes(autocomplete)) {\n        return true;\n      }\n    }\n    let maskDistance = -1;\n    let unmaskDistance = -1;\n    if (maskAllText) {\n      unmaskDistance = distanceToMatch(\n        el,\n        createMatchPredicate(unmaskTextClass, unmaskTextSelector)\n      );\n      if (unmaskDistance < 0) {\n        return true;\n      }\n      maskDistance = distanceToMatch(\n        el,\n        createMatchPredicate(maskTextClass, maskTextSelector),\n        unmaskDistance >= 0 ? unmaskDistance : Infinity\n      );\n    } else {\n      maskDistance = distanceToMatch(\n        el,\n        createMatchPredicate(maskTextClass, maskTextSelector)\n      );\n      if (maskDistance < 0) {\n        return false;\n      }\n      unmaskDistance = distanceToMatch(\n        el,\n        createMatchPredicate(unmaskTextClass, unmaskTextSelector),\n        maskDistance >= 0 ? maskDistance : Infinity\n      );\n    }\n    return maskDistance >= 0 ? unmaskDistance >= 0 ? maskDistance <= unmaskDistance : true : unmaskDistance >= 0 ? false : !!maskAllText;\n  } catch (e2) {\n  }\n  return !!maskAllText;\n}\nfunction onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {\n  const win = iframeEl.contentWindow;\n  if (!win) {\n    return;\n  }\n  let fired = false;\n  let readyState;\n  try {\n    readyState = win.document.readyState;\n  } catch (error) {\n    return;\n  }\n  if (readyState !== \"complete\") {\n    const timer = setTimeout$2(() => {\n      if (!fired) {\n        listener();\n        fired = true;\n      }\n    }, iframeLoadTimeout);\n    iframeEl.addEventListener(\"load\", () => {\n      clearTimeout$1(timer);\n      fired = true;\n      listener();\n    });\n    return;\n  }\n  const blankUrl = \"about:blank\";\n  if (win.location.href !== blankUrl || iframeEl.src === blankUrl || iframeEl.src === \"\") {\n    setTimeout$2(listener, 0);\n    return iframeEl.addEventListener(\"load\", listener);\n  }\n  iframeEl.addEventListener(\"load\", listener);\n}\nfunction onceStylesheetLoaded(link, listener, styleSheetLoadTimeout) {\n  let fired = false;\n  let styleSheetLoaded;\n  try {\n    styleSheetLoaded = link.sheet;\n  } catch (error) {\n    return;\n  }\n  if (styleSheetLoaded) return;\n  const timer = setTimeout$2(() => {\n    if (!fired) {\n      listener();\n      fired = true;\n    }\n  }, styleSheetLoadTimeout);\n  link.addEventListener(\"load\", () => {\n    clearTimeout$1(timer);\n    fired = true;\n    listener();\n  });\n}\nfunction serializeNode(n2, options) {\n  const {\n    doc,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    maskAllText,\n    maskAttributeFn,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    inlineStylesheet,\n    maskInputOptions = {},\n    maskTextFn,\n    maskInputFn,\n    dataURLOptions = {},\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n    newlyAddedElement = false,\n    ignoreCSSAttributes\n  } = options;\n  const rootId = getRootId(doc, mirror2);\n  switch (n2.nodeType) {\n    case n2.DOCUMENT_NODE:\n      if (n2.compatMode !== \"CSS1Compat\") {\n        return {\n          type: NodeType$2.Document,\n          childNodes: [],\n          compatMode: n2.compatMode\n          // probably \"BackCompat\"\n        };\n      } else {\n        return {\n          type: NodeType$2.Document,\n          childNodes: []\n        };\n      }\n    case n2.DOCUMENT_TYPE_NODE:\n      return {\n        type: NodeType$2.DocumentType,\n        name: n2.name,\n        publicId: n2.publicId,\n        systemId: n2.systemId,\n        rootId\n      };\n    case n2.ELEMENT_NODE:\n      return serializeElementNode(n2, {\n        doc,\n        blockClass,\n        blockSelector,\n        unblockSelector,\n        inlineStylesheet,\n        maskAttributeFn,\n        maskInputOptions,\n        maskInputFn,\n        dataURLOptions,\n        inlineImages,\n        recordCanvas,\n        keepIframeSrcFn,\n        newlyAddedElement,\n        rootId,\n        maskAllText,\n        maskTextClass,\n        unmaskTextClass,\n        maskTextSelector,\n        unmaskTextSelector,\n        ignoreCSSAttributes\n      });\n    case n2.TEXT_NODE:\n      return serializeTextNode(n2, {\n        doc,\n        maskAllText,\n        maskTextClass,\n        unmaskTextClass,\n        maskTextSelector,\n        unmaskTextSelector,\n        maskTextFn,\n        maskInputOptions,\n        maskInputFn,\n        rootId\n      });\n    case n2.CDATA_SECTION_NODE:\n      return {\n        type: NodeType$2.CDATA,\n        textContent: \"\",\n        rootId\n      };\n    case n2.COMMENT_NODE:\n      return {\n        type: NodeType$2.Comment,\n        textContent: n2.textContent || \"\",\n        rootId\n      };\n    default:\n      return false;\n  }\n}\nfunction getRootId(doc, mirror2) {\n  if (!mirror2.hasNode(doc)) return void 0;\n  const docId = mirror2.getId(doc);\n  return docId === 1 ? void 0 : docId;\n}\nfunction serializeTextNode(n2, options) {\n  const {\n    maskAllText,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    maskTextFn,\n    maskInputOptions,\n    maskInputFn,\n    rootId\n  } = options;\n  const parentTagName = n2.parentNode && n2.parentNode.tagName;\n  let textContent = n2.textContent;\n  const isStyle = parentTagName === \"STYLE\" ? true : void 0;\n  const isScript = parentTagName === \"SCRIPT\" ? true : void 0;\n  const isTextarea = parentTagName === \"TEXTAREA\" ? true : void 0;\n  if (isStyle && textContent) {\n    try {\n      if (n2.nextSibling || n2.previousSibling) {\n      } else if (n2.parentNode.sheet?.cssRules) {\n        textContent = stringifyStylesheet(\n          n2.parentNode.sheet\n        );\n      }\n    } catch (err) {\n      console.warn(\n        `Cannot get CSS styles from text's parentNode. Error: ${err}`,\n        n2\n      );\n    }\n    textContent = absoluteToStylesheet(textContent, getHref(options.doc));\n  }\n  if (isScript) {\n    textContent = \"SCRIPT_PLACEHOLDER\";\n  }\n  const forceMask = needMaskingText(\n    n2,\n    maskTextClass,\n    maskTextSelector,\n    unmaskTextClass,\n    unmaskTextSelector,\n    maskAllText\n  );\n  if (!isStyle && !isScript && !isTextarea && textContent && forceMask) {\n    textContent = maskTextFn ? maskTextFn(textContent, n2.parentElement) : textContent.replace(/[\\S]/g, \"*\");\n  }\n  if (isTextarea && textContent && (maskInputOptions.textarea || forceMask)) {\n    textContent = maskInputFn ? maskInputFn(textContent, n2.parentNode) : textContent.replace(/[\\S]/g, \"*\");\n  }\n  if (parentTagName === \"OPTION\" && textContent) {\n    const isInputMasked = shouldMaskInput({\n      type: null,\n      tagName: parentTagName,\n      maskInputOptions\n    });\n    textContent = maskInputValue({\n      isMasked: needMaskingText(\n        n2,\n        maskTextClass,\n        maskTextSelector,\n        unmaskTextClass,\n        unmaskTextSelector,\n        isInputMasked\n      ),\n      element: n2,\n      value: textContent,\n      maskInputFn\n    });\n  }\n  return {\n    type: NodeType$2.Text,\n    textContent: textContent || \"\",\n    isStyle,\n    rootId\n  };\n}\nfunction serializeElementNode(n2, options) {\n  const {\n    doc,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    inlineStylesheet,\n    maskInputOptions = {},\n    maskAttributeFn,\n    maskInputFn,\n    dataURLOptions = {},\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n    newlyAddedElement = false,\n    rootId,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    ignoreCSSAttributes\n  } = options;\n  const needBlock = _isBlockedElement(\n    n2,\n    blockClass,\n    blockSelector,\n    unblockSelector\n  );\n  const tagName = getValidTagName$1(n2);\n  let attributes2 = {};\n  const len = n2.attributes.length;\n  for (let i2 = 0; i2 < len; i2++) {\n    const attr = n2.attributes[i2];\n    if (attr.name && !ignoreAttribute(tagName, attr.name, attr.value)) {\n      attributes2[attr.name] = transformAttribute(\n        doc,\n        tagName,\n        toLowerCase(attr.name),\n        attr.value,\n        n2,\n        maskAttributeFn,\n        ignoreCSSAttributes\n      );\n    }\n  }\n  if (tagName === \"link\" && inlineStylesheet) {\n    const stylesheet = Array.from(doc.styleSheets).find((s2) => {\n      return s2.href === n2.href;\n    });\n    let cssText = null;\n    if (stylesheet) {\n      cssText = stringifyStylesheet(stylesheet);\n    }\n    if (cssText) {\n      attributes2.rel = null;\n      attributes2.href = null;\n      attributes2.crossorigin = null;\n      attributes2._cssText = absoluteToStylesheet(cssText, stylesheet.href);\n    }\n  }\n  if (tagName === \"style\" && n2.sheet && // TODO: Currently we only try to get dynamic stylesheet when it is an empty style element\n  !(n2.innerText || n2.textContent || \"\").trim().length) {\n    const cssText = stringifyStylesheet(\n      n2.sheet\n    );\n    if (cssText) {\n      attributes2._cssText = absoluteToStylesheet(cssText, getHref(doc));\n    }\n  }\n  if (tagName === \"input\" || tagName === \"textarea\" || tagName === \"select\" || tagName === \"option\") {\n    const el = n2;\n    const type = getInputType(el);\n    const value = getInputValue(el, toUpperCase(tagName), type);\n    const checked = el.checked;\n    if (type !== \"submit\" && type !== \"button\" && value) {\n      const forceMask = needMaskingText(\n        el,\n        maskTextClass,\n        maskTextSelector,\n        unmaskTextClass,\n        unmaskTextSelector,\n        shouldMaskInput({\n          type,\n          tagName: toUpperCase(tagName),\n          maskInputOptions\n        })\n      );\n      attributes2.value = maskInputValue({\n        isMasked: forceMask,\n        element: el,\n        value,\n        maskInputFn\n      });\n    }\n    if (checked) {\n      attributes2.checked = checked;\n    }\n  }\n  if (tagName === \"option\") {\n    if (n2.selected && !maskInputOptions[\"select\"]) {\n      attributes2.selected = true;\n    } else {\n      delete attributes2.selected;\n    }\n  }\n  if (tagName === \"canvas\" && recordCanvas) {\n    if (n2.__context === \"2d\") {\n      if (!is2DCanvasBlank(n2)) {\n        attributes2.rr_dataURL = n2.toDataURL(\n          dataURLOptions.type,\n          dataURLOptions.quality\n        );\n      }\n    } else if (!(\"__context\" in n2)) {\n      const canvasDataURL = n2.toDataURL(\n        dataURLOptions.type,\n        dataURLOptions.quality\n      );\n      const blankCanvas = doc.createElement(\"canvas\");\n      blankCanvas.width = n2.width;\n      blankCanvas.height = n2.height;\n      const blankCanvasDataURL = blankCanvas.toDataURL(\n        dataURLOptions.type,\n        dataURLOptions.quality\n      );\n      if (canvasDataURL !== blankCanvasDataURL) {\n        attributes2.rr_dataURL = canvasDataURL;\n      }\n    }\n  }\n  if (tagName === \"img\" && inlineImages) {\n    if (!canvasService) {\n      canvasService = doc.createElement(\"canvas\");\n      canvasCtx = canvasService.getContext(\"2d\");\n    }\n    const image = n2;\n    const imageSrc = image.currentSrc || image.getAttribute(\"src\") || \"<unknown-src>\";\n    const priorCrossOrigin = image.crossOrigin;\n    const recordInlineImage = () => {\n      image.removeEventListener(\"load\", recordInlineImage);\n      try {\n        canvasService.width = image.naturalWidth;\n        canvasService.height = image.naturalHeight;\n        canvasCtx.drawImage(image, 0, 0);\n        attributes2.rr_dataURL = canvasService.toDataURL(\n          dataURLOptions.type,\n          dataURLOptions.quality\n        );\n      } catch (err) {\n        if (image.crossOrigin !== \"anonymous\") {\n          image.crossOrigin = \"anonymous\";\n          if (image.complete && image.naturalWidth !== 0)\n            recordInlineImage();\n          else image.addEventListener(\"load\", recordInlineImage);\n          return;\n        } else {\n          console.warn(\n            `Cannot inline img src=${imageSrc}! Error: ${err}`\n          );\n        }\n      }\n      if (image.crossOrigin === \"anonymous\") {\n        priorCrossOrigin ? attributes2.crossOrigin = priorCrossOrigin : image.removeAttribute(\"crossorigin\");\n      }\n    };\n    if (image.complete && image.naturalWidth !== 0) recordInlineImage();\n    else image.addEventListener(\"load\", recordInlineImage);\n  }\n  if (tagName === \"audio\" || tagName === \"video\") {\n    attributes2.rr_mediaState = n2.paused ? \"paused\" : \"played\";\n    attributes2.rr_mediaCurrentTime = n2.currentTime;\n  }\n  if (!newlyAddedElement) {\n    if (n2.scrollLeft) {\n      attributes2.rr_scrollLeft = n2.scrollLeft;\n    }\n    if (n2.scrollTop) {\n      attributes2.rr_scrollTop = n2.scrollTop;\n    }\n  }\n  if (needBlock) {\n    const { width, height } = n2.getBoundingClientRect();\n    attributes2 = {\n      class: attributes2.class,\n      rr_width: `${width}px`,\n      rr_height: `${height}px`\n    };\n  }\n  if (tagName === \"iframe\" && !keepIframeSrcFn(attributes2.src)) {\n    if (!needBlock && !getIframeContentDocument(n2)) {\n      attributes2.rr_src = attributes2.src;\n    }\n    delete attributes2.src;\n  }\n  let isCustomElement;\n  try {\n    if (customElements.get(tagName)) isCustomElement = true;\n  } catch (e2) {\n  }\n  return {\n    type: NodeType$2.Element,\n    tagName,\n    attributes: attributes2,\n    childNodes: [],\n    isSVG: isSVGElement(n2) || void 0,\n    needBlock,\n    rootId,\n    isCustom: isCustomElement\n  };\n}\nfunction lowerIfExists(maybeAttr) {\n  if (maybeAttr === void 0 || maybeAttr === null) {\n    return \"\";\n  } else {\n    return maybeAttr.toLowerCase();\n  }\n}\nfunction slimDOMExcluded(sn, slimDOMOptions) {\n  if (slimDOMOptions.comment && sn.type === NodeType$2.Comment) {\n    return true;\n  } else if (sn.type === NodeType$2.Element) {\n    if (slimDOMOptions.script && // script tag\n    (sn.tagName === \"script\" || // (module)preload link\n    sn.tagName === \"link\" && (sn.attributes.rel === \"preload\" || sn.attributes.rel === \"modulepreload\") || // prefetch link\n    sn.tagName === \"link\" && sn.attributes.rel === \"prefetch\" && typeof sn.attributes.href === \"string\" && extractFileExtension(sn.attributes.href) === \"js\")) {\n      return true;\n    } else if (slimDOMOptions.headFavicon && (sn.tagName === \"link\" && sn.attributes.rel === \"shortcut icon\" || sn.tagName === \"meta\" && (lowerIfExists(sn.attributes.name).match(\n      /^msapplication-tile(image|color)$/\n    ) || lowerIfExists(sn.attributes.name) === \"application-name\" || lowerIfExists(sn.attributes.rel) === \"icon\" || lowerIfExists(sn.attributes.rel) === \"apple-touch-icon\" || lowerIfExists(sn.attributes.rel) === \"shortcut icon\"))) {\n      return true;\n    } else if (sn.tagName === \"meta\") {\n      if (slimDOMOptions.headMetaDescKeywords && lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {\n        return true;\n      } else if (slimDOMOptions.headMetaSocial && (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) || // og = opengraph (facebook)\n      lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) || lowerIfExists(sn.attributes.name) === \"pinterest\")) {\n        return true;\n      } else if (slimDOMOptions.headMetaRobots && (lowerIfExists(sn.attributes.name) === \"robots\" || lowerIfExists(sn.attributes.name) === \"googlebot\" || lowerIfExists(sn.attributes.name) === \"bingbot\")) {\n        return true;\n      } else if (slimDOMOptions.headMetaHttpEquiv && sn.attributes[\"http-equiv\"] !== void 0) {\n        return true;\n      } else if (slimDOMOptions.headMetaAuthorship && (lowerIfExists(sn.attributes.name) === \"author\" || lowerIfExists(sn.attributes.name) === \"generator\" || lowerIfExists(sn.attributes.name) === \"framework\" || lowerIfExists(sn.attributes.name) === \"publisher\" || lowerIfExists(sn.attributes.name) === \"progid\" || lowerIfExists(sn.attributes.property).match(/^article:/) || lowerIfExists(sn.attributes.property).match(/^product:/))) {\n        return true;\n      } else if (slimDOMOptions.headMetaVerification && (lowerIfExists(sn.attributes.name) === \"google-site-verification\" || lowerIfExists(sn.attributes.name) === \"yandex-verification\" || lowerIfExists(sn.attributes.name) === \"csrf-token\" || lowerIfExists(sn.attributes.name) === \"p:domain_verify\" || lowerIfExists(sn.attributes.name) === \"verify-v1\" || lowerIfExists(sn.attributes.name) === \"verification\" || lowerIfExists(sn.attributes.name) === \"shopify-checkout-api-token\")) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction serializeNodeWithId(n2, options) {\n  const {\n    doc,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    maskAllText,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    skipChild = false,\n    inlineStylesheet = true,\n    maskInputOptions = {},\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    slimDOMOptions,\n    dataURLOptions = {},\n    inlineImages = false,\n    recordCanvas = false,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout = 5e3,\n    onBlockedImageLoad,\n    onStylesheetLoad,\n    stylesheetLoadTimeout = 5e3,\n    keepIframeSrcFn = () => false,\n    newlyAddedElement = false,\n    ignoreCSSAttributes\n  } = options;\n  let { preserveWhiteSpace = true } = options;\n  const _serializedNode = serializeNode(n2, {\n    doc,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    maskAllText,\n    unblockSelector,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    inlineStylesheet,\n    maskInputOptions,\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    dataURLOptions,\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n    newlyAddedElement,\n    ignoreCSSAttributes\n  });\n  if (!_serializedNode) {\n    console.warn(n2, \"not serialized\");\n    return null;\n  }\n  let id;\n  if (mirror2.hasNode(n2)) {\n    id = mirror2.getId(n2);\n  } else if (slimDOMExcluded(_serializedNode, slimDOMOptions) || !preserveWhiteSpace && _serializedNode.type === NodeType$2.Text && !_serializedNode.isStyle && !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, \"\").length) {\n    id = IGNORED_NODE;\n  } else {\n    id = genId();\n  }\n  const serializedNode2 = Object.assign(_serializedNode, { id });\n  mirror2.add(n2, serializedNode2);\n  if (id === IGNORED_NODE) {\n    return null;\n  }\n  if (onSerialize) {\n    onSerialize(n2);\n  }\n  let recordChild = !skipChild;\n  if (serializedNode2.type === NodeType$2.Element) {\n    recordChild = recordChild && !serializedNode2.needBlock;\n    const shadowRoot = n2.shadowRoot;\n    if (shadowRoot && isNativeShadowDom(shadowRoot))\n      serializedNode2.isShadowHost = true;\n  }\n  if ((serializedNode2.type === NodeType$2.Document || serializedNode2.type === NodeType$2.Element) && recordChild) {\n    if (slimDOMOptions.headWhitespace && serializedNode2.type === NodeType$2.Element && serializedNode2.tagName === \"head\") {\n      preserveWhiteSpace = false;\n    }\n    const bypassOptions = {\n      doc,\n      mirror: mirror2,\n      blockClass,\n      blockSelector,\n      maskAllText,\n      unblockSelector,\n      maskTextClass,\n      unmaskTextClass,\n      maskTextSelector,\n      unmaskTextSelector,\n      skipChild,\n      inlineStylesheet,\n      maskInputOptions,\n      maskAttributeFn,\n      maskTextFn,\n      maskInputFn,\n      slimDOMOptions,\n      dataURLOptions,\n      inlineImages,\n      recordCanvas,\n      preserveWhiteSpace,\n      onSerialize,\n      onIframeLoad,\n      iframeLoadTimeout,\n      onBlockedImageLoad,\n      onStylesheetLoad,\n      stylesheetLoadTimeout,\n      keepIframeSrcFn,\n      ignoreCSSAttributes\n    };\n    const childNodes = n2.childNodes ? Array.from(n2.childNodes) : [];\n    for (const childN of childNodes) {\n      const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n      if (serializedChildNode) {\n        serializedNode2.childNodes.push(serializedChildNode);\n      }\n    }\n    if (isElement(n2) && n2.shadowRoot) {\n      for (const childN of Array.from(n2.shadowRoot.childNodes)) {\n        const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n        if (serializedChildNode) {\n          isNativeShadowDom(n2.shadowRoot) && (serializedChildNode.isShadow = true);\n          serializedNode2.childNodes.push(serializedChildNode);\n        }\n      }\n    }\n  }\n  if (n2.parentNode && isShadowRoot(n2.parentNode) && isNativeShadowDom(n2.parentNode)) {\n    serializedNode2.isShadow = true;\n  }\n  if (serializedNode2.type === NodeType$2.Element && serializedNode2.tagName === \"iframe\" && !serializedNode2.needBlock) {\n    onceIframeLoaded(\n      n2,\n      () => {\n        const iframeDoc = getIframeContentDocument(n2);\n        if (iframeDoc && onIframeLoad) {\n          const serializedIframeNode = serializeNodeWithId(iframeDoc, {\n            doc: iframeDoc,\n            mirror: mirror2,\n            blockClass,\n            blockSelector,\n            unblockSelector,\n            maskAllText,\n            maskTextClass,\n            unmaskTextClass,\n            maskTextSelector,\n            unmaskTextSelector,\n            skipChild: false,\n            inlineStylesheet,\n            maskInputOptions,\n            maskAttributeFn,\n            maskTextFn,\n            maskInputFn,\n            slimDOMOptions,\n            dataURLOptions,\n            inlineImages,\n            recordCanvas,\n            preserveWhiteSpace,\n            onSerialize,\n            onIframeLoad,\n            iframeLoadTimeout,\n            onStylesheetLoad,\n            stylesheetLoadTimeout,\n            keepIframeSrcFn,\n            ignoreCSSAttributes\n          });\n          if (serializedIframeNode) {\n            onIframeLoad(\n              n2,\n              serializedIframeNode\n            );\n          }\n        }\n      },\n      iframeLoadTimeout\n    );\n  }\n  if (serializedNode2.type === NodeType$2.Element && serializedNode2.tagName === \"img\" && !n2.complete && serializedNode2.needBlock) {\n    const image = n2;\n    const updateImageDimensions = () => {\n      if (image.isConnected && !image.complete && onBlockedImageLoad) {\n        try {\n          const rect = image.getBoundingClientRect();\n          if (rect.width > 0 && rect.height > 0) {\n            onBlockedImageLoad(image, serializedNode2, rect);\n          }\n        } catch (error) {\n        }\n      }\n      image.removeEventListener(\"load\", updateImageDimensions);\n    };\n    if (image.isConnected) {\n      image.addEventListener(\"load\", updateImageDimensions);\n    }\n  }\n  if (serializedNode2.type === NodeType$2.Element && serializedNode2.tagName === \"link\" && typeof serializedNode2.attributes.rel === \"string\" && (serializedNode2.attributes.rel === \"stylesheet\" || serializedNode2.attributes.rel === \"preload\" && typeof serializedNode2.attributes.href === \"string\" && extractFileExtension(serializedNode2.attributes.href) === \"css\")) {\n    onceStylesheetLoaded(\n      n2,\n      () => {\n        if (onStylesheetLoad) {\n          const serializedLinkNode = serializeNodeWithId(n2, {\n            doc,\n            mirror: mirror2,\n            blockClass,\n            blockSelector,\n            unblockSelector,\n            maskAllText,\n            maskTextClass,\n            unmaskTextClass,\n            maskTextSelector,\n            unmaskTextSelector,\n            skipChild: false,\n            inlineStylesheet,\n            maskInputOptions,\n            maskAttributeFn,\n            maskTextFn,\n            maskInputFn,\n            slimDOMOptions,\n            dataURLOptions,\n            inlineImages,\n            recordCanvas,\n            preserveWhiteSpace,\n            onSerialize,\n            onIframeLoad,\n            iframeLoadTimeout,\n            onStylesheetLoad,\n            stylesheetLoadTimeout,\n            keepIframeSrcFn,\n            ignoreCSSAttributes\n          });\n          if (serializedLinkNode) {\n            onStylesheetLoad(\n              n2,\n              serializedLinkNode\n            );\n          }\n        }\n      },\n      stylesheetLoadTimeout\n    );\n  }\n  if (serializedNode2.type === NodeType$2.Element) {\n    delete serializedNode2.needBlock;\n  }\n  return serializedNode2;\n}\nfunction snapshot(n2, options) {\n  const {\n    mirror: mirror2 = new Mirror(),\n    blockClass = \"rr-block\",\n    blockSelector = null,\n    unblockSelector = null,\n    maskAllText = false,\n    maskTextClass = \"rr-mask\",\n    unmaskTextClass = null,\n    maskTextSelector = null,\n    unmaskTextSelector = null,\n    inlineStylesheet = true,\n    inlineImages = false,\n    recordCanvas = false,\n    maskAllInputs = false,\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    slimDOM = false,\n    dataURLOptions,\n    preserveWhiteSpace,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout,\n    onBlockedImageLoad,\n    onStylesheetLoad,\n    stylesheetLoadTimeout,\n    keepIframeSrcFn = () => false,\n    ignoreCSSAttributes = /* @__PURE__ */ new Set([])\n  } = options || {};\n  const maskInputOptions = maskAllInputs === true ? {\n    color: true,\n    date: true,\n    \"datetime-local\": true,\n    email: true,\n    month: true,\n    number: true,\n    range: true,\n    search: true,\n    tel: true,\n    text: true,\n    time: true,\n    url: true,\n    week: true,\n    textarea: true,\n    select: true\n  } : maskAllInputs === false ? {} : maskAllInputs;\n  const slimDOMOptions = slimDOM === true || slimDOM === \"all\" ? (\n    // if true: set of sensible options that should not throw away any information\n    {\n      script: true,\n      comment: true,\n      headFavicon: true,\n      headWhitespace: true,\n      headMetaDescKeywords: slimDOM === \"all\",\n      // destructive\n      headMetaSocial: true,\n      headMetaRobots: true,\n      headMetaHttpEquiv: true,\n      headMetaAuthorship: true,\n      headMetaVerification: true\n    }\n  ) : slimDOM === false ? {} : slimDOM;\n  return serializeNodeWithId(n2, {\n    doc: n2,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    maskAllText,\n    maskTextClass,\n    unmaskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    skipChild: false,\n    inlineStylesheet,\n    maskInputOptions,\n    maskAttributeFn,\n    maskTextFn,\n    maskInputFn,\n    slimDOMOptions,\n    dataURLOptions,\n    inlineImages,\n    recordCanvas,\n    preserveWhiteSpace,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout,\n    onBlockedImageLoad,\n    onStylesheetLoad,\n    stylesheetLoadTimeout,\n    keepIframeSrcFn,\n    newlyAddedElement: false,\n    ignoreCSSAttributes\n  });\n}\nconst commentre = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\nfunction parse(css, options = {}) {\n  let lineno = 1;\n  let column = 1;\n  function updatePosition(str) {\n    const lines = str.match(/\\n/g);\n    if (lines) {\n      lineno += lines.length;\n    }\n    const i2 = str.lastIndexOf(\"\\n\");\n    column = i2 === -1 ? column + str.length : str.length - i2;\n  }\n  function position() {\n    const start = { line: lineno, column };\n    return (node) => {\n      node.position = new Position(start);\n      whitespace();\n      return node;\n    };\n  }\n  const _Position = class _Position2 {\n    constructor(start) {\n      __publicField$1(this, \"content\");\n      __publicField$1(this, \"start\");\n      __publicField$1(this, \"end\");\n      __publicField$1(this, \"source\");\n      this.start = start;\n      this.end = { line: lineno, column };\n      this.source = options.source;\n      this.content = _Position2.content;\n    }\n  };\n  __publicField$1(_Position, \"content\");\n  let Position = _Position;\n  Position.content = css;\n  const errorsList = [];\n  function error(msg) {\n    const err = new Error(\n      `${options.source || \"\"}:${lineno}:${column}: ${msg}`\n    );\n    err.reason = msg;\n    err.filename = options.source;\n    err.line = lineno;\n    err.column = column;\n    err.source = css;\n    if (options.silent) {\n      errorsList.push(err);\n    } else {\n      throw err;\n    }\n  }\n  function stylesheet() {\n    const rulesList = rules2();\n    return {\n      type: \"stylesheet\",\n      stylesheet: {\n        source: options.source,\n        rules: rulesList,\n        parsingErrors: errorsList\n      }\n    };\n  }\n  function open() {\n    return match(/^{\\s*/);\n  }\n  function close() {\n    return match(/^}/);\n  }\n  function rules2() {\n    let node;\n    const rules22 = [];\n    whitespace();\n    comments(rules22);\n    while (css.length && css.charAt(0) !== \"}\" && (node = atrule() || rule())) {\n      if (node) {\n        rules22.push(node);\n        comments(rules22);\n      }\n    }\n    return rules22;\n  }\n  function match(re) {\n    const m = re.exec(css);\n    if (!m) {\n      return;\n    }\n    const str = m[0];\n    updatePosition(str);\n    css = css.slice(str.length);\n    return m;\n  }\n  function whitespace() {\n    match(/^\\s*/);\n  }\n  function comments(rules22 = []) {\n    let c2;\n    while (c2 = comment()) {\n      if (c2) {\n        rules22.push(c2);\n      }\n      c2 = comment();\n    }\n    return rules22;\n  }\n  function comment() {\n    const pos = position();\n    if (\"/\" !== css.charAt(0) || \"*\" !== css.charAt(1)) {\n      return;\n    }\n    let i2 = 2;\n    while (\"\" !== css.charAt(i2) && (\"*\" !== css.charAt(i2) || \"/\" !== css.charAt(i2 + 1))) {\n      ++i2;\n    }\n    i2 += 2;\n    if (\"\" === css.charAt(i2 - 1)) {\n      return error(\"End of comment missing\");\n    }\n    const str = css.slice(2, i2 - 2);\n    column += 2;\n    updatePosition(str);\n    css = css.slice(i2);\n    column += 2;\n    return pos({\n      type: \"comment\",\n      comment: str\n    });\n  }\n  function selector() {\n    const m = match(/^([^{]+)/);\n    if (!m) {\n      return;\n    }\n    const splitSelectors = trim(m[0]).replace(/\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*\\/+/g, \"\").replace(/\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'/g, (m2) => {\n      return m2.replace(/,/g, \"\");\n    }).split(/\\s*(?![^(]*\\)),\\s*/);\n    if (splitSelectors.length <= 1) {\n      return splitSelectors.map((s2) => {\n        return s2.replace(/\\u200C/g, \",\");\n      });\n    }\n    let i2 = 0;\n    let j = 0;\n    const len = splitSelectors.length;\n    const finalSelectors = [];\n    while (i2 < len) {\n      const openingParensCount = (splitSelectors[i2].match(/\\(/g) || []).length;\n      const closingParensCount = (splitSelectors[i2].match(/\\)/g) || []).length;\n      let unbalancedParens = openingParensCount - closingParensCount;\n      if (unbalancedParens >= 1) {\n        let foundClosingSelector = false;\n        j = i2 + 1;\n        while (j < len) {\n          const nextOpeningParensCount = (splitSelectors[j].match(/\\(/g) || []).length;\n          const nextClosingParensCount = (splitSelectors[j].match(/\\)/g) || []).length;\n          const nextUnbalancedParens = nextClosingParensCount - nextOpeningParensCount;\n          if (nextUnbalancedParens === unbalancedParens) {\n            finalSelectors.push(splitSelectors.slice(i2, j + 1).join(\",\"));\n            i2 = j + 1;\n            foundClosingSelector = true;\n            break;\n          }\n          j++;\n          unbalancedParens -= nextUnbalancedParens;\n        }\n        if (foundClosingSelector) {\n          continue;\n        }\n        splitSelectors.slice(i2, len).forEach((selector2) => selector2 && finalSelectors.push(selector2));\n        break;\n      }\n      splitSelectors[i2] && finalSelectors.push(splitSelectors[i2]);\n      i2++;\n    }\n    return finalSelectors.map((s2) => {\n      return s2.replace(/\\u200C/g, \",\");\n    });\n  }\n  function declaration() {\n    const pos = position();\n    const propMatch = match(/^(\\*?[-#\\/\\*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/);\n    if (!propMatch) {\n      return;\n    }\n    const prop = trim(propMatch[0]);\n    if (!match(/^:\\s*/)) {\n      return error(`property missing ':'`);\n    }\n    const val = match(/^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^\\)]*?\\)|[^};])+)/);\n    const ret = pos({\n      type: \"declaration\",\n      property: prop.replace(commentre, \"\"),\n      value: val ? trim(val[0]).replace(commentre, \"\") : \"\"\n    });\n    match(/^[;\\s]*/);\n    return ret;\n  }\n  function declarations() {\n    const decls = [];\n    if (!open()) {\n      return error(`missing '{'`);\n    }\n    comments(decls);\n    let decl;\n    while (decl = declaration()) {\n      if (decl !== false) {\n        decls.push(decl);\n        comments(decls);\n      }\n      decl = declaration();\n    }\n    if (!close()) {\n      return error(`missing '}'`);\n    }\n    return decls;\n  }\n  function keyframe() {\n    let m;\n    const vals = [];\n    const pos = position();\n    while (m = match(/^((\\d+\\.\\d+|\\.\\d+|\\d+)%?|[a-z]+)\\s*/)) {\n      vals.push(m[1]);\n      match(/^,\\s*/);\n    }\n    if (!vals.length) {\n      return;\n    }\n    return pos({\n      type: \"keyframe\",\n      values: vals,\n      declarations: declarations()\n    });\n  }\n  function atkeyframes() {\n    const pos = position();\n    let m = match(/^@([-\\w]+)?keyframes\\s*/);\n    if (!m) {\n      return;\n    }\n    const vendor = m[1];\n    m = match(/^([-\\w]+)\\s*/);\n    if (!m) {\n      return error(\"@keyframes missing name\");\n    }\n    const name = m[1];\n    if (!open()) {\n      return error(`@keyframes missing '{'`);\n    }\n    let frame;\n    let frames = comments();\n    while (frame = keyframe()) {\n      frames.push(frame);\n      frames = frames.concat(comments());\n    }\n    if (!close()) {\n      return error(`@keyframes missing '}'`);\n    }\n    return pos({\n      type: \"keyframes\",\n      name,\n      vendor,\n      keyframes: frames\n    });\n  }\n  function atsupports() {\n    const pos = position();\n    const m = match(/^@supports *([^{]+)/);\n    if (!m) {\n      return;\n    }\n    const supports = trim(m[1]);\n    if (!open()) {\n      return error(`@supports missing '{'`);\n    }\n    const style = comments().concat(rules2());\n    if (!close()) {\n      return error(`@supports missing '}'`);\n    }\n    return pos({\n      type: \"supports\",\n      supports,\n      rules: style\n    });\n  }\n  function athost() {\n    const pos = position();\n    const m = match(/^@host\\s*/);\n    if (!m) {\n      return;\n    }\n    if (!open()) {\n      return error(`@host missing '{'`);\n    }\n    const style = comments().concat(rules2());\n    if (!close()) {\n      return error(`@host missing '}'`);\n    }\n    return pos({\n      type: \"host\",\n      rules: style\n    });\n  }\n  function atmedia() {\n    const pos = position();\n    const m = match(/^@media *([^{]+)/);\n    if (!m) {\n      return;\n    }\n    const media = trim(m[1]);\n    if (!open()) {\n      return error(`@media missing '{'`);\n    }\n    const style = comments().concat(rules2());\n    if (!close()) {\n      return error(`@media missing '}'`);\n    }\n    return pos({\n      type: \"media\",\n      media,\n      rules: style\n    });\n  }\n  function atcustommedia() {\n    const pos = position();\n    const m = match(/^@custom-media\\s+(--[^\\s]+)\\s*([^{;]+);/);\n    if (!m) {\n      return;\n    }\n    return pos({\n      type: \"custom-media\",\n      name: trim(m[1]),\n      media: trim(m[2])\n    });\n  }\n  function atpage() {\n    const pos = position();\n    const m = match(/^@page */);\n    if (!m) {\n      return;\n    }\n    const sel = selector() || [];\n    if (!open()) {\n      return error(`@page missing '{'`);\n    }\n    let decls = comments();\n    let decl;\n    while (decl = declaration()) {\n      decls.push(decl);\n      decls = decls.concat(comments());\n    }\n    if (!close()) {\n      return error(`@page missing '}'`);\n    }\n    return pos({\n      type: \"page\",\n      selectors: sel,\n      declarations: decls\n    });\n  }\n  function atdocument() {\n    const pos = position();\n    const m = match(/^@([-\\w]+)?document *([^{]+)/);\n    if (!m) {\n      return;\n    }\n    const vendor = trim(m[1]);\n    const doc = trim(m[2]);\n    if (!open()) {\n      return error(`@document missing '{'`);\n    }\n    const style = comments().concat(rules2());\n    if (!close()) {\n      return error(`@document missing '}'`);\n    }\n    return pos({\n      type: \"document\",\n      document: doc,\n      vendor,\n      rules: style\n    });\n  }\n  function atfontface() {\n    const pos = position();\n    const m = match(/^@font-face\\s*/);\n    if (!m) {\n      return;\n    }\n    if (!open()) {\n      return error(`@font-face missing '{'`);\n    }\n    let decls = comments();\n    let decl;\n    while (decl = declaration()) {\n      decls.push(decl);\n      decls = decls.concat(comments());\n    }\n    if (!close()) {\n      return error(`@font-face missing '}'`);\n    }\n    return pos({\n      type: \"font-face\",\n      declarations: decls\n    });\n  }\n  const atimport = _compileAtrule(\"import\");\n  const atcharset = _compileAtrule(\"charset\");\n  const atnamespace = _compileAtrule(\"namespace\");\n  function _compileAtrule(name) {\n    const re = new RegExp(\n      \"^@\" + name + \"\\\\s*((?:\" + [\n        /[^\\\\]\"(?:\\\\\"|[^\"])*\"/.source,\n        // consume any quoted parts (checking that the double quote isn't itself escaped)\n        /[^\\\\]'(?:\\\\'|[^'])*'/.source,\n        // same but for single quotes\n        \"[^;]\"\n      ].join(\"|\") + \")+);\"\n    );\n    return () => {\n      const pos = position();\n      const m = match(re);\n      if (!m) {\n        return;\n      }\n      const ret = { type: name };\n      ret[name] = m[1].trim();\n      return pos(ret);\n    };\n  }\n  function atrule() {\n    if (css[0] !== \"@\") {\n      return;\n    }\n    return atkeyframes() || atmedia() || atcustommedia() || atsupports() || atimport() || atcharset() || atnamespace() || atdocument() || atpage() || athost() || atfontface();\n  }\n  function rule() {\n    const pos = position();\n    const sel = selector();\n    if (!sel) {\n      return error(\"selector missing\");\n    }\n    comments();\n    return pos({\n      type: \"rule\",\n      selectors: sel,\n      declarations: declarations()\n    });\n  }\n  return addParent(stylesheet());\n}\nfunction trim(str) {\n  return str ? str.replace(/^\\s+|\\s+$/g, \"\") : \"\";\n}\nfunction addParent(obj, parent) {\n  const isNode = obj && typeof obj.type === \"string\";\n  const childParent = isNode ? obj : parent;\n  for (const k of Object.keys(obj)) {\n    const value = obj[k];\n    if (Array.isArray(value)) {\n      value.forEach((v2) => {\n        addParent(v2, childParent);\n      });\n    } else if (value && typeof value === \"object\") {\n      addParent(value, childParent);\n    }\n  }\n  if (isNode) {\n    Object.defineProperty(obj, \"parent\", {\n      configurable: true,\n      writable: true,\n      enumerable: false,\n      value: parent || null\n    });\n  }\n  return obj;\n}\nconst tagMap = {\n  script: \"noscript\",\n  // camel case svg element tag names\n  altglyph: \"altGlyph\",\n  altglyphdef: \"altGlyphDef\",\n  altglyphitem: \"altGlyphItem\",\n  animatecolor: \"animateColor\",\n  animatemotion: \"animateMotion\",\n  animatetransform: \"animateTransform\",\n  clippath: \"clipPath\",\n  feblend: \"feBlend\",\n  fecolormatrix: \"feColorMatrix\",\n  fecomponenttransfer: \"feComponentTransfer\",\n  fecomposite: \"feComposite\",\n  feconvolvematrix: \"feConvolveMatrix\",\n  fediffuselighting: \"feDiffuseLighting\",\n  fedisplacementmap: \"feDisplacementMap\",\n  fedistantlight: \"feDistantLight\",\n  fedropshadow: \"feDropShadow\",\n  feflood: \"feFlood\",\n  fefunca: \"feFuncA\",\n  fefuncb: \"feFuncB\",\n  fefuncg: \"feFuncG\",\n  fefuncr: \"feFuncR\",\n  fegaussianblur: \"feGaussianBlur\",\n  feimage: \"feImage\",\n  femerge: \"feMerge\",\n  femergenode: \"feMergeNode\",\n  femorphology: \"feMorphology\",\n  feoffset: \"feOffset\",\n  fepointlight: \"fePointLight\",\n  fespecularlighting: \"feSpecularLighting\",\n  fespotlight: \"feSpotLight\",\n  fetile: \"feTile\",\n  feturbulence: \"feTurbulence\",\n  foreignobject: \"foreignObject\",\n  glyphref: \"glyphRef\",\n  lineargradient: \"linearGradient\",\n  radialgradient: \"radialGradient\"\n};\nfunction getTagName(n2) {\n  let tagName = tagMap[n2.tagName] ? tagMap[n2.tagName] : n2.tagName;\n  if (tagName === \"link\" && n2.attributes._cssText) {\n    tagName = \"style\";\n  }\n  return tagName;\n}\nfunction escapeRegExp(str) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nconst HOVER_SELECTOR = /([^\\\\]):hover/;\nconst HOVER_SELECTOR_GLOBAL = new RegExp(HOVER_SELECTOR.source, \"g\");\nfunction addHoverClass(cssText, cache) {\n  const cachedStyle = cache?.stylesWithHoverClass.get(cssText);\n  if (cachedStyle) return cachedStyle;\n  if (cssText.length >= 1e6) {\n    return cssText;\n  }\n  const ast = parse(cssText, {\n    silent: true\n  });\n  if (!ast.stylesheet) {\n    return cssText;\n  }\n  const selectors = [];\n  ast.stylesheet.rules.forEach((rule) => {\n    if (\"selectors\" in rule) {\n      (rule.selectors || []).forEach((selector) => {\n        if (HOVER_SELECTOR.test(selector)) {\n          selectors.push(selector);\n        }\n      });\n    }\n  });\n  if (selectors.length === 0) {\n    return cssText;\n  }\n  const selectorMatcher = new RegExp(\n    selectors.filter((selector, index) => selectors.indexOf(selector) === index).sort((a2, b) => b.length - a2.length).map((selector) => {\n      return escapeRegExp(selector);\n    }).join(\"|\"),\n    \"g\"\n  );\n  const result = cssText.replace(selectorMatcher, (selector) => {\n    const newSelector = selector.replace(HOVER_SELECTOR_GLOBAL, \"$1.\\\\:hover\");\n    return `${selector}, ${newSelector}`;\n  });\n  cache?.stylesWithHoverClass.set(cssText, result);\n  return result;\n}\nfunction createCache() {\n  const stylesWithHoverClass = /* @__PURE__ */ new Map();\n  return {\n    stylesWithHoverClass\n  };\n}\nfunction buildNode(n2, options) {\n  const { doc, hackCss, cache } = options;\n  switch (n2.type) {\n    case NodeType$2.Document:\n      return doc.implementation.createDocument(null, \"\", null);\n    case NodeType$2.DocumentType:\n      return doc.implementation.createDocumentType(\n        n2.name || \"html\",\n        n2.publicId,\n        n2.systemId\n      );\n    case NodeType$2.Element: {\n      const tagName = getTagName(n2);\n      let node;\n      if (n2.isSVG) {\n        node = doc.createElementNS(\"http://www.w3.org/2000/svg\", tagName);\n      } else {\n        if (\n          // If the tag name is a custom element name\n          n2.isCustom && // If the browser supports custom elements\n          doc.defaultView?.customElements && // If the custom element hasn't been defined yet\n          !doc.defaultView.customElements.get(n2.tagName)\n        )\n          doc.defaultView.customElements.define(\n            n2.tagName,\n            class extends doc.defaultView.HTMLElement {\n            }\n          );\n        node = doc.createElement(tagName);\n      }\n      const specialAttributes = {};\n      for (const name in n2.attributes) {\n        if (!Object.prototype.hasOwnProperty.call(n2.attributes, name)) {\n          continue;\n        }\n        let value = n2.attributes[name];\n        if (tagName === \"option\" && name === \"selected\" && value === false) {\n          continue;\n        }\n        if (value === null) {\n          continue;\n        }\n        if (value === true) value = \"\";\n        if (name.startsWith(\"rr_\")) {\n          specialAttributes[name] = value;\n          continue;\n        }\n        const isTextarea = tagName === \"textarea\" && name === \"value\";\n        const isRemoteOrDynamicCss = tagName === \"style\" && name === \"_cssText\";\n        if (isRemoteOrDynamicCss && hackCss && typeof value === \"string\") {\n          value = addHoverClass(value, cache);\n        }\n        if ((isTextarea || isRemoteOrDynamicCss) && typeof value === \"string\") {\n          const child = doc.createTextNode(value);\n          for (const c2 of Array.from(node.childNodes)) {\n            if (c2.nodeType === node.TEXT_NODE) {\n              node.removeChild(c2);\n            }\n          }\n          node.appendChild(child);\n          continue;\n        }\n        try {\n          if (n2.isSVG && name === \"xlink:href\") {\n            node.setAttributeNS(\n              \"http://www.w3.org/1999/xlink\",\n              name,\n              value.toString()\n            );\n          } else if (name === \"onload\" || name === \"onclick\" || name.substring(0, 7) === \"onmouse\") {\n            node.setAttribute(\"_\" + name, value.toString());\n          } else if (tagName === \"meta\" && n2.attributes[\"http-equiv\"] === \"Content-Security-Policy\" && name === \"content\") {\n            node.setAttribute(\"csp-content\", value.toString());\n            continue;\n          } else if (tagName === \"link\" && (n2.attributes.rel === \"preload\" || n2.attributes.rel === \"modulepreload\")) {\n          } else if (tagName === \"link\" && n2.attributes.rel === \"prefetch\" && typeof n2.attributes.href === \"string\" && extractFileExtension(n2.attributes.href) === \"js\") {\n          } else if (tagName === \"img\" && n2.attributes.srcset && n2.attributes.rr_dataURL) {\n            node.setAttribute(\n              \"rrweb-original-srcset\",\n              n2.attributes.srcset\n            );\n          } else {\n            node.setAttribute(name, value.toString());\n          }\n        } catch (error) {\n        }\n      }\n      for (const name in specialAttributes) {\n        const value = specialAttributes[name];\n        if (tagName === \"canvas\" && name === \"rr_dataURL\") {\n          const image = doc.createElement(\"img\");\n          image.onload = () => {\n            const ctx = node.getContext(\"2d\");\n            if (ctx) {\n              ctx.drawImage(image, 0, 0, image.width, image.height);\n            }\n          };\n          image.src = value.toString();\n          if (node.RRNodeType)\n            node.rr_dataURL = value.toString();\n        } else if (tagName === \"img\" && name === \"rr_dataURL\") {\n          const image = node;\n          if (!image.currentSrc.startsWith(\"data:\")) {\n            image.setAttribute(\n              \"rrweb-original-src\",\n              n2.attributes.src\n            );\n            image.src = value.toString();\n          }\n        }\n        if (name === \"rr_width\") {\n          node.style.setProperty(\"width\", value.toString());\n        } else if (name === \"rr_height\") {\n          node.style.setProperty(\"height\", value.toString());\n        } else if (name === \"rr_mediaCurrentTime\" && typeof value === \"number\") {\n          node.currentTime = value;\n        } else if (name === \"rr_mediaState\") {\n          switch (value) {\n            case \"played\":\n              node.play().catch((e2) => console.warn(\"media playback error\", e2));\n              break;\n            case \"paused\":\n              node.pause();\n              break;\n          }\n        }\n      }\n      if (n2.isShadowHost) {\n        if (!node.shadowRoot) {\n          node.attachShadow({ mode: \"open\" });\n        } else {\n          while (node.shadowRoot.firstChild) {\n            node.shadowRoot.removeChild(node.shadowRoot.firstChild);\n          }\n        }\n      }\n      return node;\n    }\n    case NodeType$2.Text:\n      return doc.createTextNode(\n        n2.isStyle && hackCss ? addHoverClass(n2.textContent, cache) : n2.textContent\n      );\n    case NodeType$2.CDATA:\n      if (!(doc instanceof XMLDocument)) {\n        return null;\n      }\n      return doc.createCDATASection(n2.textContent);\n    case NodeType$2.Comment:\n      return doc.createComment(n2.textContent);\n    default:\n      return null;\n  }\n}\nfunction buildNodeWithSN(n2, options) {\n  const {\n    doc,\n    mirror: mirror2,\n    skipChild = false,\n    hackCss = true,\n    afterAppend,\n    cache\n  } = options;\n  if (mirror2.has(n2.id)) {\n    const nodeInMirror = mirror2.getNode(n2.id);\n    const meta = mirror2.getMeta(nodeInMirror);\n    if (isNodeMetaEqual(meta, n2)) return mirror2.getNode(n2.id);\n  }\n  let node = buildNode(n2, { doc, hackCss, cache });\n  if (!node) {\n    return null;\n  }\n  if (n2.rootId && mirror2.getNode(n2.rootId) !== doc) {\n    mirror2.replace(n2.rootId, doc);\n  }\n  if (n2.type === NodeType$2.Document) {\n    doc.close();\n    doc.open();\n    if (n2.compatMode === \"BackCompat\" && n2.childNodes && n2.childNodes[0].type !== NodeType$2.DocumentType) {\n      if (n2.childNodes[0].type === NodeType$2.Element && \"xmlns\" in n2.childNodes[0].attributes && n2.childNodes[0].attributes.xmlns === \"http://www.w3.org/1999/xhtml\") {\n        doc.write(\n          '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"\">'\n        );\n      } else {\n        doc.write(\n          '<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"\">'\n        );\n      }\n    }\n    node = doc;\n  }\n  mirror2.add(node, n2);\n  if ((n2.type === NodeType$2.Document || n2.type === NodeType$2.Element) && !skipChild) {\n    for (const childN of n2.childNodes) {\n      const childNode = buildNodeWithSN(childN, {\n        doc,\n        mirror: mirror2,\n        skipChild: false,\n        hackCss,\n        afterAppend,\n        cache\n      });\n      if (!childNode) {\n        console.warn(\"Failed to rebuild\", childN);\n        continue;\n      }\n      if (childN.isShadow && isElement(node) && node.shadowRoot) {\n        node.shadowRoot.appendChild(childNode);\n      } else if (n2.type === NodeType$2.Document && childN.type == NodeType$2.Element) {\n        const htmlElement = childNode;\n        let body = null;\n        htmlElement.childNodes.forEach((child) => {\n          if (child.nodeName === \"BODY\") body = child;\n        });\n        if (body) {\n          htmlElement.removeChild(body);\n          node.appendChild(childNode);\n          htmlElement.appendChild(body);\n        } else {\n          node.appendChild(childNode);\n        }\n      } else {\n        node.appendChild(childNode);\n      }\n      if (afterAppend) {\n        afterAppend(childNode, childN.id);\n      }\n    }\n  }\n  return node;\n}\nfunction visit(mirror2, onVisit) {\n  function walk(node) {\n    onVisit(node);\n  }\n  for (const id of mirror2.getIds()) {\n    if (mirror2.has(id)) {\n      walk(mirror2.getNode(id));\n    }\n  }\n}\nfunction handleScroll(node, mirror2) {\n  const n2 = mirror2.getMeta(node);\n  if (n2?.type !== NodeType$2.Element) {\n    return;\n  }\n  const el = node;\n  for (const name in n2.attributes) {\n    if (!(Object.prototype.hasOwnProperty.call(n2.attributes, name) && name.startsWith(\"rr_\"))) {\n      continue;\n    }\n    const value = n2.attributes[name];\n    if (name === \"rr_scrollLeft\") {\n      el.scrollLeft = value;\n    }\n    if (name === \"rr_scrollTop\") {\n      el.scrollTop = value;\n    }\n  }\n}\nfunction rebuild(n2, options) {\n  const {\n    doc,\n    onVisit,\n    hackCss = true,\n    afterAppend,\n    cache,\n    mirror: mirror2 = new Mirror()\n  } = options;\n  const node = buildNodeWithSN(n2, {\n    doc,\n    mirror: mirror2,\n    skipChild: false,\n    hackCss,\n    afterAppend,\n    cache\n  });\n  visit(mirror2, (visitedNode) => {\n    if (onVisit) {\n      onVisit(visitedNode);\n    }\n    handleScroll(visitedNode, mirror2);\n  });\n  return node;\n}\nfunction on(type, fn, target = document) {\n  const options = { capture: true, passive: true };\n  target.addEventListener(type, fn, options);\n  return () => target.removeEventListener(type, fn, options);\n}\nconst DEPARTED_MIRROR_ACCESS_WARNING = \"Please stop import mirror directly. Instead of that,\\r\\nnow you can use replayer.getMirror() to access the mirror instance of a replayer,\\r\\nor you can use record.mirror to access the mirror instance during recording.\";\nlet _mirror = {\n  map: {},\n  getId() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return -1;\n  },\n  getNode() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return null;\n  },\n  removeNodeFromMap() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n  },\n  has() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    return false;\n  },\n  reset() {\n    console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n  }\n};\nif (typeof window !== \"undefined\" && window.Proxy && window.Reflect) {\n  _mirror = new Proxy(_mirror, {\n    get(target, prop, receiver) {\n      if (prop === \"map\") {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n      }\n      return Reflect.get(target, prop, receiver);\n    }\n  });\n}\nfunction throttle(func, wait, options = {}) {\n  let timeout = null;\n  let previous = 0;\n  return function(...args) {\n    const now = Date.now();\n    if (!previous && options.leading === false) {\n      previous = now;\n    }\n    const remaining = wait - (now - previous);\n    const context = this;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      func.apply(context, args);\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout$1(() => {\n        previous = options.leading === false ? 0 : Date.now();\n        timeout = null;\n        func.apply(context, args);\n      }, remaining);\n    }\n  };\n}\nfunction hookSetter(target, key, d, isRevoked, win = window) {\n  const original = win.Object.getOwnPropertyDescriptor(target, key);\n  win.Object.defineProperty(\n    target,\n    key,\n    isRevoked ? d : {\n      set(value) {\n        setTimeout$1(() => {\n          d.set.call(this, value);\n        }, 0);\n        if (original && original.set) {\n          original.set.call(this, value);\n        }\n      }\n    }\n  );\n  return () => hookSetter(target, key, original || {}, true);\n}\nfunction patch(source, name, replacement) {\n  try {\n    if (!(name in source)) {\n      return () => {\n      };\n    }\n    const original = source[name];\n    const wrapped = replacement(original);\n    if (typeof wrapped === \"function\") {\n      wrapped.prototype = wrapped.prototype || {};\n      Object.defineProperties(wrapped, {\n        __rrweb_original__: {\n          enumerable: false,\n          value: original\n        }\n      });\n    }\n    source[name] = wrapped;\n    return () => {\n      source[name] = original;\n    };\n  } catch {\n    return () => {\n    };\n  }\n}\nlet nowTimestamp = Date.now;\nif (!/* @__PURE__ */ /[1-9][0-9]{12}/.test(Date.now().toString())) {\n  nowTimestamp = () => (/* @__PURE__ */ new Date()).getTime();\n}\nfunction getWindowScroll(win) {\n  const doc = win.document;\n  return {\n    left: doc.scrollingElement ? doc.scrollingElement.scrollLeft : win.pageXOffset !== void 0 ? win.pageXOffset : doc?.documentElement.scrollLeft || doc?.body?.parentElement?.scrollLeft || doc?.body?.scrollLeft || 0,\n    top: doc.scrollingElement ? doc.scrollingElement.scrollTop : win.pageYOffset !== void 0 ? win.pageYOffset : doc?.documentElement.scrollTop || doc?.body?.parentElement?.scrollTop || doc?.body?.scrollTop || 0\n  };\n}\nfunction getWindowHeight() {\n  return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight;\n}\nfunction getWindowWidth() {\n  return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth;\n}\nfunction closestElementOfNode(node) {\n  if (!node) {\n    return null;\n  }\n  try {\n    const el = node.nodeType === node.ELEMENT_NODE ? node : node.parentElement;\n    return el;\n  } catch (error) {\n    return null;\n  }\n}\nfunction isBlocked(node, blockClass, blockSelector, unblockSelector, checkAncestors) {\n  if (!node) {\n    return false;\n  }\n  const el = closestElementOfNode(node);\n  if (!el) {\n    return false;\n  }\n  const blockedPredicate = createMatchPredicate(blockClass, blockSelector);\n  if (!checkAncestors) {\n    const isUnblocked = unblockSelector && el.matches(unblockSelector);\n    return blockedPredicate(el) && !isUnblocked;\n  }\n  const blockDistance = distanceToMatch(el, blockedPredicate);\n  let unblockDistance = -1;\n  if (blockDistance < 0) {\n    return false;\n  }\n  if (unblockSelector) {\n    unblockDistance = distanceToMatch(\n      el,\n      createMatchPredicate(null, unblockSelector)\n    );\n  }\n  if (blockDistance > -1 && unblockDistance < 0) {\n    return true;\n  }\n  return blockDistance < unblockDistance;\n}\nfunction isSerialized(n2, mirror2) {\n  return mirror2.getId(n2) !== -1;\n}\nfunction isIgnored(n2, mirror2) {\n  return mirror2.getId(n2) === IGNORED_NODE;\n}\nfunction isAncestorRemoved(target, mirror2) {\n  if (isShadowRoot(target)) {\n    return false;\n  }\n  const id = mirror2.getId(target);\n  if (!mirror2.has(id)) {\n    return true;\n  }\n  if (target.parentNode && target.parentNode.nodeType === target.DOCUMENT_NODE) {\n    return false;\n  }\n  if (!target.parentNode) {\n    return true;\n  }\n  return isAncestorRemoved(target.parentNode, mirror2);\n}\nfunction legacy_isTouchEvent(event) {\n  return Boolean(event.changedTouches);\n}\nfunction polyfill$1(win = window) {\n  if (\"NodeList\" in win && !win.NodeList.prototype.forEach) {\n    win.NodeList.prototype.forEach = Array.prototype.forEach;\n  }\n  if (\"DOMTokenList\" in win && !win.DOMTokenList.prototype.forEach) {\n    win.DOMTokenList.prototype.forEach = Array.prototype.forEach;\n  }\n  if (!Node.prototype.contains) {\n    Node.prototype.contains = (...args) => {\n      let node = args[0];\n      if (!(0 in args)) {\n        throw new TypeError(\"1 argument is required\");\n      }\n      do {\n        if (this === node) {\n          return true;\n        }\n      } while (node = node && node.parentNode);\n      return false;\n    };\n  }\n}\nfunction queueToResolveTrees(queue) {\n  const queueNodeMap = {};\n  const putIntoMap = (m, parent) => {\n    const nodeInTree = {\n      value: m,\n      parent,\n      children: []\n    };\n    queueNodeMap[m.node.id] = nodeInTree;\n    return nodeInTree;\n  };\n  const queueNodeTrees = [];\n  for (const mutation of queue) {\n    const { nextId, parentId } = mutation;\n    if (nextId && nextId in queueNodeMap) {\n      const nextInTree = queueNodeMap[nextId];\n      if (nextInTree.parent) {\n        const idx = nextInTree.parent.children.indexOf(nextInTree);\n        nextInTree.parent.children.splice(\n          idx,\n          0,\n          putIntoMap(mutation, nextInTree.parent)\n        );\n      } else {\n        const idx = queueNodeTrees.indexOf(nextInTree);\n        queueNodeTrees.splice(idx, 0, putIntoMap(mutation, null));\n      }\n      continue;\n    }\n    if (parentId in queueNodeMap) {\n      const parentInTree = queueNodeMap[parentId];\n      parentInTree.children.push(putIntoMap(mutation, parentInTree));\n      continue;\n    }\n    queueNodeTrees.push(putIntoMap(mutation, null));\n  }\n  return queueNodeTrees;\n}\nfunction iterateResolveTree(tree, cb) {\n  cb(tree.value);\n  for (let i2 = tree.children.length - 1; i2 >= 0; i2--) {\n    iterateResolveTree(tree.children[i2], cb);\n  }\n}\nfunction isSerializedIframe(n2, mirror2) {\n  return Boolean(n2.nodeName === \"IFRAME\" && mirror2.getMeta(n2));\n}\nfunction isSerializedStylesheet(n2, mirror2) {\n  return Boolean(\n    n2.nodeName === \"LINK\" && n2.nodeType === n2.ELEMENT_NODE && n2.getAttribute && n2.getAttribute(\"rel\") === \"stylesheet\" && mirror2.getMeta(n2)\n  );\n}\nfunction getBaseDimension(node, rootIframe) {\n  const frameElement = node.ownerDocument?.defaultView?.frameElement;\n  if (!frameElement || frameElement === rootIframe) {\n    return {\n      x: 0,\n      y: 0,\n      relativeScale: 1,\n      absoluteScale: 1\n    };\n  }\n  const frameDimension = frameElement.getBoundingClientRect();\n  const frameBaseDimension = getBaseDimension(frameElement, rootIframe);\n  const relativeScale = frameDimension.height / frameElement.clientHeight;\n  return {\n    x: frameDimension.x * frameBaseDimension.relativeScale + frameBaseDimension.x,\n    y: frameDimension.y * frameBaseDimension.relativeScale + frameBaseDimension.y,\n    relativeScale,\n    absoluteScale: frameBaseDimension.absoluteScale * relativeScale\n  };\n}\nfunction hasShadowRoot(n2) {\n  return Boolean(n2?.shadowRoot);\n}\nfunction getNestedRule(rules2, position) {\n  const rule = rules2[position[0]];\n  if (position.length === 1) {\n    return rule;\n  } else {\n    return getNestedRule(\n      rule.cssRules[position[1]].cssRules,\n      position.slice(2)\n    );\n  }\n}\nfunction getPositionsAndIndex(nestedIndex) {\n  const positions = [...nestedIndex];\n  const index = positions.pop();\n  return { positions, index };\n}\nfunction uniqueTextMutations(mutations) {\n  const idSet = /* @__PURE__ */ new Set();\n  const uniqueMutations = [];\n  for (let i2 = mutations.length; i2--; ) {\n    const mutation = mutations[i2];\n    if (!idSet.has(mutation.id)) {\n      uniqueMutations.push(mutation);\n      idSet.add(mutation.id);\n    }\n  }\n  return uniqueMutations;\n}\nclass StyleSheetMirror {\n  constructor() {\n    this.id = 1;\n    this.styleIDMap = /* @__PURE__ */ new WeakMap();\n    this.idStyleMap = /* @__PURE__ */ new Map();\n  }\n  getId(stylesheet) {\n    return this.styleIDMap.get(stylesheet) ?? -1;\n  }\n  has(stylesheet) {\n    return this.styleIDMap.has(stylesheet);\n  }\n  /**\n   * @returns If the stylesheet is in the mirror, returns the id of the stylesheet. If not, return the new assigned id.\n   */\n  add(stylesheet, id) {\n    if (this.has(stylesheet)) return this.getId(stylesheet);\n    let newId;\n    if (id === void 0) {\n      newId = this.id++;\n    } else newId = id;\n    this.styleIDMap.set(stylesheet, newId);\n    this.idStyleMap.set(newId, stylesheet);\n    return newId;\n  }\n  getStyle(id) {\n    return this.idStyleMap.get(id) || null;\n  }\n  reset() {\n    this.styleIDMap = /* @__PURE__ */ new WeakMap();\n    this.idStyleMap = /* @__PURE__ */ new Map();\n    this.id = 1;\n  }\n  generateId() {\n    return this.id++;\n  }\n}\nfunction getShadowHost(n2) {\n  let shadowHost = null;\n  if (n2.getRootNode?.()?.nodeType === Node.DOCUMENT_FRAGMENT_NODE && n2.getRootNode().host)\n    shadowHost = n2.getRootNode().host;\n  return shadowHost;\n}\nfunction getRootShadowHost(n2) {\n  let rootShadowHost = n2;\n  let shadowHost;\n  while (shadowHost = getShadowHost(rootShadowHost))\n    rootShadowHost = shadowHost;\n  return rootShadowHost;\n}\nfunction shadowHostInDom(n2) {\n  const doc = n2.ownerDocument;\n  if (!doc) return false;\n  const shadowHost = getRootShadowHost(n2);\n  return doc.contains(shadowHost);\n}\nfunction inDom(n2) {\n  const doc = n2.ownerDocument;\n  if (!doc) return false;\n  return doc.contains(n2) || shadowHostInDom(n2);\n}\nconst cachedImplementations = {};\nfunction getImplementation(name) {\n  const cached = cachedImplementations[name];\n  if (cached) {\n    return cached;\n  }\n  const document2 = window.document;\n  let impl = window[name];\n  if (document2 && typeof document2.createElement === \"function\") {\n    try {\n      const sandbox = document2.createElement(\"iframe\");\n      sandbox.hidden = true;\n      document2.head.appendChild(sandbox);\n      const contentWindow = sandbox.contentWindow;\n      if (contentWindow && contentWindow[name]) {\n        impl = // eslint-disable-next-line @typescript-eslint/unbound-method\n        contentWindow[name];\n      }\n      document2.head.removeChild(sandbox);\n    } catch (e2) {\n    }\n  }\n  return cachedImplementations[name] = impl.bind(\n    window\n  );\n}\nfunction onRequestAnimationFrame(...rest) {\n  return getImplementation(\"requestAnimationFrame\")(...rest);\n}\nfunction setTimeout$1(...rest) {\n  return getImplementation(\"setTimeout\")(...rest);\n}\nfunction clearTimeout(...rest) {\n  return getImplementation(\"clearTimeout\")(...rest);\n}\nconst utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  StyleSheetMirror,\n  get _mirror() {\n    return _mirror;\n  },\n  clearTimeout,\n  closestElementOfNode,\n  getBaseDimension,\n  getNestedRule,\n  getPositionsAndIndex,\n  getRootShadowHost,\n  getShadowHost,\n  getWindowHeight,\n  getWindowScroll,\n  getWindowWidth,\n  hasShadowRoot,\n  hookSetter,\n  inDom,\n  isAncestorRemoved,\n  isBlocked,\n  isIgnored,\n  isSerialized,\n  isSerializedIframe,\n  isSerializedStylesheet,\n  iterateResolveTree,\n  legacy_isTouchEvent,\n  get nowTimestamp() {\n    return nowTimestamp;\n  },\n  on,\n  onRequestAnimationFrame,\n  patch,\n  polyfill: polyfill$1,\n  queueToResolveTrees,\n  setTimeout: setTimeout$1,\n  shadowHostInDom,\n  throttle,\n  uniqueTextMutations\n}, Symbol.toStringTag, { value: \"Module\" }));\nvar EventType = /* @__PURE__ */ ((EventType2) => {\n  EventType2[EventType2[\"DomContentLoaded\"] = 0] = \"DomContentLoaded\";\n  EventType2[EventType2[\"Load\"] = 1] = \"Load\";\n  EventType2[EventType2[\"FullSnapshot\"] = 2] = \"FullSnapshot\";\n  EventType2[EventType2[\"IncrementalSnapshot\"] = 3] = \"IncrementalSnapshot\";\n  EventType2[EventType2[\"Meta\"] = 4] = \"Meta\";\n  EventType2[EventType2[\"Custom\"] = 5] = \"Custom\";\n  EventType2[EventType2[\"Plugin\"] = 6] = \"Plugin\";\n  return EventType2;\n})(EventType || {});\nvar IncrementalSource = /* @__PURE__ */ ((IncrementalSource2) => {\n  IncrementalSource2[IncrementalSource2[\"Mutation\"] = 0] = \"Mutation\";\n  IncrementalSource2[IncrementalSource2[\"MouseMove\"] = 1] = \"MouseMove\";\n  IncrementalSource2[IncrementalSource2[\"MouseInteraction\"] = 2] = \"MouseInteraction\";\n  IncrementalSource2[IncrementalSource2[\"Scroll\"] = 3] = \"Scroll\";\n  IncrementalSource2[IncrementalSource2[\"ViewportResize\"] = 4] = \"ViewportResize\";\n  IncrementalSource2[IncrementalSource2[\"Input\"] = 5] = \"Input\";\n  IncrementalSource2[IncrementalSource2[\"TouchMove\"] = 6] = \"TouchMove\";\n  IncrementalSource2[IncrementalSource2[\"MediaInteraction\"] = 7] = \"MediaInteraction\";\n  IncrementalSource2[IncrementalSource2[\"StyleSheetRule\"] = 8] = \"StyleSheetRule\";\n  IncrementalSource2[IncrementalSource2[\"CanvasMutation\"] = 9] = \"CanvasMutation\";\n  IncrementalSource2[IncrementalSource2[\"Font\"] = 10] = \"Font\";\n  IncrementalSource2[IncrementalSource2[\"Log\"] = 11] = \"Log\";\n  IncrementalSource2[IncrementalSource2[\"Drag\"] = 12] = \"Drag\";\n  IncrementalSource2[IncrementalSource2[\"StyleDeclaration\"] = 13] = \"StyleDeclaration\";\n  IncrementalSource2[IncrementalSource2[\"Selection\"] = 14] = \"Selection\";\n  IncrementalSource2[IncrementalSource2[\"AdoptedStyleSheet\"] = 15] = \"AdoptedStyleSheet\";\n  IncrementalSource2[IncrementalSource2[\"CustomElement\"] = 16] = \"CustomElement\";\n  return IncrementalSource2;\n})(IncrementalSource || {});\nvar MouseInteractions = /* @__PURE__ */ ((MouseInteractions2) => {\n  MouseInteractions2[MouseInteractions2[\"MouseUp\"] = 0] = \"MouseUp\";\n  MouseInteractions2[MouseInteractions2[\"MouseDown\"] = 1] = \"MouseDown\";\n  MouseInteractions2[MouseInteractions2[\"Click\"] = 2] = \"Click\";\n  MouseInteractions2[MouseInteractions2[\"ContextMenu\"] = 3] = \"ContextMenu\";\n  MouseInteractions2[MouseInteractions2[\"DblClick\"] = 4] = \"DblClick\";\n  MouseInteractions2[MouseInteractions2[\"Focus\"] = 5] = \"Focus\";\n  MouseInteractions2[MouseInteractions2[\"Blur\"] = 6] = \"Blur\";\n  MouseInteractions2[MouseInteractions2[\"TouchStart\"] = 7] = \"TouchStart\";\n  MouseInteractions2[MouseInteractions2[\"TouchMove_Departed\"] = 8] = \"TouchMove_Departed\";\n  MouseInteractions2[MouseInteractions2[\"TouchEnd\"] = 9] = \"TouchEnd\";\n  MouseInteractions2[MouseInteractions2[\"TouchCancel\"] = 10] = \"TouchCancel\";\n  return MouseInteractions2;\n})(MouseInteractions || {});\nvar PointerTypes = /* @__PURE__ */ ((PointerTypes2) => {\n  PointerTypes2[PointerTypes2[\"Mouse\"] = 0] = \"Mouse\";\n  PointerTypes2[PointerTypes2[\"Pen\"] = 1] = \"Pen\";\n  PointerTypes2[PointerTypes2[\"Touch\"] = 2] = \"Touch\";\n  return PointerTypes2;\n})(PointerTypes || {});\nvar CanvasContext = /* @__PURE__ */ ((CanvasContext2) => {\n  CanvasContext2[CanvasContext2[\"2D\"] = 0] = \"2D\";\n  CanvasContext2[CanvasContext2[\"WebGL\"] = 1] = \"WebGL\";\n  CanvasContext2[CanvasContext2[\"WebGL2\"] = 2] = \"WebGL2\";\n  return CanvasContext2;\n})(CanvasContext || {});\nvar MediaInteractions = /* @__PURE__ */ ((MediaInteractions2) => {\n  MediaInteractions2[MediaInteractions2[\"Play\"] = 0] = \"Play\";\n  MediaInteractions2[MediaInteractions2[\"Pause\"] = 1] = \"Pause\";\n  MediaInteractions2[MediaInteractions2[\"Seeked\"] = 2] = \"Seeked\";\n  MediaInteractions2[MediaInteractions2[\"VolumeChange\"] = 3] = \"VolumeChange\";\n  MediaInteractions2[MediaInteractions2[\"RateChange\"] = 4] = \"RateChange\";\n  return MediaInteractions2;\n})(MediaInteractions || {});\nvar ReplayerEvents = /* @__PURE__ */ ((ReplayerEvents2) => {\n  ReplayerEvents2[\"Start\"] = \"start\";\n  ReplayerEvents2[\"Pause\"] = \"pause\";\n  ReplayerEvents2[\"Resume\"] = \"resume\";\n  ReplayerEvents2[\"Resize\"] = \"resize\";\n  ReplayerEvents2[\"Finish\"] = \"finish\";\n  ReplayerEvents2[\"FullsnapshotRebuilded\"] = \"fullsnapshot-rebuilded\";\n  ReplayerEvents2[\"LoadStylesheetStart\"] = \"load-stylesheet-start\";\n  ReplayerEvents2[\"LoadStylesheetEnd\"] = \"load-stylesheet-end\";\n  ReplayerEvents2[\"SkipStart\"] = \"skip-start\";\n  ReplayerEvents2[\"SkipEnd\"] = \"skip-end\";\n  ReplayerEvents2[\"MouseInteraction\"] = \"mouse-interaction\";\n  ReplayerEvents2[\"EventCast\"] = \"event-cast\";\n  ReplayerEvents2[\"CustomEvent\"] = \"custom-event\";\n  ReplayerEvents2[\"Flush\"] = \"flush\";\n  ReplayerEvents2[\"StateChange\"] = \"state-change\";\n  ReplayerEvents2[\"PlayBack\"] = \"play-back\";\n  ReplayerEvents2[\"Destroy\"] = \"destroy\";\n  return ReplayerEvents2;\n})(ReplayerEvents || {});\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar __defProp2 = Object.defineProperty;\nvar __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField2 = (obj, key, value) => __defNormalProp2(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\nvar NodeType$1 = /* @__PURE__ */ ((NodeType2) => {\n  NodeType2[NodeType2[\"Document\"] = 0] = \"Document\";\n  NodeType2[NodeType2[\"DocumentType\"] = 1] = \"DocumentType\";\n  NodeType2[NodeType2[\"Element\"] = 2] = \"Element\";\n  NodeType2[NodeType2[\"Text\"] = 3] = \"Text\";\n  NodeType2[NodeType2[\"CDATA\"] = 4] = \"CDATA\";\n  NodeType2[NodeType2[\"Comment\"] = 5] = \"Comment\";\n  return NodeType2;\n})(NodeType$1 || {});\nlet Mirror$1 = class Mirror2 {\n  constructor() {\n    __publicField2(this, \"idNodeMap\", /* @__PURE__ */ new Map());\n    __publicField2(this, \"nodeMetaMap\", /* @__PURE__ */ new WeakMap());\n  }\n  getId(n2) {\n    if (!n2) return -1;\n    const id = this.getMeta(n2)?.id;\n    return id ?? -1;\n  }\n  getNode(id) {\n    return this.idNodeMap.get(id) || null;\n  }\n  getIds() {\n    return Array.from(this.idNodeMap.keys());\n  }\n  getMeta(n2) {\n    return this.nodeMetaMap.get(n2) || null;\n  }\n  // removes the node from idNodeMap\n  // doesn't remove the node from nodeMetaMap\n  removeNodeFromMap(n2) {\n    const id = this.getId(n2);\n    this.idNodeMap.delete(id);\n    if (n2.childNodes) {\n      n2.childNodes.forEach(\n        (childNode) => this.removeNodeFromMap(childNode)\n      );\n    }\n  }\n  has(id) {\n    return this.idNodeMap.has(id);\n  }\n  hasNode(node) {\n    return this.nodeMetaMap.has(node);\n  }\n  add(n2, meta) {\n    const id = meta.id;\n    this.idNodeMap.set(id, n2);\n    this.nodeMetaMap.set(n2, meta);\n  }\n  replace(id, n2) {\n    const oldNode = this.getNode(id);\n    if (oldNode) {\n      const meta = this.nodeMetaMap.get(oldNode);\n      if (meta) this.nodeMetaMap.set(n2, meta);\n    }\n    this.idNodeMap.set(id, n2);\n  }\n  reset() {\n    this.idNodeMap = /* @__PURE__ */ new Map();\n    this.nodeMetaMap = /* @__PURE__ */ new WeakMap();\n  }\n};\nfunction createMirror$1() {\n  return new Mirror$1();\n}\nfunction parseCSSText(cssText) {\n  const res = {};\n  const listDelimiter = /;(?![^(]*\\))/g;\n  const propertyDelimiter = /:(.+)/;\n  const comment = /\\/\\*.*?\\*\\//g;\n  cssText.replace(comment, \"\").split(listDelimiter).forEach(function(item) {\n    if (item) {\n      const tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[camelize(tmp[0].trim())] = tmp[1].trim());\n    }\n  });\n  return res;\n}\nfunction toCSSText(style) {\n  const properties = [];\n  for (const name in style) {\n    const value = style[name];\n    if (typeof value !== \"string\") continue;\n    const normalizedName = hyphenate(name);\n    properties.push(`${normalizedName}: ${value};`);\n  }\n  return properties.join(\" \");\n}\nconst camelizeRE = /-([a-z])/g;\nconst CUSTOM_PROPERTY_REGEX = /^--[a-zA-Z0-9-]+$/;\nconst camelize = (str) => {\n  if (CUSTOM_PROPERTY_REGEX.test(str)) return str;\n  return str.replace(camelizeRE, (_, c2) => c2 ? c2.toUpperCase() : \"\");\n};\nconst hyphenateRE = /\\B([A-Z])/g;\nconst hyphenate = (str) => {\n  return str.replace(hyphenateRE, \"-$1\").toLowerCase();\n};\nclass BaseRRNode {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any\n  constructor(..._args) {\n    __publicField(this, \"parentElement\", null);\n    __publicField(this, \"parentNode\", null);\n    __publicField(this, \"ownerDocument\");\n    __publicField(this, \"firstChild\", null);\n    __publicField(this, \"lastChild\", null);\n    __publicField(this, \"previousSibling\", null);\n    __publicField(this, \"nextSibling\", null);\n    __publicField(this, \"ELEMENT_NODE\", 1);\n    __publicField(this, \"TEXT_NODE\", 3);\n    __publicField(this, \"nodeType\");\n    __publicField(this, \"nodeName\");\n    __publicField(this, \"RRNodeType\");\n  }\n  get childNodes() {\n    const childNodes = [];\n    let childIterator = this.firstChild;\n    while (childIterator) {\n      childNodes.push(childIterator);\n      childIterator = childIterator.nextSibling;\n    }\n    return childNodes;\n  }\n  contains(node) {\n    if (!(node instanceof BaseRRNode)) return false;\n    else if (node.ownerDocument !== this.ownerDocument) return false;\n    else if (node === this) return true;\n    while (node.parentNode) {\n      if (node.parentNode === this) return true;\n      node = node.parentNode;\n    }\n    return false;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  appendChild(_newChild) {\n    throw new Error(\n      `RRDomException: Failed to execute 'appendChild' on 'RRNode': This RRNode type does not support this method.`\n    );\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  insertBefore(_newChild, _refChild) {\n    throw new Error(\n      `RRDomException: Failed to execute 'insertBefore' on 'RRNode': This RRNode type does not support this method.`\n    );\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  removeChild(_node) {\n    throw new Error(\n      `RRDomException: Failed to execute 'removeChild' on 'RRNode': This RRNode type does not support this method.`\n    );\n  }\n  toString() {\n    return \"RRNode\";\n  }\n}\nclass BaseRRDocument extends BaseRRNode {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(...args) {\n    super(args);\n    __publicField(this, \"nodeType\", 9);\n    __publicField(this, \"nodeName\", \"#document\");\n    __publicField(this, \"compatMode\", \"CSS1Compat\");\n    __publicField(this, \"RRNodeType\", NodeType$1.Document);\n    __publicField(this, \"textContent\", null);\n    this.ownerDocument = this;\n  }\n  get documentElement() {\n    return this.childNodes.find(\n      (node) => node.RRNodeType === NodeType$1.Element && node.tagName === \"HTML\"\n    ) || null;\n  }\n  get body() {\n    return this.documentElement?.childNodes.find(\n      (node) => node.RRNodeType === NodeType$1.Element && node.tagName === \"BODY\"\n    ) || null;\n  }\n  get head() {\n    return this.documentElement?.childNodes.find(\n      (node) => node.RRNodeType === NodeType$1.Element && node.tagName === \"HEAD\"\n    ) || null;\n  }\n  get implementation() {\n    return this;\n  }\n  get firstElementChild() {\n    return this.documentElement;\n  }\n  appendChild(newChild) {\n    const nodeType = newChild.RRNodeType;\n    if (nodeType === NodeType$1.Element || nodeType === NodeType$1.DocumentType) {\n      if (this.childNodes.some((s2) => s2.RRNodeType === nodeType)) {\n        throw new Error(\n          `RRDomException: Failed to execute 'appendChild' on 'RRNode': Only one ${nodeType === NodeType$1.Element ? \"RRElement\" : \"RRDoctype\"} on RRDocument allowed.`\n        );\n      }\n    }\n    const child = appendChild(this, newChild);\n    child.parentElement = null;\n    return child;\n  }\n  insertBefore(newChild, refChild) {\n    const nodeType = newChild.RRNodeType;\n    if (nodeType === NodeType$1.Element || nodeType === NodeType$1.DocumentType) {\n      if (this.childNodes.some((s2) => s2.RRNodeType === nodeType)) {\n        throw new Error(\n          `RRDomException: Failed to execute 'insertBefore' on 'RRNode': Only one ${nodeType === NodeType$1.Element ? \"RRElement\" : \"RRDoctype\"} on RRDocument allowed.`\n        );\n      }\n    }\n    const child = insertBefore(this, newChild, refChild);\n    child.parentElement = null;\n    return child;\n  }\n  removeChild(node) {\n    return removeChild(this, node);\n  }\n  open() {\n    this.firstChild = null;\n    this.lastChild = null;\n  }\n  close() {\n  }\n  /**\n   * Adhoc implementation for setting xhtml namespace in rebuilt.ts (rrweb-snapshot).\n   * There are two lines used this function:\n   * 1. doc.write('\\<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"\"\\>')\n   * 2. doc.write('\\<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"\"\\>')\n   */\n  write(content) {\n    let publicId;\n    if (content === '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"\">')\n      publicId = \"-//W3C//DTD XHTML 1.0 Transitional//EN\";\n    else if (content === '<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"\">')\n      publicId = \"-//W3C//DTD HTML 4.0 Transitional//EN\";\n    if (publicId) {\n      const doctype = this.createDocumentType(\"html\", publicId, \"\");\n      this.open();\n      this.appendChild(doctype);\n    }\n  }\n  createDocument(_namespace, _qualifiedName, _doctype) {\n    return new BaseRRDocument();\n  }\n  createDocumentType(qualifiedName, publicId, systemId) {\n    const doctype = new BaseRRDocumentType(qualifiedName, publicId, systemId);\n    doctype.ownerDocument = this;\n    return doctype;\n  }\n  createElement(tagName) {\n    const element = new BaseRRElement(tagName);\n    element.ownerDocument = this;\n    return element;\n  }\n  createElementNS(_namespaceURI, qualifiedName) {\n    return this.createElement(qualifiedName);\n  }\n  createTextNode(data) {\n    const text = new BaseRRText(data);\n    text.ownerDocument = this;\n    return text;\n  }\n  createComment(data) {\n    const comment = new BaseRRComment(data);\n    comment.ownerDocument = this;\n    return comment;\n  }\n  createCDATASection(data) {\n    const CDATASection = new BaseRRCDATASection(data);\n    CDATASection.ownerDocument = this;\n    return CDATASection;\n  }\n  toString() {\n    return \"RRDocument\";\n  }\n}\nclass BaseRRDocumentType extends BaseRRNode {\n  constructor(qualifiedName, publicId, systemId) {\n    super();\n    __publicField(this, \"nodeType\", 10);\n    __publicField(this, \"RRNodeType\", NodeType$1.DocumentType);\n    __publicField(this, \"name\");\n    __publicField(this, \"publicId\");\n    __publicField(this, \"systemId\");\n    __publicField(this, \"textContent\", null);\n    this.name = qualifiedName;\n    this.publicId = publicId;\n    this.systemId = systemId;\n    this.nodeName = qualifiedName;\n  }\n  toString() {\n    return \"RRDocumentType\";\n  }\n}\nclass BaseRRElement extends BaseRRNode {\n  constructor(tagName) {\n    super();\n    __publicField(this, \"nodeType\", 1);\n    __publicField(this, \"RRNodeType\", NodeType$1.Element);\n    __publicField(this, \"tagName\");\n    __publicField(this, \"attributes\", {});\n    __publicField(this, \"shadowRoot\", null);\n    __publicField(this, \"scrollLeft\");\n    __publicField(this, \"scrollTop\");\n    this.tagName = tagName.toUpperCase();\n    this.nodeName = tagName.toUpperCase();\n  }\n  get textContent() {\n    let result = \"\";\n    this.childNodes.forEach((node) => result += node.textContent);\n    return result;\n  }\n  set textContent(textContent) {\n    this.firstChild = null;\n    this.lastChild = null;\n    this.appendChild(this.ownerDocument.createTextNode(textContent));\n  }\n  get classList() {\n    return new ClassList(\n      this.attributes.class,\n      (newClassName) => {\n        this.attributes.class = newClassName;\n      }\n    );\n  }\n  get id() {\n    return this.attributes.id || \"\";\n  }\n  get className() {\n    return this.attributes.class || \"\";\n  }\n  get style() {\n    const style = this.attributes.style ? parseCSSText(this.attributes.style) : {};\n    const hyphenateRE2 = /\\B([A-Z])/g;\n    style.setProperty = (name, value, priority) => {\n      if (hyphenateRE2.test(name)) return;\n      const normalizedName = camelize(name);\n      if (!value) delete style[normalizedName];\n      else style[normalizedName] = value;\n      if (priority === \"important\") style[normalizedName] += \" !important\";\n      this.attributes.style = toCSSText(style);\n    };\n    style.removeProperty = (name) => {\n      if (hyphenateRE2.test(name)) return \"\";\n      const normalizedName = camelize(name);\n      const value = style[normalizedName] || \"\";\n      delete style[normalizedName];\n      this.attributes.style = toCSSText(style);\n      return value;\n    };\n    return style;\n  }\n  getAttribute(name) {\n    return this.attributes[name] || null;\n  }\n  setAttribute(name, attribute) {\n    this.attributes[name] = attribute;\n  }\n  setAttributeNS(_namespace, qualifiedName, value) {\n    this.setAttribute(qualifiedName, value);\n  }\n  removeAttribute(name) {\n    delete this.attributes[name];\n  }\n  appendChild(newChild) {\n    return appendChild(this, newChild);\n  }\n  insertBefore(newChild, refChild) {\n    return insertBefore(this, newChild, refChild);\n  }\n  removeChild(node) {\n    return removeChild(this, node);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  attachShadow(_init) {\n    const shadowRoot = this.ownerDocument.createElement(\"SHADOWROOT\");\n    this.shadowRoot = shadowRoot;\n    return shadowRoot;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  dispatchEvent(_event) {\n    return true;\n  }\n  toString() {\n    let attributeString = \"\";\n    for (const attribute in this.attributes) {\n      attributeString += `${attribute}=\"${this.attributes[attribute]}\" `;\n    }\n    return `${this.tagName} ${attributeString}`;\n  }\n}\nclass BaseRRMediaElement extends BaseRRElement {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"currentTime\");\n    __publicField(this, \"volume\");\n    __publicField(this, \"paused\");\n    __publicField(this, \"muted\");\n    __publicField(this, \"playbackRate\");\n    __publicField(this, \"loop\");\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  attachShadow(_init) {\n    throw new Error(\n      `RRDomException: Failed to execute 'attachShadow' on 'RRElement': This RRElement does not support attachShadow`\n    );\n  }\n  play() {\n    this.paused = false;\n  }\n  pause() {\n    this.paused = true;\n  }\n}\nclass BaseRRText extends BaseRRNode {\n  constructor(data) {\n    super();\n    __publicField(this, \"nodeType\", 3);\n    __publicField(this, \"nodeName\", \"#text\");\n    __publicField(this, \"RRNodeType\", NodeType$1.Text);\n    __publicField(this, \"data\");\n    this.data = data;\n  }\n  get textContent() {\n    return this.data;\n  }\n  set textContent(textContent) {\n    this.data = textContent;\n  }\n  toString() {\n    return `RRText text=${JSON.stringify(this.data)}`;\n  }\n}\nclass BaseRRComment extends BaseRRNode {\n  constructor(data) {\n    super();\n    __publicField(this, \"nodeType\", 8);\n    __publicField(this, \"nodeName\", \"#comment\");\n    __publicField(this, \"RRNodeType\", NodeType$1.Comment);\n    __publicField(this, \"data\");\n    this.data = data;\n  }\n  get textContent() {\n    return this.data;\n  }\n  set textContent(textContent) {\n    this.data = textContent;\n  }\n  toString() {\n    return `RRComment text=${JSON.stringify(this.data)}`;\n  }\n}\nclass BaseRRCDATASection extends BaseRRNode {\n  constructor(data) {\n    super();\n    __publicField(this, \"nodeName\", \"#cdata-section\");\n    __publicField(this, \"nodeType\", 4);\n    __publicField(this, \"RRNodeType\", NodeType$1.CDATA);\n    __publicField(this, \"data\");\n    this.data = data;\n  }\n  get textContent() {\n    return this.data;\n  }\n  set textContent(textContent) {\n    this.data = textContent;\n  }\n  toString() {\n    return `RRCDATASection data=${JSON.stringify(this.data)}`;\n  }\n}\nclass ClassList {\n  constructor(classText, onChange) {\n    __publicField(this, \"onChange\");\n    __publicField(this, \"classes\", []);\n    __publicField(this, \"add\", (...classNames) => {\n      for (const item of classNames) {\n        const className = String(item);\n        if (this.classes.indexOf(className) >= 0) continue;\n        this.classes.push(className);\n      }\n      this.onChange && this.onChange(this.classes.join(\" \"));\n    });\n    __publicField(this, \"remove\", (...classNames) => {\n      this.classes = this.classes.filter(\n        (item) => classNames.indexOf(item) === -1\n      );\n      this.onChange && this.onChange(this.classes.join(\" \"));\n    });\n    if (classText) {\n      const classes = classText.trim().split(/\\s+/);\n      this.classes.push(...classes);\n    }\n    this.onChange = onChange;\n  }\n}\nfunction appendChild(parent, newChild) {\n  if (newChild.parentNode) newChild.parentNode.removeChild(newChild);\n  if (parent.lastChild) {\n    parent.lastChild.nextSibling = newChild;\n    newChild.previousSibling = parent.lastChild;\n  } else {\n    parent.firstChild = newChild;\n    newChild.previousSibling = null;\n  }\n  parent.lastChild = newChild;\n  newChild.nextSibling = null;\n  newChild.parentNode = parent;\n  newChild.parentElement = parent;\n  newChild.ownerDocument = parent.ownerDocument;\n  return newChild;\n}\nfunction insertBefore(parent, newChild, refChild) {\n  if (!refChild) return appendChild(parent, newChild);\n  if (refChild.parentNode !== parent)\n    throw new Error(\n      \"Failed to execute 'insertBefore' on 'RRNode': The RRNode before which the new node is to be inserted is not a child of this RRNode.\"\n    );\n  if (newChild === refChild) return newChild;\n  if (newChild.parentNode) newChild.parentNode.removeChild(newChild);\n  newChild.previousSibling = refChild.previousSibling;\n  refChild.previousSibling = newChild;\n  newChild.nextSibling = refChild;\n  if (newChild.previousSibling) newChild.previousSibling.nextSibling = newChild;\n  else parent.firstChild = newChild;\n  newChild.parentElement = parent;\n  newChild.parentNode = parent;\n  newChild.ownerDocument = parent.ownerDocument;\n  return newChild;\n}\nfunction removeChild(parent, child) {\n  if (child.parentNode !== parent)\n    throw new Error(\n      \"Failed to execute 'removeChild' on 'RRNode': The RRNode to be removed is not a child of this RRNode.\"\n    );\n  if (child.previousSibling)\n    child.previousSibling.nextSibling = child.nextSibling;\n  else parent.firstChild = child.nextSibling;\n  if (child.nextSibling)\n    child.nextSibling.previousSibling = child.previousSibling;\n  else parent.lastChild = child.previousSibling;\n  child.previousSibling = null;\n  child.nextSibling = null;\n  child.parentElement = null;\n  child.parentNode = null;\n  return child;\n}\nvar NodeType = /* @__PURE__ */ ((NodeType2) => {\n  NodeType2[NodeType2[\"PLACEHOLDER\"] = 0] = \"PLACEHOLDER\";\n  NodeType2[NodeType2[\"ELEMENT_NODE\"] = 1] = \"ELEMENT_NODE\";\n  NodeType2[NodeType2[\"ATTRIBUTE_NODE\"] = 2] = \"ATTRIBUTE_NODE\";\n  NodeType2[NodeType2[\"TEXT_NODE\"] = 3] = \"TEXT_NODE\";\n  NodeType2[NodeType2[\"CDATA_SECTION_NODE\"] = 4] = \"CDATA_SECTION_NODE\";\n  NodeType2[NodeType2[\"ENTITY_REFERENCE_NODE\"] = 5] = \"ENTITY_REFERENCE_NODE\";\n  NodeType2[NodeType2[\"ENTITY_NODE\"] = 6] = \"ENTITY_NODE\";\n  NodeType2[NodeType2[\"PROCESSING_INSTRUCTION_NODE\"] = 7] = \"PROCESSING_INSTRUCTION_NODE\";\n  NodeType2[NodeType2[\"COMMENT_NODE\"] = 8] = \"COMMENT_NODE\";\n  NodeType2[NodeType2[\"DOCUMENT_NODE\"] = 9] = \"DOCUMENT_NODE\";\n  NodeType2[NodeType2[\"DOCUMENT_TYPE_NODE\"] = 10] = \"DOCUMENT_TYPE_NODE\";\n  NodeType2[NodeType2[\"DOCUMENT_FRAGMENT_NODE\"] = 11] = \"DOCUMENT_FRAGMENT_NODE\";\n  return NodeType2;\n})(NodeType || {});\nfunction getIFrameContentDocument(iframe) {\n  try {\n    return iframe.contentDocument;\n  } catch (e2) {\n  }\n}\nfunction getIFrameContentWindow(iframe) {\n  try {\n    return iframe.contentWindow;\n  } catch (e2) {\n  }\n}\nconst NAMESPACES = {\n  svg: \"http://www.w3.org/2000/svg\",\n  \"xlink:href\": \"http://www.w3.org/1999/xlink\",\n  xmlns: \"http://www.w3.org/2000/xmlns/\"\n};\nconst SVGTagMap = {\n  altglyph: \"altGlyph\",\n  altglyphdef: \"altGlyphDef\",\n  altglyphitem: \"altGlyphItem\",\n  animatecolor: \"animateColor\",\n  animatemotion: \"animateMotion\",\n  animatetransform: \"animateTransform\",\n  clippath: \"clipPath\",\n  feblend: \"feBlend\",\n  fecolormatrix: \"feColorMatrix\",\n  fecomponenttransfer: \"feComponentTransfer\",\n  fecomposite: \"feComposite\",\n  feconvolvematrix: \"feConvolveMatrix\",\n  fediffuselighting: \"feDiffuseLighting\",\n  fedisplacementmap: \"feDisplacementMap\",\n  fedistantlight: \"feDistantLight\",\n  fedropshadow: \"feDropShadow\",\n  feflood: \"feFlood\",\n  fefunca: \"feFuncA\",\n  fefuncb: \"feFuncB\",\n  fefuncg: \"feFuncG\",\n  fefuncr: \"feFuncR\",\n  fegaussianblur: \"feGaussianBlur\",\n  feimage: \"feImage\",\n  femerge: \"feMerge\",\n  femergenode: \"feMergeNode\",\n  femorphology: \"feMorphology\",\n  feoffset: \"feOffset\",\n  fepointlight: \"fePointLight\",\n  fespecularlighting: \"feSpecularLighting\",\n  fespotlight: \"feSpotLight\",\n  fetile: \"feTile\",\n  feturbulence: \"feTurbulence\",\n  foreignobject: \"foreignObject\",\n  glyphref: \"glyphRef\",\n  lineargradient: \"linearGradient\",\n  radialgradient: \"radialGradient\"\n};\nlet createdNodeSet = null;\nfunction diff(oldTree, newTree, replayer, rrnodeMirror = newTree.mirror || newTree.ownerDocument.mirror) {\n  oldTree = diffBeforeUpdatingChildren(\n    oldTree,\n    newTree,\n    replayer,\n    rrnodeMirror\n  );\n  diffChildren(oldTree, newTree, replayer, rrnodeMirror);\n  diffAfterUpdatingChildren(oldTree, newTree, replayer);\n}\nfunction diffBeforeUpdatingChildren(oldTree, newTree, replayer, rrnodeMirror) {\n  if (replayer.afterAppend && !createdNodeSet) {\n    createdNodeSet = /* @__PURE__ */ new WeakSet();\n    setTimeout(() => {\n      createdNodeSet = null;\n    }, 0);\n  }\n  if (!sameNodeType(oldTree, newTree)) {\n    const calibratedOldTree = createOrGetNode(\n      newTree,\n      replayer.mirror,\n      rrnodeMirror\n    );\n    oldTree.parentNode?.replaceChild(calibratedOldTree, oldTree);\n    oldTree = calibratedOldTree;\n  }\n  switch (newTree.RRNodeType) {\n    case NodeType$1.Document: {\n      if (!nodeMatching(oldTree, newTree, replayer.mirror, rrnodeMirror)) {\n        const newMeta = rrnodeMirror.getMeta(newTree);\n        if (newMeta) {\n          replayer.mirror.removeNodeFromMap(oldTree);\n          oldTree.close();\n          oldTree.open();\n          replayer.mirror.add(oldTree, newMeta);\n          createdNodeSet?.add(oldTree);\n        }\n      }\n      break;\n    }\n    case NodeType$1.Element: {\n      const oldElement = oldTree;\n      const newRRElement = newTree;\n      switch (newRRElement.tagName) {\n        case \"IFRAME\": {\n          const oldContentDocument = getIFrameContentDocument(\n            oldTree\n          );\n          if (!oldContentDocument) break;\n          diff(\n            oldContentDocument,\n            newTree.contentDocument,\n            replayer,\n            rrnodeMirror\n          );\n          break;\n        }\n      }\n      if (newRRElement.shadowRoot) {\n        if (!oldElement.shadowRoot) oldElement.attachShadow({ mode: \"open\" });\n        diffChildren(\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          oldElement.shadowRoot,\n          newRRElement.shadowRoot,\n          replayer,\n          rrnodeMirror\n        );\n      }\n      diffProps(oldElement, newRRElement, rrnodeMirror);\n      break;\n    }\n  }\n  return oldTree;\n}\nfunction diffAfterUpdatingChildren(oldTree, newTree, replayer) {\n  switch (newTree.RRNodeType) {\n    case NodeType$1.Document: {\n      const scrollData = newTree.scrollData;\n      scrollData && replayer.applyScroll(scrollData, true);\n      break;\n    }\n    case NodeType$1.Element: {\n      const oldElement = oldTree;\n      const newRRElement = newTree;\n      newRRElement.scrollData && replayer.applyScroll(newRRElement.scrollData, true);\n      newRRElement.inputData && replayer.applyInput(newRRElement.inputData);\n      switch (newRRElement.tagName) {\n        case \"AUDIO\":\n        case \"VIDEO\": {\n          const oldMediaElement = oldTree;\n          const newMediaRRElement = newRRElement;\n          if (newMediaRRElement.paused !== void 0) {\n            const maybePromise = newMediaRRElement.paused ? oldMediaElement.pause() : oldMediaElement.play();\n            if (typeof maybePromise?.catch === \"function\") {\n              maybePromise.catch((e2) => {\n                console.warn(e2);\n              });\n            }\n          }\n          if (newMediaRRElement.muted !== void 0)\n            oldMediaElement.muted = newMediaRRElement.muted;\n          if (newMediaRRElement.volume !== void 0)\n            oldMediaElement.volume = newMediaRRElement.volume;\n          if (newMediaRRElement.currentTime !== void 0)\n            oldMediaElement.currentTime = newMediaRRElement.currentTime;\n          if (newMediaRRElement.playbackRate !== void 0)\n            oldMediaElement.playbackRate = newMediaRRElement.playbackRate;\n          break;\n        }\n        case \"CANVAS\": {\n          const rrCanvasElement = newTree;\n          if (rrCanvasElement.rr_dataURL !== null) {\n            const image = document.createElement(\"img\");\n            image.onload = () => {\n              const ctx = oldElement.getContext(\"2d\");\n              if (ctx) {\n                ctx.drawImage(image, 0, 0, image.width, image.height);\n              }\n            };\n            image.src = rrCanvasElement.rr_dataURL;\n          }\n          rrCanvasElement.canvasMutations.forEach(\n            (canvasMutation2) => replayer.applyCanvas(\n              canvasMutation2.event,\n              canvasMutation2.mutation,\n              oldTree\n            )\n          );\n          break;\n        }\n        case \"STYLE\": {\n          const styleSheet = oldElement.sheet;\n          styleSheet && newTree.rules.forEach(\n            (data) => replayer.applyStyleSheetMutation(data, styleSheet)\n          );\n          break;\n        }\n      }\n      break;\n    }\n    case NodeType$1.Text:\n    case NodeType$1.Comment:\n    case NodeType$1.CDATA: {\n      if (oldTree.textContent !== newTree.data)\n        oldTree.textContent = newTree.data;\n      break;\n    }\n  }\n  if (createdNodeSet?.has(oldTree)) {\n    createdNodeSet.delete(oldTree);\n    replayer.afterAppend?.(oldTree, replayer.mirror.getId(oldTree));\n  }\n}\nfunction diffProps(oldTree, newTree, rrnodeMirror) {\n  const oldAttributes = oldTree.attributes;\n  const newAttributes = newTree.attributes;\n  for (const name in newAttributes) {\n    const newValue = newAttributes[name];\n    const sn = rrnodeMirror.getMeta(newTree);\n    if (sn?.isSVG && NAMESPACES[name])\n      oldTree.setAttributeNS(NAMESPACES[name], name, newValue);\n    else if (newTree.tagName === \"CANVAS\" && name === \"rr_dataURL\") {\n      const image = document.createElement(\"img\");\n      image.src = newValue;\n      image.onload = () => {\n        const ctx = oldTree.getContext(\"2d\");\n        if (ctx) {\n          ctx.drawImage(image, 0, 0, image.width, image.height);\n        }\n      };\n    } else if (newTree.tagName === \"IFRAME\" && name === \"srcdoc\") continue;\n    else {\n      try {\n        oldTree.setAttribute(name, newValue);\n      } catch (err) {\n        console.warn(err);\n      }\n    }\n  }\n  for (const { name } of Array.from(oldAttributes))\n    if (!(name in newAttributes)) oldTree.removeAttribute(name);\n  newTree.scrollLeft && (oldTree.scrollLeft = newTree.scrollLeft);\n  newTree.scrollTop && (oldTree.scrollTop = newTree.scrollTop);\n}\nfunction diffChildren(oldTree, newTree, replayer, rrnodeMirror) {\n  const oldChildren = Array.from(oldTree.childNodes);\n  const newChildren = newTree.childNodes;\n  if (oldChildren.length === 0 && newChildren.length === 0) return;\n  let oldStartIndex = 0, oldEndIndex = oldChildren.length - 1, newStartIndex = 0, newEndIndex = newChildren.length - 1;\n  let oldStartNode = oldChildren[oldStartIndex], oldEndNode = oldChildren[oldEndIndex], newStartNode = newChildren[newStartIndex], newEndNode = newChildren[newEndIndex];\n  let oldIdToIndex = void 0, indexInOld = void 0;\n  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {\n    if (oldStartNode === void 0) {\n      oldStartNode = oldChildren[++oldStartIndex];\n    } else if (oldEndNode === void 0) {\n      oldEndNode = oldChildren[--oldEndIndex];\n    } else if (\n      // same first node?\n      nodeMatching(oldStartNode, newStartNode, replayer.mirror, rrnodeMirror)\n    ) {\n      oldStartNode = oldChildren[++oldStartIndex];\n      newStartNode = newChildren[++newStartIndex];\n    } else if (\n      // same last node?\n      nodeMatching(oldEndNode, newEndNode, replayer.mirror, rrnodeMirror)\n    ) {\n      oldEndNode = oldChildren[--oldEndIndex];\n      newEndNode = newChildren[--newEndIndex];\n    } else if (\n      // is the first old node the same as the last new node?\n      nodeMatching(oldStartNode, newEndNode, replayer.mirror, rrnodeMirror)\n    ) {\n      try {\n        handleInsertBefore(oldTree, oldStartNode, oldEndNode.nextSibling);\n      } catch (e2) {\n        console.warn(e2);\n      }\n      oldStartNode = oldChildren[++oldStartIndex];\n      newEndNode = newChildren[--newEndIndex];\n    } else if (\n      // is the last old node the same as the first new node?\n      nodeMatching(oldEndNode, newStartNode, replayer.mirror, rrnodeMirror)\n    ) {\n      try {\n        handleInsertBefore(oldTree, oldEndNode, oldStartNode);\n      } catch (e2) {\n        console.warn(e2);\n      }\n      oldEndNode = oldChildren[--oldEndIndex];\n      newStartNode = newChildren[++newStartIndex];\n    } else {\n      if (!oldIdToIndex) {\n        oldIdToIndex = {};\n        for (let i2 = oldStartIndex; i2 <= oldEndIndex; i2++) {\n          const oldChild2 = oldChildren[i2];\n          if (oldChild2 && replayer.mirror.hasNode(oldChild2))\n            oldIdToIndex[replayer.mirror.getId(oldChild2)] = i2;\n        }\n      }\n      indexInOld = oldIdToIndex[rrnodeMirror.getId(newStartNode)];\n      const nodeToMove = oldChildren[indexInOld];\n      if (indexInOld !== void 0 && nodeToMove && nodeMatching(nodeToMove, newStartNode, replayer.mirror, rrnodeMirror)) {\n        try {\n          handleInsertBefore(oldTree, nodeToMove, oldStartNode);\n        } catch (e2) {\n          console.warn(e2);\n        }\n        oldChildren[indexInOld] = void 0;\n      } else {\n        const newNode = createOrGetNode(\n          newStartNode,\n          replayer.mirror,\n          rrnodeMirror\n        );\n        if (oldTree.nodeName === \"#document\" && oldStartNode && /**\n        * Special case 1: one document isn't allowed to have two doctype nodes at the same time, so we need to remove the old one first before inserting the new one.\n        * How this case happens: A parent document in the old tree already has a doctype node with an id e.g. #1. A new full snapshot rebuilds the replayer with a new doctype node with another id #2. According to the algorithm, the new doctype node will be inserted before the old one, which is not allowed by the Document standard.\n        */\n        (newNode.nodeType === newNode.DOCUMENT_TYPE_NODE && oldStartNode.nodeType === oldStartNode.DOCUMENT_TYPE_NODE || /**\n        * Special case 2: one document isn't allowed to have two HTMLElements at the same time, so we need to remove the old one first before inserting the new one.\n        * How this case happens: A mounted iframe element has an automatically created HTML element. We should delete it before inserting a serialized one. Otherwise, an error 'Only one element on document allowed' will be thrown.\n        */\n        newNode.nodeType === newNode.ELEMENT_NODE && oldStartNode.nodeType === oldStartNode.ELEMENT_NODE)) {\n          oldTree.removeChild(oldStartNode);\n          replayer.mirror.removeNodeFromMap(oldStartNode);\n          oldStartNode = oldChildren[++oldStartIndex];\n        }\n        try {\n          handleInsertBefore(oldTree, newNode, oldStartNode || null);\n        } catch (e2) {\n          console.warn(e2);\n        }\n      }\n      newStartNode = newChildren[++newStartIndex];\n    }\n  }\n  if (oldStartIndex > oldEndIndex) {\n    const referenceRRNode = newChildren[newEndIndex + 1];\n    let referenceNode = null;\n    if (referenceRRNode)\n      referenceNode = replayer.mirror.getNode(\n        rrnodeMirror.getId(referenceRRNode)\n      );\n    for (; newStartIndex <= newEndIndex; ++newStartIndex) {\n      const newNode = createOrGetNode(\n        newChildren[newStartIndex],\n        replayer.mirror,\n        rrnodeMirror\n      );\n      try {\n        handleInsertBefore(oldTree, newNode, referenceNode);\n      } catch (e2) {\n        console.warn(e2);\n      }\n    }\n  } else if (newStartIndex > newEndIndex) {\n    for (; oldStartIndex <= oldEndIndex; oldStartIndex++) {\n      const node = oldChildren[oldStartIndex];\n      if (!node || node.parentNode !== oldTree) continue;\n      try {\n        oldTree.removeChild(node);\n        replayer.mirror.removeNodeFromMap(node);\n      } catch (e2) {\n        console.warn(e2);\n      }\n    }\n  }\n  let oldChild = oldTree.firstChild;\n  let newChild = newTree.firstChild;\n  while (oldChild !== null && newChild !== null) {\n    diff(oldChild, newChild, replayer, rrnodeMirror);\n    oldChild = oldChild.nextSibling;\n    newChild = newChild.nextSibling;\n  }\n}\nfunction createOrGetNode(rrNode, domMirror, rrnodeMirror) {\n  const nodeId = rrnodeMirror.getId(rrNode);\n  const sn = rrnodeMirror.getMeta(rrNode);\n  let node = null;\n  if (nodeId > -1) node = domMirror.getNode(nodeId);\n  if (node !== null && sameNodeType(node, rrNode)) return node;\n  switch (rrNode.RRNodeType) {\n    case NodeType$1.Document:\n      node = new Document();\n      break;\n    case NodeType$1.DocumentType:\n      node = document.implementation.createDocumentType(\n        rrNode.name,\n        rrNode.publicId,\n        rrNode.systemId\n      );\n      break;\n    case NodeType$1.Element: {\n      let tagName = rrNode.tagName.toLowerCase();\n      tagName = SVGTagMap[tagName] || tagName;\n      if (sn && \"isSVG\" in sn && sn?.isSVG) {\n        node = document.createElementNS(NAMESPACES[\"svg\"], tagName);\n      } else node = document.createElement(rrNode.tagName);\n      break;\n    }\n    case NodeType$1.Text:\n      node = document.createTextNode(rrNode.data);\n      break;\n    case NodeType$1.Comment:\n      node = document.createComment(rrNode.data);\n      break;\n    case NodeType$1.CDATA:\n      node = document.createCDATASection(rrNode.data);\n      break;\n  }\n  if (sn) domMirror.add(node, { ...sn });\n  try {\n    createdNodeSet?.add(node);\n  } catch (e2) {\n  }\n  return node;\n}\nfunction sameNodeType(node1, node2) {\n  if (node1.nodeType !== node2.nodeType) return false;\n  return node1.nodeType !== node1.ELEMENT_NODE || node1.tagName.toUpperCase() === node2.tagName;\n}\nfunction nodeMatching(node1, node2, domMirror, rrdomMirror) {\n  const node1Id = domMirror.getId(node1);\n  const node2Id = rrdomMirror.getId(node2);\n  if (node1Id === -1 || node1Id !== node2Id) return false;\n  return sameNodeType(node1, node2);\n}\nfunction getInsertedStylesFromElement(styleElement) {\n  const elementCssRules = styleElement.sheet?.cssRules;\n  if (!elementCssRules || !elementCssRules.length) return;\n  const tempStyleSheet = new CSSStyleSheet();\n  tempStyleSheet.replaceSync(styleElement.innerText);\n  const innerTextStylesMap = {};\n  for (let i2 = 0; i2 < tempStyleSheet.cssRules.length; i2++) {\n    innerTextStylesMap[tempStyleSheet.cssRules[i2].cssText] = tempStyleSheet.cssRules[i2];\n  }\n  const insertedStylesStyleSheet = [];\n  for (let i2 = 0; i2 < elementCssRules?.length; i2++) {\n    const cssRuleText = elementCssRules[i2].cssText;\n    if (!innerTextStylesMap[cssRuleText]) {\n      insertedStylesStyleSheet.push({\n        index: i2,\n        cssRuleText\n      });\n    }\n  }\n  return insertedStylesStyleSheet;\n}\nfunction handleInsertBefore(oldTree, nodeToMove, insertBeforeNode) {\n  let insertedStyles;\n  if (nodeToMove.nodeName === \"STYLE\") {\n    insertedStyles = getInsertedStylesFromElement(\n      nodeToMove\n    );\n  }\n  oldTree.insertBefore(nodeToMove, insertBeforeNode);\n  if (insertedStyles && insertedStyles.length) {\n    insertedStyles.forEach(({ cssRuleText, index }) => {\n      nodeToMove.sheet?.insertRule(cssRuleText, index);\n    });\n  }\n}\nclass RRDocument extends BaseRRDocument {\n  constructor(mirror2) {\n    super();\n    __publicField(this, \"UNSERIALIZED_STARTING_ID\", -2);\n    __publicField(this, \"_unserializedId\", this.UNSERIALIZED_STARTING_ID);\n    __publicField(this, \"mirror\", createMirror());\n    __publicField(this, \"scrollData\", null);\n    if (mirror2) {\n      this.mirror = mirror2;\n    }\n  }\n  /**\n   * Every time the id is used, it will minus 1 automatically to avoid collisions.\n   */\n  get unserializedId() {\n    return this._unserializedId--;\n  }\n  createDocument(_namespace, _qualifiedName, _doctype) {\n    return new RRDocument();\n  }\n  createDocumentType(qualifiedName, publicId, systemId) {\n    const documentTypeNode = new RRDocumentType(\n      qualifiedName,\n      publicId,\n      systemId\n    );\n    documentTypeNode.ownerDocument = this;\n    return documentTypeNode;\n  }\n  createElement(tagName) {\n    const upperTagName = tagName.toUpperCase();\n    let element;\n    switch (upperTagName) {\n      case \"AUDIO\":\n      case \"VIDEO\":\n        element = new RRMediaElement(upperTagName);\n        break;\n      case \"IFRAME\":\n        element = new RRIFrameElement(upperTagName, this.mirror);\n        break;\n      case \"CANVAS\":\n        element = new RRCanvasElement(upperTagName);\n        break;\n      case \"STYLE\":\n        element = new RRStyleElement(upperTagName);\n        break;\n      default:\n        element = new RRElement(upperTagName);\n        break;\n    }\n    element.ownerDocument = this;\n    return element;\n  }\n  createComment(data) {\n    const commentNode = new RRComment(data);\n    commentNode.ownerDocument = this;\n    return commentNode;\n  }\n  createCDATASection(data) {\n    const sectionNode = new RRCDATASection(data);\n    sectionNode.ownerDocument = this;\n    return sectionNode;\n  }\n  createTextNode(data) {\n    const textNode = new RRText(data);\n    textNode.ownerDocument = this;\n    return textNode;\n  }\n  destroyTree() {\n    this.firstChild = null;\n    this.lastChild = null;\n    this.mirror.reset();\n  }\n  open() {\n    super.open();\n    this._unserializedId = this.UNSERIALIZED_STARTING_ID;\n  }\n}\nconst RRDocumentType = BaseRRDocumentType;\nclass RRElement extends BaseRRElement {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"inputData\", null);\n    __publicField(this, \"scrollData\", null);\n  }\n}\nclass RRMediaElement extends BaseRRMediaElement {\n}\nclass RRCanvasElement extends RRElement {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"rr_dataURL\", null);\n    __publicField(this, \"canvasMutations\", []);\n  }\n  /**\n   * This is a dummy implementation to distinguish RRCanvasElement from real HTMLCanvasElement.\n   */\n  getContext() {\n    return null;\n  }\n}\nclass RRStyleElement extends RRElement {\n  constructor() {\n    super(...arguments);\n    __publicField(this, \"rules\", []);\n  }\n}\nclass RRIFrameElement extends RRElement {\n  constructor(upperTagName, mirror2) {\n    super(upperTagName);\n    __publicField(this, \"contentDocument\", new RRDocument());\n    this.contentDocument.mirror = mirror2;\n  }\n}\nconst RRText = BaseRRText;\nconst RRComment = BaseRRComment;\nconst RRCDATASection = BaseRRCDATASection;\nfunction getValidTagName(element) {\n  if (element instanceof HTMLFormElement) {\n    return \"FORM\";\n  }\n  return element.tagName.toUpperCase();\n}\nfunction buildFromNode(node, rrdom, domMirror, parentRRNode) {\n  let rrNode;\n  switch (node.nodeType) {\n    case NodeType.DOCUMENT_NODE:\n      if (parentRRNode && parentRRNode.nodeName === \"IFRAME\")\n        rrNode = parentRRNode.contentDocument;\n      else {\n        rrNode = rrdom;\n        rrNode.compatMode = node.compatMode;\n      }\n      break;\n    case NodeType.DOCUMENT_TYPE_NODE: {\n      const documentType = node;\n      rrNode = rrdom.createDocumentType(\n        documentType.name,\n        documentType.publicId,\n        documentType.systemId\n      );\n      break;\n    }\n    case NodeType.ELEMENT_NODE: {\n      const elementNode = node;\n      const tagName = getValidTagName(elementNode);\n      rrNode = rrdom.createElement(tagName);\n      const rrElement = rrNode;\n      for (const { name, value } of Array.from(elementNode.attributes)) {\n        rrElement.attributes[name] = value;\n      }\n      elementNode.scrollLeft && (rrElement.scrollLeft = elementNode.scrollLeft);\n      elementNode.scrollTop && (rrElement.scrollTop = elementNode.scrollTop);\n      break;\n    }\n    case NodeType.TEXT_NODE:\n      rrNode = rrdom.createTextNode(node.textContent || \"\");\n      break;\n    case NodeType.CDATA_SECTION_NODE:\n      rrNode = rrdom.createCDATASection(node.data);\n      break;\n    case NodeType.COMMENT_NODE:\n      rrNode = rrdom.createComment(node.textContent || \"\");\n      break;\n    case NodeType.DOCUMENT_FRAGMENT_NODE:\n      rrNode = parentRRNode.attachShadow({ mode: \"open\" });\n      break;\n    default:\n      return null;\n  }\n  let sn = domMirror.getMeta(node);\n  if (rrdom instanceof RRDocument) {\n    if (!sn) {\n      sn = getDefaultSN(rrNode, rrdom.unserializedId);\n      domMirror.add(node, sn);\n    }\n    rrdom.mirror.add(rrNode, { ...sn });\n  }\n  return rrNode;\n}\nfunction buildFromDom(dom, domMirror = createMirror$1(), rrdom = new RRDocument()) {\n  function walk2(node, parentRRNode) {\n    const rrNode = buildFromNode(node, rrdom, domMirror, parentRRNode);\n    if (rrNode === null) return;\n    if (\n      // if the parentRRNode isn't a RRIFrameElement\n      parentRRNode?.nodeName !== \"IFRAME\" && // if node isn't a shadow root\n      node.nodeType !== NodeType.DOCUMENT_FRAGMENT_NODE\n    ) {\n      parentRRNode?.appendChild(rrNode);\n      rrNode.parentNode = parentRRNode;\n      rrNode.parentElement = parentRRNode;\n    }\n    if (node.nodeName === \"IFRAME\") {\n      const iframeDoc = getIFrameContentDocument(node);\n      iframeDoc && walk2(iframeDoc, rrNode);\n    } else if (node.nodeType === NodeType.DOCUMENT_NODE || node.nodeType === NodeType.ELEMENT_NODE || node.nodeType === NodeType.DOCUMENT_FRAGMENT_NODE) {\n      if (node.nodeType === NodeType.ELEMENT_NODE && node.shadowRoot)\n        walk2(node.shadowRoot, rrNode);\n      node.childNodes.forEach((childNode) => walk2(childNode, rrNode));\n    }\n  }\n  walk2(dom, null);\n  return rrdom;\n}\nfunction createMirror() {\n  return new Mirror22();\n}\nclass Mirror22 {\n  constructor() {\n    __publicField(this, \"idNodeMap\", /* @__PURE__ */ new Map());\n    __publicField(this, \"nodeMetaMap\", /* @__PURE__ */ new WeakMap());\n  }\n  getId(n2) {\n    if (!n2) return -1;\n    const id = this.getMeta(n2)?.id;\n    return id ?? -1;\n  }\n  getNode(id) {\n    return this.idNodeMap.get(id) || null;\n  }\n  getIds() {\n    return Array.from(this.idNodeMap.keys());\n  }\n  getMeta(n2) {\n    return this.nodeMetaMap.get(n2) || null;\n  }\n  // removes the node from idNodeMap\n  // doesn't remove the node from nodeMetaMap\n  removeNodeFromMap(n2) {\n    const id = this.getId(n2);\n    this.idNodeMap.delete(id);\n    if (n2.childNodes) {\n      n2.childNodes.forEach((childNode) => this.removeNodeFromMap(childNode));\n    }\n  }\n  has(id) {\n    return this.idNodeMap.has(id);\n  }\n  hasNode(node) {\n    return this.nodeMetaMap.has(node);\n  }\n  add(n2, meta) {\n    const id = meta.id;\n    this.idNodeMap.set(id, n2);\n    this.nodeMetaMap.set(n2, meta);\n  }\n  replace(id, n2) {\n    const oldNode = this.getNode(id);\n    if (oldNode) {\n      const meta = this.nodeMetaMap.get(oldNode);\n      if (meta) this.nodeMetaMap.set(n2, meta);\n    }\n    this.idNodeMap.set(id, n2);\n  }\n  reset() {\n    this.idNodeMap = /* @__PURE__ */ new Map();\n    this.nodeMetaMap = /* @__PURE__ */ new WeakMap();\n  }\n}\nfunction getDefaultSN(node, id) {\n  switch (node.RRNodeType) {\n    case NodeType$1.Document:\n      return {\n        id,\n        type: node.RRNodeType,\n        childNodes: []\n      };\n    case NodeType$1.DocumentType: {\n      const doctype = node;\n      return {\n        id,\n        type: node.RRNodeType,\n        name: doctype.name,\n        publicId: doctype.publicId,\n        systemId: doctype.systemId\n      };\n    }\n    case NodeType$1.Element:\n      return {\n        id,\n        type: node.RRNodeType,\n        tagName: node.tagName.toLowerCase(),\n        // In rrweb data, all tagNames are lowercase.\n        attributes: {},\n        childNodes: []\n      };\n    case NodeType$1.Text:\n      return {\n        id,\n        type: node.RRNodeType,\n        textContent: node.textContent || \"\"\n      };\n    case NodeType$1.Comment:\n      return {\n        id,\n        type: node.RRNodeType,\n        textContent: node.textContent || \"\"\n      };\n    case NodeType$1.CDATA:\n      return {\n        id,\n        type: node.RRNodeType,\n        textContent: \"\"\n      };\n  }\n}\nfunction isNodeInLinkedList(n2) {\n  return \"__ln\" in n2;\n}\nclass DoubleLinkedList {\n  constructor() {\n    this.length = 0;\n    this.head = null;\n    this.tail = null;\n  }\n  get(position) {\n    if (position >= this.length) {\n      throw new Error(\"Position outside of list range\");\n    }\n    let current = this.head;\n    for (let index = 0; index < position; index++) {\n      current = current?.next || null;\n    }\n    return current;\n  }\n  addNode(n2) {\n    const node = {\n      value: n2,\n      previous: null,\n      next: null\n    };\n    n2.__ln = node;\n    if (n2.previousSibling && isNodeInLinkedList(n2.previousSibling)) {\n      const current = n2.previousSibling.__ln.next;\n      node.next = current;\n      node.previous = n2.previousSibling.__ln;\n      n2.previousSibling.__ln.next = node;\n      if (current) {\n        current.previous = node;\n      }\n    } else if (n2.nextSibling && isNodeInLinkedList(n2.nextSibling) && n2.nextSibling.__ln.previous) {\n      const current = n2.nextSibling.__ln.previous;\n      node.previous = current;\n      node.next = n2.nextSibling.__ln;\n      n2.nextSibling.__ln.previous = node;\n      if (current) {\n        current.next = node;\n      }\n    } else {\n      if (this.head) {\n        this.head.previous = node;\n      }\n      node.next = this.head;\n      this.head = node;\n    }\n    if (node.next === null) {\n      this.tail = node;\n    }\n    this.length++;\n  }\n  removeNode(n2) {\n    const current = n2.__ln;\n    if (!this.head) {\n      return;\n    }\n    if (!current.previous) {\n      this.head = current.next;\n      if (this.head) {\n        this.head.previous = null;\n      } else {\n        this.tail = null;\n      }\n    } else {\n      current.previous.next = current.next;\n      if (current.next) {\n        current.next.previous = current.previous;\n      } else {\n        this.tail = current.previous;\n      }\n    }\n    if (n2.__ln) {\n      delete n2.__ln;\n    }\n    this.length--;\n  }\n}\nconst moveKey = (id, parentId) => `${id}@${parentId}`;\nclass MutationBuffer {\n  constructor() {\n    this.frozen = false;\n    this.locked = false;\n    this.texts = [];\n    this.attributes = [];\n    this.attributeMap = /* @__PURE__ */ new WeakMap();\n    this.removes = [];\n    this.mapRemoves = [];\n    this.movedMap = {};\n    this.addedSet = /* @__PURE__ */ new Set();\n    this.movedSet = /* @__PURE__ */ new Set();\n    this.droppedSet = /* @__PURE__ */ new Set();\n    this.processMutations = (mutations) => {\n      mutations.forEach(this.processMutation);\n      this.emit();\n    };\n    this.emit = () => {\n      if (this.frozen || this.locked) {\n        return;\n      }\n      const adds = [];\n      const addedIds = /* @__PURE__ */ new Set();\n      const addList = new DoubleLinkedList();\n      const getNextId = (n2) => {\n        let ns = n2;\n        let nextId = IGNORED_NODE;\n        while (nextId === IGNORED_NODE) {\n          ns = ns && ns.nextSibling;\n          nextId = ns && this.mirror.getId(ns);\n        }\n        return nextId;\n      };\n      const pushAdd = (n2) => {\n        if (!n2.parentNode || !inDom(n2)) {\n          return;\n        }\n        const parentId = isShadowRoot(n2.parentNode) ? this.mirror.getId(getShadowHost(n2)) : this.mirror.getId(n2.parentNode);\n        const nextId = getNextId(n2);\n        if (parentId === -1 || nextId === -1) {\n          return addList.addNode(n2);\n        }\n        const sn = serializeNodeWithId(n2, {\n          doc: this.doc,\n          mirror: this.mirror,\n          blockClass: this.blockClass,\n          blockSelector: this.blockSelector,\n          maskAllText: this.maskAllText,\n          unblockSelector: this.unblockSelector,\n          maskTextClass: this.maskTextClass,\n          unmaskTextClass: this.unmaskTextClass,\n          maskTextSelector: this.maskTextSelector,\n          unmaskTextSelector: this.unmaskTextSelector,\n          skipChild: true,\n          newlyAddedElement: true,\n          inlineStylesheet: this.inlineStylesheet,\n          maskInputOptions: this.maskInputOptions,\n          maskAttributeFn: this.maskAttributeFn,\n          maskTextFn: this.maskTextFn,\n          maskInputFn: this.maskInputFn,\n          slimDOMOptions: this.slimDOMOptions,\n          dataURLOptions: this.dataURLOptions,\n          recordCanvas: this.recordCanvas,\n          inlineImages: this.inlineImages,\n          onSerialize: (currentN) => {\n            if (isSerializedIframe(currentN, this.mirror) && !isBlocked(\n              currentN,\n              this.blockClass,\n              this.blockSelector,\n              this.unblockSelector,\n              false\n            )) {\n              this.iframeManager.addIframe(currentN);\n            }\n            if (isSerializedStylesheet(currentN, this.mirror)) {\n              this.stylesheetManager.trackLinkElement(\n                currentN\n              );\n            }\n            if (hasShadowRoot(n2)) {\n              this.shadowDomManager.addShadowRoot(n2.shadowRoot, this.doc);\n            }\n          },\n          onIframeLoad: (iframe, childSn) => {\n            if (isBlocked(\n              iframe,\n              this.blockClass,\n              this.blockSelector,\n              this.unblockSelector,\n              false\n            )) {\n              return;\n            }\n            this.iframeManager.attachIframe(iframe, childSn);\n            if (iframe.contentWindow) {\n              this.canvasManager.addWindow(iframe.contentWindow);\n            }\n            this.shadowDomManager.observeAttachShadow(iframe);\n          },\n          onStylesheetLoad: (link, childSn) => {\n            this.stylesheetManager.attachLinkElement(link, childSn);\n          },\n          onBlockedImageLoad: (_imageEl, serializedNode, { width, height }) => {\n            this.mutationCb({\n              adds: [],\n              removes: [],\n              texts: [],\n              attributes: [\n                {\n                  id: serializedNode.id,\n                  attributes: {\n                    style: {\n                      width: `${width}px`,\n                      height: `${height}px`\n                    }\n                  }\n                }\n              ]\n            });\n          },\n          ignoreCSSAttributes: this.ignoreCSSAttributes\n        });\n        if (sn) {\n          adds.push({\n            parentId,\n            nextId,\n            node: sn\n          });\n          addedIds.add(sn.id);\n        }\n      };\n      while (this.mapRemoves.length) {\n        this.mirror.removeNodeFromMap(this.mapRemoves.shift());\n      }\n      for (const n2 of this.movedSet) {\n        if (isParentRemoved(this.removes, n2, this.mirror) && !this.movedSet.has(n2.parentNode)) {\n          continue;\n        }\n        pushAdd(n2);\n      }\n      for (const n2 of this.addedSet) {\n        if (!isAncestorInSet(this.droppedSet, n2) && !isParentRemoved(this.removes, n2, this.mirror)) {\n          pushAdd(n2);\n        } else if (isAncestorInSet(this.movedSet, n2)) {\n          pushAdd(n2);\n        } else {\n          this.droppedSet.add(n2);\n        }\n      }\n      let candidate = null;\n      while (addList.length) {\n        let node = null;\n        if (candidate) {\n          const parentId = this.mirror.getId(candidate.value.parentNode);\n          const nextId = getNextId(candidate.value);\n          if (parentId !== -1 && nextId !== -1) {\n            node = candidate;\n          }\n        }\n        if (!node) {\n          let tailNode = addList.tail;\n          while (tailNode) {\n            const _node = tailNode;\n            tailNode = tailNode.previous;\n            if (_node) {\n              const parentId = this.mirror.getId(_node.value.parentNode);\n              const nextId = getNextId(_node.value);\n              if (nextId === -1) continue;\n              else if (parentId !== -1) {\n                node = _node;\n                break;\n              } else {\n                const unhandledNode = _node.value;\n                if (unhandledNode.parentNode && unhandledNode.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n                  const shadowHost = unhandledNode.parentNode.host;\n                  const parentId2 = this.mirror.getId(shadowHost);\n                  if (parentId2 !== -1) {\n                    node = _node;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n        }\n        if (!node) {\n          while (addList.head) {\n            addList.removeNode(addList.head.value);\n          }\n          break;\n        }\n        candidate = node.previous;\n        addList.removeNode(node.value);\n        pushAdd(node.value);\n      }\n      const payload = {\n        texts: this.texts.map((text) => ({\n          id: this.mirror.getId(text.node),\n          value: text.value\n        })).filter((text) => !addedIds.has(text.id)).filter((text) => this.mirror.has(text.id)),\n        attributes: this.attributes.map((attribute) => {\n          const { attributes } = attribute;\n          if (typeof attributes.style === \"string\") {\n            const diffAsStr = JSON.stringify(attribute.styleDiff);\n            const unchangedAsStr = JSON.stringify(attribute._unchangedStyles);\n            if (diffAsStr.length < attributes.style.length) {\n              if ((diffAsStr + unchangedAsStr).split(\"var(\").length === attributes.style.split(\"var(\").length) {\n                attributes.style = attribute.styleDiff;\n              }\n            }\n          }\n          return {\n            id: this.mirror.getId(attribute.node),\n            attributes\n          };\n        }).filter((attribute) => !addedIds.has(attribute.id)).filter((attribute) => this.mirror.has(attribute.id)),\n        removes: this.removes,\n        adds\n      };\n      if (!payload.texts.length && !payload.attributes.length && !payload.removes.length && !payload.adds.length) {\n        return;\n      }\n      this.texts = [];\n      this.attributes = [];\n      this.attributeMap = /* @__PURE__ */ new WeakMap();\n      this.removes = [];\n      this.addedSet = /* @__PURE__ */ new Set();\n      this.movedSet = /* @__PURE__ */ new Set();\n      this.droppedSet = /* @__PURE__ */ new Set();\n      this.movedMap = {};\n      this.mutationCb(payload);\n    };\n    this.processMutation = (m) => {\n      if (isIgnored(m.target, this.mirror)) {\n        return;\n      }\n      switch (m.type) {\n        case \"characterData\": {\n          const value = m.target.textContent;\n          if (!isBlocked(\n            m.target,\n            this.blockClass,\n            this.blockSelector,\n            this.unblockSelector,\n            false\n          ) && value !== m.oldValue) {\n            this.texts.push({\n              value: needMaskingText(\n                m.target,\n                this.maskTextClass,\n                this.maskTextSelector,\n                this.unmaskTextClass,\n                this.unmaskTextSelector,\n                this.maskAllText\n              ) && value ? this.maskTextFn ? this.maskTextFn(value, closestElementOfNode(m.target)) : value.replace(/[\\S]/g, \"*\") : value,\n              node: m.target\n            });\n          }\n          break;\n        }\n        case \"attributes\": {\n          const target = m.target;\n          let attributeName = m.attributeName;\n          let value = m.target.getAttribute(attributeName);\n          if (attributeName === \"value\") {\n            const type = getInputType(target);\n            const tagName = target.tagName;\n            value = getInputValue(target, tagName, type);\n            const isInputMasked = shouldMaskInput({\n              maskInputOptions: this.maskInputOptions,\n              tagName,\n              type\n            });\n            const forceMask = needMaskingText(\n              m.target,\n              this.maskTextClass,\n              this.maskTextSelector,\n              this.unmaskTextClass,\n              this.unmaskTextSelector,\n              isInputMasked\n            );\n            value = maskInputValue({\n              isMasked: forceMask,\n              element: target,\n              value,\n              maskInputFn: this.maskInputFn\n            });\n          }\n          if (isBlocked(\n            m.target,\n            this.blockClass,\n            this.blockSelector,\n            this.unblockSelector,\n            false\n          ) || value === m.oldValue) {\n            return;\n          }\n          let item = this.attributeMap.get(m.target);\n          if (target.tagName === \"IFRAME\" && attributeName === \"src\" && !this.keepIframeSrcFn(value)) {\n            const iframeDoc = getIFrameContentDocument(\n              target\n            );\n            if (!iframeDoc) {\n              attributeName = \"rr_src\";\n            } else {\n              return;\n            }\n          }\n          if (!item) {\n            item = {\n              node: m.target,\n              attributes: {},\n              styleDiff: {},\n              _unchangedStyles: {}\n            };\n            this.attributes.push(item);\n            this.attributeMap.set(m.target, item);\n          }\n          if (attributeName === \"type\" && target.tagName === \"INPUT\" && (m.oldValue || \"\").toLowerCase() === \"password\") {\n            target.setAttribute(\"data-rr-is-password\", \"true\");\n          }\n          if (!ignoreAttribute(target.tagName, attributeName)) {\n            item.attributes[attributeName] = transformAttribute(\n              this.doc,\n              toLowerCase(target.tagName),\n              toLowerCase(attributeName),\n              value,\n              target,\n              this.maskAttributeFn\n            );\n            if (attributeName === \"style\") {\n              if (!this.unattachedDoc) {\n                try {\n                  this.unattachedDoc = document.implementation.createHTMLDocument();\n                } catch (e2) {\n                  this.unattachedDoc = this.doc;\n                }\n              }\n              const old = this.unattachedDoc.createElement(\"span\");\n              if (m.oldValue) {\n                old.setAttribute(\"style\", m.oldValue);\n              }\n              for (const pname of Array.from(target.style)) {\n                const newValue = target.style.getPropertyValue(pname);\n                const newPriority = target.style.getPropertyPriority(pname);\n                if (newValue !== old.style.getPropertyValue(pname) || newPriority !== old.style.getPropertyPriority(pname)) {\n                  if (newPriority === \"\") {\n                    item.styleDiff[pname] = newValue;\n                  } else {\n                    item.styleDiff[pname] = [newValue, newPriority];\n                  }\n                } else {\n                  item._unchangedStyles[pname] = [newValue, newPriority];\n                }\n              }\n              for (const pname of Array.from(old.style)) {\n                if (target.style.getPropertyValue(pname) === \"\") {\n                  item.styleDiff[pname] = false;\n                }\n              }\n            }\n          }\n          break;\n        }\n        case \"childList\": {\n          if (isBlocked(\n            m.target,\n            this.blockClass,\n            this.blockSelector,\n            this.unblockSelector,\n            true\n          )) {\n            return;\n          }\n          m.addedNodes.forEach((n2) => this.genAdds(n2, m.target));\n          m.removedNodes.forEach((n2) => {\n            const nodeId = this.mirror.getId(n2);\n            const parentId = isShadowRoot(m.target) ? this.mirror.getId(m.target.host) : this.mirror.getId(m.target);\n            if (isBlocked(\n              m.target,\n              this.blockClass,\n              this.blockSelector,\n              this.unblockSelector,\n              false\n            ) || isIgnored(n2, this.mirror) || !isSerialized(n2, this.mirror)) {\n              return;\n            }\n            if (this.addedSet.has(n2)) {\n              deepDelete(this.addedSet, n2);\n              this.droppedSet.add(n2);\n            } else if (this.addedSet.has(m.target) && nodeId === -1) ;\n            else if (isAncestorRemoved(m.target, this.mirror)) ;\n            else if (this.movedSet.has(n2) && this.movedMap[moveKey(nodeId, parentId)]) {\n              deepDelete(this.movedSet, n2);\n            } else {\n              this.removes.push({\n                parentId,\n                id: nodeId,\n                isShadow: isShadowRoot(m.target) && isNativeShadowDom(m.target) ? true : void 0\n              });\n            }\n            this.mapRemoves.push(n2);\n          });\n          break;\n        }\n      }\n    };\n    this.genAdds = (n2, target) => {\n      if (this.processedNodeManager.inOtherBuffer(n2, this)) return;\n      if (this.addedSet.has(n2) || this.movedSet.has(n2)) return;\n      if (this.mirror.hasNode(n2)) {\n        if (isIgnored(n2, this.mirror)) {\n          return;\n        }\n        this.movedSet.add(n2);\n        let targetId = null;\n        if (target && this.mirror.hasNode(target)) {\n          targetId = this.mirror.getId(target);\n        }\n        if (targetId && targetId !== -1) {\n          this.movedMap[moveKey(this.mirror.getId(n2), targetId)] = true;\n        }\n      } else {\n        this.addedSet.add(n2);\n        this.droppedSet.delete(n2);\n      }\n      if (!isBlocked(\n        n2,\n        this.blockClass,\n        this.blockSelector,\n        this.unblockSelector,\n        false\n      )) {\n        if (n2.childNodes) {\n          n2.childNodes.forEach((childN) => this.genAdds(childN));\n        }\n        if (hasShadowRoot(n2)) {\n          n2.shadowRoot.childNodes.forEach((childN) => {\n            this.processedNodeManager.add(childN, this);\n            this.genAdds(childN, n2);\n          });\n        }\n      }\n    };\n  }\n  init(options) {\n    [\n      \"mutationCb\",\n      \"blockClass\",\n      \"blockSelector\",\n      \"unblockSelector\",\n      \"maskAllText\",\n      \"maskTextClass\",\n      \"unmaskTextClass\",\n      \"maskTextSelector\",\n      \"unmaskTextSelector\",\n      \"inlineStylesheet\",\n      \"maskInputOptions\",\n      \"maskAttributeFn\",\n      \"maskTextFn\",\n      \"maskInputFn\",\n      \"keepIframeSrcFn\",\n      \"recordCanvas\",\n      \"inlineImages\",\n      \"slimDOMOptions\",\n      \"dataURLOptions\",\n      \"doc\",\n      \"mirror\",\n      \"iframeManager\",\n      \"stylesheetManager\",\n      \"shadowDomManager\",\n      \"canvasManager\",\n      \"processedNodeManager\",\n      \"ignoreCSSAttributes\"\n    ].forEach((key) => {\n      this[key] = options[key];\n    });\n  }\n  freeze() {\n    this.frozen = true;\n    this.canvasManager.freeze();\n  }\n  unfreeze() {\n    this.frozen = false;\n    this.canvasManager.unfreeze();\n    this.emit();\n  }\n  isFrozen() {\n    return this.frozen;\n  }\n  lock() {\n    this.locked = true;\n    this.canvasManager.lock();\n  }\n  unlock() {\n    this.locked = false;\n    this.canvasManager.unlock();\n    this.emit();\n  }\n  reset() {\n    this.shadowDomManager.reset();\n    this.canvasManager.reset();\n  }\n}\nfunction deepDelete(addsSet, n2) {\n  addsSet.delete(n2);\n  n2.childNodes?.forEach((childN) => deepDelete(addsSet, childN));\n}\nfunction isParentRemoved(removes, n2, mirror2) {\n  if (removes.length === 0) return false;\n  return _isParentRemoved(removes, n2, mirror2);\n}\nfunction _isParentRemoved(removes, n2, mirror2) {\n  let node = n2.parentNode;\n  while (node) {\n    const parentId = mirror2.getId(node);\n    if (removes.some((r2) => r2.id === parentId)) {\n      return true;\n    }\n    node = node.parentNode;\n  }\n  return false;\n}\nfunction isAncestorInSet(set, n2) {\n  if (set.size === 0) return false;\n  return _isAncestorInSet(set, n2);\n}\nfunction _isAncestorInSet(set, n2) {\n  const { parentNode } = n2;\n  if (!parentNode) {\n    return false;\n  }\n  if (set.has(parentNode)) {\n    return true;\n  }\n  return _isAncestorInSet(set, parentNode);\n}\nlet errorHandler;\nfunction registerErrorHandler(handler) {\n  errorHandler = handler;\n}\nfunction unregisterErrorHandler() {\n  errorHandler = void 0;\n}\nconst callbackWrapper = (cb) => {\n  if (!errorHandler) {\n    return cb;\n  }\n  const rrwebWrapped = (...rest) => {\n    try {\n      return cb(...rest);\n    } catch (error) {\n      if (errorHandler && errorHandler(error) === true) {\n        return () => {\n        };\n      }\n      throw error;\n    }\n  };\n  return rrwebWrapped;\n};\nconst mutationBuffers = [];\nfunction getEventTarget(event) {\n  try {\n    if (\"composedPath\" in event) {\n      const path = event.composedPath();\n      if (path.length) {\n        return path[0];\n      }\n    } else if (\"path\" in event && event.path.length) {\n      return event.path[0];\n    }\n  } catch {\n  }\n  return event && event.target;\n}\nfunction initMutationObserver(options, rootEl) {\n  const mutationBuffer = new MutationBuffer();\n  mutationBuffers.push(mutationBuffer);\n  mutationBuffer.init(options);\n  let mutationObserverCtor = window.MutationObserver || /**\n  * Some websites may disable MutationObserver by removing it from the window object.\n  * If someone is using rrweb to build a browser extention or things like it, they\n  * could not change the website's code but can have an opportunity to inject some\n  * code before the website executing its JS logic.\n  * Then they can do this to store the native MutationObserver:\n  * window.__rrMutationObserver = MutationObserver\n  */\n  window.__rrMutationObserver;\n  const angularZoneSymbol = window?.Zone?.__symbol__?.(\"MutationObserver\");\n  if (angularZoneSymbol && window[angularZoneSymbol]) {\n    mutationObserverCtor = window[angularZoneSymbol];\n  }\n  const observer = new mutationObserverCtor(\n    callbackWrapper((mutations) => {\n      if (options.onMutation && options.onMutation(mutations) === false) {\n        return;\n      }\n      mutationBuffer.processMutations.bind(mutationBuffer)(mutations);\n    })\n  );\n  observer.observe(rootEl, {\n    attributes: true,\n    attributeOldValue: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true\n  });\n  return observer;\n}\nfunction initMoveObserver({\n  mousemoveCb,\n  sampling,\n  doc,\n  mirror: mirror2\n}) {\n  if (sampling.mousemove === false) {\n    return () => {\n    };\n  }\n  const threshold = typeof sampling.mousemove === \"number\" ? sampling.mousemove : 50;\n  const callbackThreshold = typeof sampling.mousemoveCallback === \"number\" ? sampling.mousemoveCallback : 500;\n  let positions = [];\n  let timeBaseline;\n  const wrappedCb = throttle(\n    callbackWrapper(\n      (source) => {\n        const totalOffset = Date.now() - timeBaseline;\n        mousemoveCb(\n          positions.map((p) => {\n            p.timeOffset -= totalOffset;\n            return p;\n          }),\n          source\n        );\n        positions = [];\n        timeBaseline = null;\n      }\n    ),\n    callbackThreshold\n  );\n  const updatePosition = callbackWrapper(\n    throttle(\n      callbackWrapper((evt) => {\n        const target = getEventTarget(evt);\n        const { clientX, clientY } = legacy_isTouchEvent(evt) ? evt.changedTouches[0] : evt;\n        if (!timeBaseline) {\n          timeBaseline = nowTimestamp();\n        }\n        positions.push({\n          x: clientX,\n          y: clientY,\n          id: mirror2.getId(target),\n          timeOffset: nowTimestamp() - timeBaseline\n        });\n        wrappedCb(\n          typeof DragEvent !== \"undefined\" && evt instanceof DragEvent ? IncrementalSource.Drag : evt instanceof MouseEvent ? IncrementalSource.MouseMove : IncrementalSource.TouchMove\n        );\n      }),\n      threshold,\n      {\n        trailing: false\n      }\n    )\n  );\n  const handlers = [\n    on(\"mousemove\", updatePosition, doc),\n    on(\"touchmove\", updatePosition, doc),\n    on(\"drag\", updatePosition, doc)\n  ];\n  return callbackWrapper(() => {\n    handlers.forEach((h) => h());\n  });\n}\nfunction initMouseInteractionObserver({\n  mouseInteractionCb,\n  doc,\n  mirror: mirror2,\n  blockClass,\n  blockSelector,\n  unblockSelector,\n  sampling\n}) {\n  if (sampling.mouseInteraction === false) {\n    return () => {\n    };\n  }\n  const disableMap = sampling.mouseInteraction === true || sampling.mouseInteraction === void 0 ? {} : sampling.mouseInteraction;\n  const handlers = [];\n  let currentPointerType = null;\n  const getHandler = (eventKey) => {\n    return (event) => {\n      const target = getEventTarget(event);\n      if (isBlocked(target, blockClass, blockSelector, unblockSelector, true)) {\n        return;\n      }\n      let pointerType = null;\n      let thisEventKey = eventKey;\n      if (\"pointerType\" in event) {\n        switch (event.pointerType) {\n          case \"mouse\":\n            pointerType = PointerTypes.Mouse;\n            break;\n          case \"touch\":\n            pointerType = PointerTypes.Touch;\n            break;\n          case \"pen\":\n            pointerType = PointerTypes.Pen;\n            break;\n        }\n        if (pointerType === PointerTypes.Touch) {\n          if (MouseInteractions[eventKey] === MouseInteractions.MouseDown) {\n            thisEventKey = \"TouchStart\";\n          } else if (MouseInteractions[eventKey] === MouseInteractions.MouseUp) {\n            thisEventKey = \"TouchEnd\";\n          }\n        } else if (pointerType === PointerTypes.Pen) ;\n      } else if (legacy_isTouchEvent(event)) {\n        pointerType = PointerTypes.Touch;\n      }\n      if (pointerType !== null) {\n        currentPointerType = pointerType;\n        if (thisEventKey.startsWith(\"Touch\") && pointerType === PointerTypes.Touch || thisEventKey.startsWith(\"Mouse\") && pointerType === PointerTypes.Mouse) {\n          pointerType = null;\n        }\n      } else if (MouseInteractions[eventKey] === MouseInteractions.Click) {\n        pointerType = currentPointerType;\n        currentPointerType = null;\n      }\n      const e2 = legacy_isTouchEvent(event) ? event.changedTouches[0] : event;\n      if (!e2) {\n        return;\n      }\n      const id = mirror2.getId(target);\n      const { clientX, clientY } = e2;\n      callbackWrapper(mouseInteractionCb)({\n        type: MouseInteractions[thisEventKey],\n        id,\n        x: clientX,\n        y: clientY,\n        ...pointerType !== null && { pointerType }\n      });\n    };\n  };\n  Object.keys(MouseInteractions).filter(\n    (key) => Number.isNaN(Number(key)) && !key.endsWith(\"_Departed\") && disableMap[key] !== false\n  ).forEach((eventKey) => {\n    let eventName = toLowerCase(eventKey);\n    const handler = getHandler(eventKey);\n    if (window.PointerEvent) {\n      switch (MouseInteractions[eventKey]) {\n        case MouseInteractions.MouseDown:\n        case MouseInteractions.MouseUp:\n          eventName = eventName.replace(\n            \"mouse\",\n            \"pointer\"\n          );\n          break;\n        case MouseInteractions.TouchStart:\n        case MouseInteractions.TouchEnd:\n          return;\n      }\n    }\n    handlers.push(on(eventName, handler, doc));\n  });\n  return callbackWrapper(() => {\n    handlers.forEach((h) => h());\n  });\n}\nfunction initScrollObserver({\n  scrollCb,\n  doc,\n  mirror: mirror2,\n  blockClass,\n  blockSelector,\n  unblockSelector,\n  sampling\n}) {\n  const updatePosition = callbackWrapper(\n    throttle(\n      callbackWrapper((evt) => {\n        const target = getEventTarget(evt);\n        if (!target || isBlocked(\n          target,\n          blockClass,\n          blockSelector,\n          unblockSelector,\n          true\n        )) {\n          return;\n        }\n        const id = mirror2.getId(target);\n        if (target === doc && doc.defaultView) {\n          const scrollLeftTop = getWindowScroll(doc.defaultView);\n          scrollCb({\n            id,\n            x: scrollLeftTop.left,\n            y: scrollLeftTop.top\n          });\n        } else {\n          scrollCb({\n            id,\n            x: target.scrollLeft,\n            y: target.scrollTop\n          });\n        }\n      }),\n      sampling.scroll || 100\n    )\n  );\n  return on(\"scroll\", updatePosition, doc);\n}\nfunction initViewportResizeObserver({ viewportResizeCb }, { win }) {\n  let lastH = -1;\n  let lastW = -1;\n  const updateDimension = callbackWrapper(\n    throttle(\n      callbackWrapper(() => {\n        const height = getWindowHeight();\n        const width = getWindowWidth();\n        if (lastH !== height || lastW !== width) {\n          viewportResizeCb({\n            width: Number(width),\n            height: Number(height)\n          });\n          lastH = height;\n          lastW = width;\n        }\n      }),\n      200\n    )\n  );\n  return on(\"resize\", updateDimension, win);\n}\nconst INPUT_TAGS = [\"INPUT\", \"TEXTAREA\", \"SELECT\"];\nconst lastInputValueMap = /* @__PURE__ */ new WeakMap();\nfunction initInputObserver({\n  inputCb,\n  doc,\n  mirror: mirror2,\n  blockClass,\n  blockSelector,\n  unblockSelector,\n  ignoreClass,\n  ignoreSelector,\n  maskInputOptions,\n  maskInputFn,\n  sampling,\n  userTriggeredOnInput,\n  maskTextClass,\n  unmaskTextClass,\n  maskTextSelector,\n  unmaskTextSelector\n}) {\n  function eventHandler(event) {\n    let target = getEventTarget(event);\n    const userTriggered = event.isTrusted;\n    const tagName = target && toUpperCase(target.tagName);\n    if (tagName === \"OPTION\") target = target.parentElement;\n    if (!target || !tagName || INPUT_TAGS.indexOf(tagName) < 0 || isBlocked(\n      target,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      true\n    )) {\n      return;\n    }\n    const el = target;\n    if (el.classList.contains(ignoreClass) || ignoreSelector && el.matches(ignoreSelector)) {\n      return;\n    }\n    const type = getInputType(target);\n    let text = getInputValue(el, tagName, type);\n    let isChecked = false;\n    const isInputMasked = shouldMaskInput({\n      maskInputOptions,\n      tagName,\n      type\n    });\n    const forceMask = needMaskingText(\n      target,\n      maskTextClass,\n      maskTextSelector,\n      unmaskTextClass,\n      unmaskTextSelector,\n      isInputMasked\n    );\n    if (type === \"radio\" || type === \"checkbox\") {\n      isChecked = target.checked;\n    }\n    text = maskInputValue({\n      isMasked: forceMask,\n      element: target,\n      value: text,\n      maskInputFn\n    });\n    cbWithDedup(\n      target,\n      userTriggeredOnInput ? { text, isChecked, userTriggered } : { text, isChecked }\n    );\n    const name = target.name;\n    if (type === \"radio\" && name && isChecked) {\n      doc.querySelectorAll(`input[type=\"radio\"][name=\"${name}\"]`).forEach((el2) => {\n        if (el2 !== target) {\n          const text2 = maskInputValue({\n            // share mask behavior of `target`\n            isMasked: forceMask,\n            element: el2,\n            value: getInputValue(el2, tagName, type),\n            maskInputFn\n          });\n          cbWithDedup(\n            el2,\n            userTriggeredOnInput ? { text: text2, isChecked: !isChecked, userTriggered: false } : { text: text2, isChecked: !isChecked }\n          );\n        }\n      });\n    }\n  }\n  function cbWithDedup(target, v2) {\n    const lastInputValue = lastInputValueMap.get(target);\n    if (!lastInputValue || lastInputValue.text !== v2.text || lastInputValue.isChecked !== v2.isChecked) {\n      lastInputValueMap.set(target, v2);\n      const id = mirror2.getId(target);\n      callbackWrapper(inputCb)({\n        ...v2,\n        id\n      });\n    }\n  }\n  const events = sampling.input === \"last\" ? [\"change\"] : [\"input\", \"change\"];\n  const handlers = events.map(\n    (eventName) => on(eventName, callbackWrapper(eventHandler), doc)\n  );\n  const currentWindow = doc.defaultView;\n  if (!currentWindow) {\n    return () => {\n      handlers.forEach((h) => h());\n    };\n  }\n  const propertyDescriptor = currentWindow.Object.getOwnPropertyDescriptor(\n    currentWindow.HTMLInputElement.prototype,\n    \"value\"\n  );\n  const hookProperties = [\n    [currentWindow.HTMLInputElement.prototype, \"value\"],\n    [currentWindow.HTMLInputElement.prototype, \"checked\"],\n    [currentWindow.HTMLSelectElement.prototype, \"value\"],\n    [currentWindow.HTMLTextAreaElement.prototype, \"value\"],\n    // Some UI library use selectedIndex to set select value\n    [currentWindow.HTMLSelectElement.prototype, \"selectedIndex\"],\n    [currentWindow.HTMLOptionElement.prototype, \"selected\"]\n  ];\n  if (propertyDescriptor && propertyDescriptor.set) {\n    handlers.push(\n      ...hookProperties.map(\n        (p) => hookSetter(\n          p[0],\n          p[1],\n          {\n            set() {\n              callbackWrapper(eventHandler)({\n                target: this,\n                isTrusted: false\n                // userTriggered to false as this could well be programmatic\n              });\n            }\n          },\n          false,\n          currentWindow\n        )\n      )\n    );\n  }\n  return callbackWrapper(() => {\n    handlers.forEach((h) => h());\n  });\n}\nfunction getNestedCSSRulePositions(rule) {\n  const positions = [];\n  function recurse(childRule, pos) {\n    if (hasNestedCSSRule(\"CSSGroupingRule\") && childRule.parentRule instanceof CSSGroupingRule || hasNestedCSSRule(\"CSSMediaRule\") && childRule.parentRule instanceof CSSMediaRule || hasNestedCSSRule(\"CSSSupportsRule\") && childRule.parentRule instanceof CSSSupportsRule || hasNestedCSSRule(\"CSSConditionRule\") && childRule.parentRule instanceof CSSConditionRule) {\n      const rules2 = Array.from(\n        childRule.parentRule.cssRules\n      );\n      const index = rules2.indexOf(childRule);\n      pos.unshift(index);\n    } else if (childRule.parentStyleSheet) {\n      const rules2 = Array.from(childRule.parentStyleSheet.cssRules);\n      const index = rules2.indexOf(childRule);\n      pos.unshift(index);\n    }\n    return pos;\n  }\n  return recurse(rule, positions);\n}\nfunction getIdAndStyleId(sheet, mirror2, styleMirror) {\n  let id, styleId;\n  if (!sheet) return {};\n  if (sheet.ownerNode) id = mirror2.getId(sheet.ownerNode);\n  else styleId = styleMirror.getId(sheet);\n  return {\n    styleId,\n    id\n  };\n}\nfunction initStyleSheetObserver({ styleSheetRuleCb, mirror: mirror2, stylesheetManager }, { win }) {\n  if (!win.CSSStyleSheet || !win.CSSStyleSheet.prototype) {\n    return () => {\n    };\n  }\n  const insertRule = win.CSSStyleSheet.prototype.insertRule;\n  win.CSSStyleSheet.prototype.insertRule = new Proxy(insertRule, {\n    apply: callbackWrapper(\n      (target, thisArg, argumentsList) => {\n        const [rule, index] = argumentsList;\n        const { id, styleId } = getIdAndStyleId(\n          thisArg,\n          mirror2,\n          stylesheetManager.styleMirror\n        );\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleSheetRuleCb({\n            id,\n            styleId,\n            adds: [{ rule, index }]\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      }\n    )\n  });\n  const deleteRule = win.CSSStyleSheet.prototype.deleteRule;\n  win.CSSStyleSheet.prototype.deleteRule = new Proxy(deleteRule, {\n    apply: callbackWrapper(\n      (target, thisArg, argumentsList) => {\n        const [index] = argumentsList;\n        const { id, styleId } = getIdAndStyleId(\n          thisArg,\n          mirror2,\n          stylesheetManager.styleMirror\n        );\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleSheetRuleCb({\n            id,\n            styleId,\n            removes: [{ index }]\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      }\n    )\n  });\n  let replace;\n  if (win.CSSStyleSheet.prototype.replace) {\n    replace = win.CSSStyleSheet.prototype.replace;\n    win.CSSStyleSheet.prototype.replace = new Proxy(replace, {\n      apply: callbackWrapper(\n        (target, thisArg, argumentsList) => {\n          const [text] = argumentsList;\n          const { id, styleId } = getIdAndStyleId(\n            thisArg,\n            mirror2,\n            stylesheetManager.styleMirror\n          );\n          if (id && id !== -1 || styleId && styleId !== -1) {\n            styleSheetRuleCb({\n              id,\n              styleId,\n              replace: text\n            });\n          }\n          return target.apply(thisArg, argumentsList);\n        }\n      )\n    });\n  }\n  let replaceSync;\n  if (win.CSSStyleSheet.prototype.replaceSync) {\n    replaceSync = win.CSSStyleSheet.prototype.replaceSync;\n    win.CSSStyleSheet.prototype.replaceSync = new Proxy(replaceSync, {\n      apply: callbackWrapper(\n        (target, thisArg, argumentsList) => {\n          const [text] = argumentsList;\n          const { id, styleId } = getIdAndStyleId(\n            thisArg,\n            mirror2,\n            stylesheetManager.styleMirror\n          );\n          if (id && id !== -1 || styleId && styleId !== -1) {\n            styleSheetRuleCb({\n              id,\n              styleId,\n              replaceSync: text\n            });\n          }\n          return target.apply(thisArg, argumentsList);\n        }\n      )\n    });\n  }\n  const supportedNestedCSSRuleTypes = {};\n  if (canMonkeyPatchNestedCSSRule(\"CSSGroupingRule\")) {\n    supportedNestedCSSRuleTypes.CSSGroupingRule = win.CSSGroupingRule;\n  } else {\n    if (canMonkeyPatchNestedCSSRule(\"CSSMediaRule\")) {\n      supportedNestedCSSRuleTypes.CSSMediaRule = win.CSSMediaRule;\n    }\n    if (canMonkeyPatchNestedCSSRule(\"CSSConditionRule\")) {\n      supportedNestedCSSRuleTypes.CSSConditionRule = win.CSSConditionRule;\n    }\n    if (canMonkeyPatchNestedCSSRule(\"CSSSupportsRule\")) {\n      supportedNestedCSSRuleTypes.CSSSupportsRule = win.CSSSupportsRule;\n    }\n  }\n  const unmodifiedFunctions = {};\n  Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {\n    unmodifiedFunctions[typeKey] = {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      insertRule: type.prototype.insertRule,\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      deleteRule: type.prototype.deleteRule\n    };\n    type.prototype.insertRule = new Proxy(\n      unmodifiedFunctions[typeKey].insertRule,\n      {\n        apply: callbackWrapper(\n          (target, thisArg, argumentsList) => {\n            const [rule, index] = argumentsList;\n            const { id, styleId } = getIdAndStyleId(\n              thisArg.parentStyleSheet,\n              mirror2,\n              stylesheetManager.styleMirror\n            );\n            if (id && id !== -1 || styleId && styleId !== -1) {\n              styleSheetRuleCb({\n                id,\n                styleId,\n                adds: [\n                  {\n                    rule,\n                    index: [\n                      ...getNestedCSSRulePositions(thisArg),\n                      index || 0\n                      // defaults to 0\n                    ]\n                  }\n                ]\n              });\n            }\n            return target.apply(thisArg, argumentsList);\n          }\n        )\n      }\n    );\n    type.prototype.deleteRule = new Proxy(\n      unmodifiedFunctions[typeKey].deleteRule,\n      {\n        apply: callbackWrapper(\n          (target, thisArg, argumentsList) => {\n            const [index] = argumentsList;\n            const { id, styleId } = getIdAndStyleId(\n              thisArg.parentStyleSheet,\n              mirror2,\n              stylesheetManager.styleMirror\n            );\n            if (id && id !== -1 || styleId && styleId !== -1) {\n              styleSheetRuleCb({\n                id,\n                styleId,\n                removes: [\n                  { index: [...getNestedCSSRulePositions(thisArg), index] }\n                ]\n              });\n            }\n            return target.apply(thisArg, argumentsList);\n          }\n        )\n      }\n    );\n  });\n  return callbackWrapper(() => {\n    win.CSSStyleSheet.prototype.insertRule = insertRule;\n    win.CSSStyleSheet.prototype.deleteRule = deleteRule;\n    replace && (win.CSSStyleSheet.prototype.replace = replace);\n    replaceSync && (win.CSSStyleSheet.prototype.replaceSync = replaceSync);\n    Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {\n      type.prototype.insertRule = unmodifiedFunctions[typeKey].insertRule;\n      type.prototype.deleteRule = unmodifiedFunctions[typeKey].deleteRule;\n    });\n  });\n}\nfunction initAdoptedStyleSheetObserver({\n  mirror: mirror2,\n  stylesheetManager\n}, host) {\n  let hostId = null;\n  if (host.nodeName === \"#document\") hostId = mirror2.getId(host);\n  else hostId = mirror2.getId(host.host);\n  const patchTarget = host.nodeName === \"#document\" ? host.defaultView?.Document : host.ownerDocument?.defaultView?.ShadowRoot;\n  const originalPropertyDescriptor = patchTarget?.prototype ? Object.getOwnPropertyDescriptor(\n    patchTarget?.prototype,\n    \"adoptedStyleSheets\"\n  ) : void 0;\n  if (hostId === null || hostId === -1 || !patchTarget || !originalPropertyDescriptor)\n    return () => {\n    };\n  Object.defineProperty(host, \"adoptedStyleSheets\", {\n    configurable: originalPropertyDescriptor.configurable,\n    enumerable: originalPropertyDescriptor.enumerable,\n    get() {\n      return originalPropertyDescriptor.get?.call(this);\n    },\n    set(sheets) {\n      const result = originalPropertyDescriptor.set?.call(this, sheets);\n      if (hostId !== null && hostId !== -1) {\n        try {\n          stylesheetManager.adoptStyleSheets(sheets, hostId);\n        } catch (e2) {\n        }\n      }\n      return result;\n    }\n  });\n  return callbackWrapper(() => {\n    Object.defineProperty(host, \"adoptedStyleSheets\", {\n      configurable: originalPropertyDescriptor.configurable,\n      enumerable: originalPropertyDescriptor.enumerable,\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      get: originalPropertyDescriptor.get,\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      set: originalPropertyDescriptor.set\n    });\n  });\n}\nfunction initStyleDeclarationObserver({\n  styleDeclarationCb,\n  mirror: mirror2,\n  ignoreCSSAttributes,\n  stylesheetManager\n}, { win }) {\n  const setProperty = win.CSSStyleDeclaration.prototype.setProperty;\n  win.CSSStyleDeclaration.prototype.setProperty = new Proxy(setProperty, {\n    apply: callbackWrapper(\n      (target, thisArg, argumentsList) => {\n        const [property, value, priority] = argumentsList;\n        if (ignoreCSSAttributes.has(property)) {\n          return setProperty.apply(thisArg, [property, value, priority]);\n        }\n        const { id, styleId } = getIdAndStyleId(\n          thisArg.parentRule?.parentStyleSheet,\n          mirror2,\n          stylesheetManager.styleMirror\n        );\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleDeclarationCb({\n            id,\n            styleId,\n            set: {\n              property,\n              value,\n              priority\n            },\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            index: getNestedCSSRulePositions(thisArg.parentRule)\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      }\n    )\n  });\n  const removeProperty = win.CSSStyleDeclaration.prototype.removeProperty;\n  win.CSSStyleDeclaration.prototype.removeProperty = new Proxy(removeProperty, {\n    apply: callbackWrapper(\n      (target, thisArg, argumentsList) => {\n        const [property] = argumentsList;\n        if (ignoreCSSAttributes.has(property)) {\n          return removeProperty.apply(thisArg, [property]);\n        }\n        const { id, styleId } = getIdAndStyleId(\n          thisArg.parentRule?.parentStyleSheet,\n          mirror2,\n          stylesheetManager.styleMirror\n        );\n        if (id && id !== -1 || styleId && styleId !== -1) {\n          styleDeclarationCb({\n            id,\n            styleId,\n            remove: {\n              property\n            },\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            index: getNestedCSSRulePositions(thisArg.parentRule)\n          });\n        }\n        return target.apply(thisArg, argumentsList);\n      }\n    )\n  });\n  return callbackWrapper(() => {\n    win.CSSStyleDeclaration.prototype.setProperty = setProperty;\n    win.CSSStyleDeclaration.prototype.removeProperty = removeProperty;\n  });\n}\nfunction initMediaInteractionObserver({\n  mediaInteractionCb,\n  blockClass,\n  blockSelector,\n  unblockSelector,\n  mirror: mirror2,\n  sampling,\n  doc\n}) {\n  const handler = callbackWrapper(\n    (type) => throttle(\n      callbackWrapper((event) => {\n        const target = getEventTarget(event);\n        if (!target || isBlocked(\n          target,\n          blockClass,\n          blockSelector,\n          unblockSelector,\n          true\n        )) {\n          return;\n        }\n        const { currentTime, volume, muted, playbackRate } = target;\n        mediaInteractionCb({\n          type,\n          id: mirror2.getId(target),\n          currentTime,\n          volume,\n          muted,\n          playbackRate\n        });\n      }),\n      sampling.media || 500\n    )\n  );\n  const handlers = [\n    on(\"play\", handler(MediaInteractions.Play), doc),\n    on(\"pause\", handler(MediaInteractions.Pause), doc),\n    on(\"seeked\", handler(MediaInteractions.Seeked), doc),\n    on(\"volumechange\", handler(MediaInteractions.VolumeChange), doc),\n    on(\"ratechange\", handler(MediaInteractions.RateChange), doc)\n  ];\n  return callbackWrapper(() => {\n    handlers.forEach((h) => h());\n  });\n}\nfunction initFontObserver({ fontCb, doc }) {\n  const win = doc.defaultView;\n  if (!win) {\n    return () => {\n    };\n  }\n  const handlers = [];\n  const fontMap = /* @__PURE__ */ new WeakMap();\n  const originalFontFace = win.FontFace;\n  win.FontFace = function FontFace2(family, source, descriptors) {\n    const fontFace = new originalFontFace(family, source, descriptors);\n    fontMap.set(fontFace, {\n      family,\n      buffer: typeof source !== \"string\",\n      descriptors,\n      fontSource: typeof source === \"string\" ? source : JSON.stringify(Array.from(new Uint8Array(source)))\n    });\n    return fontFace;\n  };\n  const restoreHandler = patch(\n    doc.fonts,\n    \"add\",\n    function(original) {\n      return function(fontFace) {\n        setTimeout$1(\n          callbackWrapper(() => {\n            const p = fontMap.get(fontFace);\n            if (p) {\n              fontCb(p);\n              fontMap.delete(fontFace);\n            }\n          }),\n          0\n        );\n        return original.apply(this, [fontFace]);\n      };\n    }\n  );\n  handlers.push(() => {\n    win.FontFace = originalFontFace;\n  });\n  handlers.push(restoreHandler);\n  return callbackWrapper(() => {\n    handlers.forEach((h) => h());\n  });\n}\nfunction initSelectionObserver(param) {\n  const {\n    doc,\n    mirror: mirror2,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    selectionCb\n  } = param;\n  let collapsed = true;\n  const updateSelection = callbackWrapper(() => {\n    const selection = doc.getSelection();\n    if (!selection || collapsed && selection?.isCollapsed) return;\n    collapsed = selection.isCollapsed || false;\n    const ranges = [];\n    const count = selection.rangeCount || 0;\n    for (let i2 = 0; i2 < count; i2++) {\n      const range = selection.getRangeAt(i2);\n      const { startContainer, startOffset, endContainer, endOffset } = range;\n      const blocked = isBlocked(\n        startContainer,\n        blockClass,\n        blockSelector,\n        unblockSelector,\n        true\n      ) || isBlocked(\n        endContainer,\n        blockClass,\n        blockSelector,\n        unblockSelector,\n        true\n      );\n      if (blocked) continue;\n      ranges.push({\n        start: mirror2.getId(startContainer),\n        startOffset,\n        end: mirror2.getId(endContainer),\n        endOffset\n      });\n    }\n    selectionCb({ ranges });\n  });\n  updateSelection();\n  return on(\"selectionchange\", updateSelection);\n}\nfunction initCustomElementObserver({\n  doc,\n  customElementCb\n}) {\n  const win = doc.defaultView;\n  if (!win || !win.customElements) return () => {\n  };\n  const restoreHandler = patch(\n    win.customElements,\n    \"define\",\n    function(original) {\n      return function(name, constructor, options) {\n        try {\n          customElementCb({\n            define: {\n              name\n            }\n          });\n        } catch (e2) {\n        }\n        return original.apply(this, [name, constructor, options]);\n      };\n    }\n  );\n  return restoreHandler;\n}\nfunction initObservers(o2, _hooks = {}) {\n  const currentWindow = o2.doc.defaultView;\n  if (!currentWindow) {\n    return () => {\n    };\n  }\n  let mutationObserver;\n  if (o2.recordDOM) {\n    mutationObserver = initMutationObserver(o2, o2.doc);\n  }\n  const mousemoveHandler = initMoveObserver(o2);\n  const mouseInteractionHandler = initMouseInteractionObserver(o2);\n  const scrollHandler = initScrollObserver(o2);\n  const viewportResizeHandler = initViewportResizeObserver(o2, {\n    win: currentWindow\n  });\n  const inputHandler = initInputObserver(o2);\n  const mediaInteractionHandler = initMediaInteractionObserver(o2);\n  let styleSheetObserver = () => {\n  };\n  let adoptedStyleSheetObserver = () => {\n  };\n  let styleDeclarationObserver = () => {\n  };\n  let fontObserver = () => {\n  };\n  if (o2.recordDOM) {\n    styleSheetObserver = initStyleSheetObserver(o2, { win: currentWindow });\n    adoptedStyleSheetObserver = initAdoptedStyleSheetObserver(o2, o2.doc);\n    styleDeclarationObserver = initStyleDeclarationObserver(o2, {\n      win: currentWindow\n    });\n    if (o2.collectFonts) {\n      fontObserver = initFontObserver(o2);\n    }\n  }\n  const selectionObserver = initSelectionObserver(o2);\n  const customElementObserver = initCustomElementObserver(o2);\n  const pluginHandlers = [];\n  for (const plugin of o2.plugins) {\n    pluginHandlers.push(\n      plugin.observer(plugin.callback, currentWindow, plugin.options)\n    );\n  }\n  return callbackWrapper(() => {\n    mutationBuffers.forEach((b) => b.reset());\n    mutationObserver?.disconnect();\n    mousemoveHandler();\n    mouseInteractionHandler();\n    scrollHandler();\n    viewportResizeHandler();\n    inputHandler();\n    mediaInteractionHandler();\n    styleSheetObserver();\n    adoptedStyleSheetObserver();\n    styleDeclarationObserver();\n    fontObserver();\n    selectionObserver();\n    customElementObserver();\n    pluginHandlers.forEach((h) => h());\n  });\n}\nfunction hasNestedCSSRule(prop) {\n  return typeof window[prop] !== \"undefined\";\n}\nfunction canMonkeyPatchNestedCSSRule(prop) {\n  return Boolean(\n    typeof window[prop] !== \"undefined\" && // Note: Generally, this check _shouldn't_ be necessary\n    // However, in some scenarios (e.g. jsdom) this can sometimes fail, so we check for it here\n    window[prop].prototype && \"insertRule\" in window[prop].prototype && \"deleteRule\" in window[prop].prototype\n  );\n}\nclass CrossOriginIframeMirror {\n  constructor(generateIdFn) {\n    this.generateIdFn = generateIdFn;\n    this.iframeIdToRemoteIdMap = /* @__PURE__ */ new WeakMap();\n    this.iframeRemoteIdToIdMap = /* @__PURE__ */ new WeakMap();\n  }\n  getId(iframe, remoteId, idToRemoteMap, remoteToIdMap) {\n    const idToRemoteIdMap = idToRemoteMap || this.getIdToRemoteIdMap(iframe);\n    const remoteIdToIdMap = remoteToIdMap || this.getRemoteIdToIdMap(iframe);\n    let id = idToRemoteIdMap.get(remoteId);\n    if (!id) {\n      id = this.generateIdFn();\n      idToRemoteIdMap.set(remoteId, id);\n      remoteIdToIdMap.set(id, remoteId);\n    }\n    return id;\n  }\n  getIds(iframe, remoteId) {\n    const idToRemoteIdMap = this.getIdToRemoteIdMap(iframe);\n    const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\n    return remoteId.map(\n      (id) => this.getId(iframe, id, idToRemoteIdMap, remoteIdToIdMap)\n    );\n  }\n  getRemoteId(iframe, id, map) {\n    const remoteIdToIdMap = map || this.getRemoteIdToIdMap(iframe);\n    if (typeof id !== \"number\") return id;\n    const remoteId = remoteIdToIdMap.get(id);\n    if (!remoteId) return -1;\n    return remoteId;\n  }\n  getRemoteIds(iframe, ids) {\n    const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\n    return ids.map((id) => this.getRemoteId(iframe, id, remoteIdToIdMap));\n  }\n  reset(iframe) {\n    if (!iframe) {\n      this.iframeIdToRemoteIdMap = /* @__PURE__ */ new WeakMap();\n      this.iframeRemoteIdToIdMap = /* @__PURE__ */ new WeakMap();\n      return;\n    }\n    this.iframeIdToRemoteIdMap.delete(iframe);\n    this.iframeRemoteIdToIdMap.delete(iframe);\n  }\n  getIdToRemoteIdMap(iframe) {\n    let idToRemoteIdMap = this.iframeIdToRemoteIdMap.get(iframe);\n    if (!idToRemoteIdMap) {\n      idToRemoteIdMap = /* @__PURE__ */ new Map();\n      this.iframeIdToRemoteIdMap.set(iframe, idToRemoteIdMap);\n    }\n    return idToRemoteIdMap;\n  }\n  getRemoteIdToIdMap(iframe) {\n    let remoteIdToIdMap = this.iframeRemoteIdToIdMap.get(iframe);\n    if (!remoteIdToIdMap) {\n      remoteIdToIdMap = /* @__PURE__ */ new Map();\n      this.iframeRemoteIdToIdMap.set(iframe, remoteIdToIdMap);\n    }\n    return remoteIdToIdMap;\n  }\n}\nclass IframeManagerNoop {\n  constructor() {\n    this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId);\n    this.crossOriginIframeRootIdMap = /* @__PURE__ */ new WeakMap();\n  }\n  addIframe() {\n  }\n  addLoadListener() {\n  }\n  attachIframe() {\n  }\n}\nclass IframeManager {\n  constructor(options) {\n    this.iframes = /* @__PURE__ */ new WeakMap();\n    this.crossOriginIframeMap = /* @__PURE__ */ new WeakMap();\n    this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId);\n    this.crossOriginIframeRootIdMap = /* @__PURE__ */ new WeakMap();\n    this.mutationCb = options.mutationCb;\n    this.wrappedEmit = options.wrappedEmit;\n    this.stylesheetManager = options.stylesheetManager;\n    this.recordCrossOriginIframes = options.recordCrossOriginIframes;\n    this.crossOriginIframeStyleMirror = new CrossOriginIframeMirror(\n      this.stylesheetManager.styleMirror.generateId.bind(\n        this.stylesheetManager.styleMirror\n      )\n    );\n    this.mirror = options.mirror;\n    if (this.recordCrossOriginIframes) {\n      window.addEventListener(\"message\", this.handleMessage.bind(this));\n    }\n  }\n  addIframe(iframeEl) {\n    this.iframes.set(iframeEl, true);\n    if (iframeEl.contentWindow)\n      this.crossOriginIframeMap.set(iframeEl.contentWindow, iframeEl);\n  }\n  addLoadListener(cb) {\n    this.loadListener = cb;\n  }\n  attachIframe(iframeEl, childSn) {\n    this.mutationCb({\n      adds: [\n        {\n          parentId: this.mirror.getId(iframeEl),\n          nextId: null,\n          node: childSn\n        }\n      ],\n      removes: [],\n      texts: [],\n      attributes: [],\n      isAttachIframe: true\n    });\n    if (this.recordCrossOriginIframes)\n      iframeEl.contentWindow?.addEventListener(\n        \"message\",\n        this.handleMessage.bind(this)\n      );\n    this.loadListener?.(iframeEl);\n    const iframeDoc = getIFrameContentDocument(iframeEl);\n    if (iframeDoc && iframeDoc.adoptedStyleSheets && iframeDoc.adoptedStyleSheets.length > 0)\n      this.stylesheetManager.adoptStyleSheets(\n        iframeDoc.adoptedStyleSheets,\n        this.mirror.getId(iframeDoc)\n      );\n  }\n  handleMessage(message) {\n    const crossOriginMessageEvent = message;\n    if (crossOriginMessageEvent.data.type !== \"rrweb\" || // To filter out the rrweb messages which are forwarded by some sites.\n    crossOriginMessageEvent.origin !== crossOriginMessageEvent.data.origin)\n      return;\n    const iframeSourceWindow = message.source;\n    if (!iframeSourceWindow) return;\n    const iframeEl = this.crossOriginIframeMap.get(message.source);\n    if (!iframeEl) return;\n    const transformedEvent = this.transformCrossOriginEvent(\n      iframeEl,\n      crossOriginMessageEvent.data.event\n    );\n    if (transformedEvent)\n      this.wrappedEmit(\n        transformedEvent,\n        crossOriginMessageEvent.data.isCheckout\n      );\n  }\n  transformCrossOriginEvent(iframeEl, e2) {\n    switch (e2.type) {\n      case EventType.FullSnapshot: {\n        this.crossOriginIframeMirror.reset(iframeEl);\n        this.crossOriginIframeStyleMirror.reset(iframeEl);\n        this.replaceIdOnNode(e2.data.node, iframeEl);\n        const rootId = e2.data.node.id;\n        this.crossOriginIframeRootIdMap.set(iframeEl, rootId);\n        this.patchRootIdOnNode(e2.data.node, rootId);\n        return {\n          timestamp: e2.timestamp,\n          type: EventType.IncrementalSnapshot,\n          data: {\n            source: IncrementalSource.Mutation,\n            adds: [\n              {\n                parentId: this.mirror.getId(iframeEl),\n                nextId: null,\n                node: e2.data.node\n              }\n            ],\n            removes: [],\n            texts: [],\n            attributes: [],\n            isAttachIframe: true\n          }\n        };\n      }\n      case EventType.Meta:\n      case EventType.Load:\n      case EventType.DomContentLoaded: {\n        return false;\n      }\n      case EventType.Plugin: {\n        return e2;\n      }\n      case EventType.Custom: {\n        this.replaceIds(\n          e2.data.payload,\n          iframeEl,\n          [\"id\", \"parentId\", \"previousId\", \"nextId\"]\n        );\n        return e2;\n      }\n      case EventType.IncrementalSnapshot: {\n        switch (e2.data.source) {\n          case IncrementalSource.Mutation: {\n            e2.data.adds.forEach((n2) => {\n              this.replaceIds(n2, iframeEl, [\n                \"parentId\",\n                \"nextId\",\n                \"previousId\"\n              ]);\n              this.replaceIdOnNode(n2.node, iframeEl);\n              const rootId = this.crossOriginIframeRootIdMap.get(iframeEl);\n              rootId && this.patchRootIdOnNode(n2.node, rootId);\n            });\n            e2.data.removes.forEach((n2) => {\n              this.replaceIds(n2, iframeEl, [\"parentId\", \"id\"]);\n            });\n            e2.data.attributes.forEach((n2) => {\n              this.replaceIds(n2, iframeEl, [\"id\"]);\n            });\n            e2.data.texts.forEach((n2) => {\n              this.replaceIds(n2, iframeEl, [\"id\"]);\n            });\n            return e2;\n          }\n          case IncrementalSource.Drag:\n          case IncrementalSource.TouchMove:\n          case IncrementalSource.MouseMove: {\n            e2.data.positions.forEach((p) => {\n              this.replaceIds(p, iframeEl, [\"id\"]);\n            });\n            return e2;\n          }\n          case IncrementalSource.ViewportResize: {\n            return false;\n          }\n          case IncrementalSource.MediaInteraction:\n          case IncrementalSource.MouseInteraction:\n          case IncrementalSource.Scroll:\n          case IncrementalSource.CanvasMutation:\n          case IncrementalSource.Input: {\n            this.replaceIds(e2.data, iframeEl, [\"id\"]);\n            return e2;\n          }\n          case IncrementalSource.StyleSheetRule:\n          case IncrementalSource.StyleDeclaration: {\n            this.replaceIds(e2.data, iframeEl, [\"id\"]);\n            this.replaceStyleIds(e2.data, iframeEl, [\"styleId\"]);\n            return e2;\n          }\n          case IncrementalSource.Font: {\n            return e2;\n          }\n          case IncrementalSource.Selection: {\n            e2.data.ranges.forEach((range) => {\n              this.replaceIds(range, iframeEl, [\"start\", \"end\"]);\n            });\n            return e2;\n          }\n          case IncrementalSource.AdoptedStyleSheet: {\n            this.replaceIds(e2.data, iframeEl, [\"id\"]);\n            this.replaceStyleIds(e2.data, iframeEl, [\"styleIds\"]);\n            e2.data.styles?.forEach((style) => {\n              this.replaceStyleIds(style, iframeEl, [\"styleId\"]);\n            });\n            return e2;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  replace(iframeMirror, obj, iframeEl, keys) {\n    for (const key of keys) {\n      if (!Array.isArray(obj[key]) && typeof obj[key] !== \"number\") continue;\n      if (Array.isArray(obj[key])) {\n        obj[key] = iframeMirror.getIds(\n          iframeEl,\n          obj[key]\n        );\n      } else {\n        obj[key] = iframeMirror.getId(iframeEl, obj[key]);\n      }\n    }\n    return obj;\n  }\n  replaceIds(obj, iframeEl, keys) {\n    return this.replace(this.crossOriginIframeMirror, obj, iframeEl, keys);\n  }\n  replaceStyleIds(obj, iframeEl, keys) {\n    return this.replace(this.crossOriginIframeStyleMirror, obj, iframeEl, keys);\n  }\n  replaceIdOnNode(node, iframeEl) {\n    this.replaceIds(node, iframeEl, [\"id\", \"rootId\"]);\n    if (\"childNodes\" in node) {\n      node.childNodes.forEach((child) => {\n        this.replaceIdOnNode(child, iframeEl);\n      });\n    }\n  }\n  patchRootIdOnNode(node, rootId) {\n    if (node.type !== NodeType$2.Document && !node.rootId) node.rootId = rootId;\n    if (\"childNodes\" in node) {\n      node.childNodes.forEach((child) => {\n        this.patchRootIdOnNode(child, rootId);\n      });\n    }\n  }\n}\nclass ShadowDomManagerNoop {\n  init() {\n  }\n  addShadowRoot() {\n  }\n  observeAttachShadow() {\n  }\n  reset() {\n  }\n}\nclass ShadowDomManager {\n  constructor(options) {\n    this.shadowDoms = /* @__PURE__ */ new WeakSet();\n    this.restoreHandlers = [];\n    this.mutationCb = options.mutationCb;\n    this.scrollCb = options.scrollCb;\n    this.bypassOptions = options.bypassOptions;\n    this.mirror = options.mirror;\n    this.init();\n  }\n  init() {\n    this.reset();\n    this.patchAttachShadow(Element, document);\n  }\n  addShadowRoot(shadowRoot, doc) {\n    if (!isNativeShadowDom(shadowRoot)) return;\n    if (this.shadowDoms.has(shadowRoot)) return;\n    this.shadowDoms.add(shadowRoot);\n    this.bypassOptions.canvasManager.addShadowRoot(shadowRoot);\n    const observer = initMutationObserver(\n      {\n        ...this.bypassOptions,\n        doc,\n        mutationCb: this.mutationCb,\n        mirror: this.mirror,\n        shadowDomManager: this\n      },\n      shadowRoot\n    );\n    this.restoreHandlers.push(() => observer.disconnect());\n    this.restoreHandlers.push(\n      initScrollObserver({\n        ...this.bypassOptions,\n        scrollCb: this.scrollCb,\n        // https://gist.github.com/praveenpuglia/0832da687ed5a5d7a0907046c9ef1813\n        // scroll is not allowed to pass the boundary, so we need to listen the shadow document\n        doc: shadowRoot,\n        mirror: this.mirror\n      })\n    );\n    setTimeout$1(() => {\n      if (shadowRoot.adoptedStyleSheets && shadowRoot.adoptedStyleSheets.length > 0)\n        this.bypassOptions.stylesheetManager.adoptStyleSheets(\n          shadowRoot.adoptedStyleSheets,\n          this.mirror.getId(shadowRoot.host)\n        );\n      this.restoreHandlers.push(\n        initAdoptedStyleSheetObserver(\n          {\n            mirror: this.mirror,\n            stylesheetManager: this.bypassOptions.stylesheetManager\n          },\n          shadowRoot\n        )\n      );\n    }, 0);\n  }\n  /**\n   * Monkey patch 'attachShadow' of an IFrameElement to observe newly added shadow doms.\n   */\n  observeAttachShadow(iframeElement) {\n    const iframeDoc = getIFrameContentDocument(iframeElement);\n    const iframeWindow = getIFrameContentWindow(iframeElement);\n    if (!iframeDoc || !iframeWindow) return;\n    this.patchAttachShadow(\n      iframeWindow.Element,\n      iframeDoc\n    );\n  }\n  /**\n   * Patch 'attachShadow' to observe newly added shadow doms.\n   */\n  patchAttachShadow(element, doc) {\n    const manager = this;\n    this.restoreHandlers.push(\n      patch(\n        element.prototype,\n        \"attachShadow\",\n        function(original) {\n          return function(option) {\n            const shadowRoot = original.call(this, option);\n            if (this.shadowRoot && inDom(this))\n              manager.addShadowRoot(this.shadowRoot, doc);\n            return shadowRoot;\n          };\n        }\n      )\n    );\n  }\n  reset() {\n    this.restoreHandlers.forEach((handler) => {\n      try {\n        handler();\n      } catch (e2) {\n      }\n    });\n    this.restoreHandlers = [];\n    this.shadowDoms = /* @__PURE__ */ new WeakSet();\n    this.bypassOptions.canvasManager.resetShadowRoots();\n  }\n}\nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar lookup = typeof Uint8Array === \"undefined\" ? [] : new Uint8Array(256);\nfor (var i$1 = 0; i$1 < chars.length; i$1++) {\n  lookup[chars.charCodeAt(i$1)] = i$1;\n}\nvar encode = function(arraybuffer) {\n  var bytes = new Uint8Array(arraybuffer), i2, len = bytes.length, base64 = \"\";\n  for (i2 = 0; i2 < len; i2 += 3) {\n    base64 += chars[bytes[i2] >> 2];\n    base64 += chars[(bytes[i2] & 3) << 4 | bytes[i2 + 1] >> 4];\n    base64 += chars[(bytes[i2 + 1] & 15) << 2 | bytes[i2 + 2] >> 6];\n    base64 += chars[bytes[i2 + 2] & 63];\n  }\n  if (len % 3 === 2) {\n    base64 = base64.substring(0, base64.length - 1) + \"=\";\n  } else if (len % 3 === 1) {\n    base64 = base64.substring(0, base64.length - 2) + \"==\";\n  }\n  return base64;\n};\nvar decode = function(base64) {\n  var bufferLength = base64.length * 0.75, len = base64.length, i2, p = 0, encoded1, encoded2, encoded3, encoded4;\n  if (base64[base64.length - 1] === \"=\") {\n    bufferLength--;\n    if (base64[base64.length - 2] === \"=\") {\n      bufferLength--;\n    }\n  }\n  var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n  for (i2 = 0; i2 < len; i2 += 4) {\n    encoded1 = lookup[base64.charCodeAt(i2)];\n    encoded2 = lookup[base64.charCodeAt(i2 + 1)];\n    encoded3 = lookup[base64.charCodeAt(i2 + 2)];\n    encoded4 = lookup[base64.charCodeAt(i2 + 3)];\n    bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n  }\n  return arraybuffer;\n};\nconst canvasVarMap = /* @__PURE__ */ new Map();\nfunction variableListFor$1(ctx, ctor) {\n  let contextMap = canvasVarMap.get(ctx);\n  if (!contextMap) {\n    contextMap = /* @__PURE__ */ new Map();\n    canvasVarMap.set(ctx, contextMap);\n  }\n  if (!contextMap.has(ctor)) {\n    contextMap.set(ctor, []);\n  }\n  return contextMap.get(ctor);\n}\nconst saveWebGLVar = (value, win, ctx) => {\n  if (!value || !(isInstanceOfWebGLObject(value, win) || typeof value === \"object\"))\n    return;\n  const name = value.constructor.name;\n  const list = variableListFor$1(ctx, name);\n  let index = list.indexOf(value);\n  if (index === -1) {\n    index = list.length;\n    list.push(value);\n  }\n  return index;\n};\nfunction serializeArg(value, win, ctx) {\n  if (value instanceof Array) {\n    return value.map((arg) => serializeArg(arg, win, ctx));\n  } else if (value === null) {\n    return value;\n  } else if (value instanceof Float32Array || value instanceof Float64Array || value instanceof Int32Array || value instanceof Uint32Array || value instanceof Uint8Array || value instanceof Uint16Array || value instanceof Int16Array || value instanceof Int8Array || value instanceof Uint8ClampedArray) {\n    const name = value.constructor.name;\n    return {\n      rr_type: name,\n      args: [Object.values(value)]\n    };\n  } else if (\n    // SharedArrayBuffer disabled on most browsers due to spectre.\n    // More info: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer/SharedArrayBuffer\n    // value instanceof SharedArrayBuffer ||\n    value instanceof ArrayBuffer\n  ) {\n    const name = value.constructor.name;\n    const base64 = encode(value);\n    return {\n      rr_type: name,\n      base64\n    };\n  } else if (value instanceof DataView) {\n    const name = value.constructor.name;\n    return {\n      rr_type: name,\n      args: [\n        serializeArg(value.buffer, win, ctx),\n        value.byteOffset,\n        value.byteLength\n      ]\n    };\n  } else if (value instanceof HTMLImageElement) {\n    const name = value.constructor.name;\n    const { src } = value;\n    return {\n      rr_type: name,\n      src\n    };\n  } else if (value instanceof HTMLCanvasElement) {\n    const name = \"HTMLImageElement\";\n    const src = value.toDataURL();\n    return {\n      rr_type: name,\n      src\n    };\n  } else if (value instanceof ImageData) {\n    const name = value.constructor.name;\n    return {\n      rr_type: name,\n      args: [serializeArg(value.data, win, ctx), value.width, value.height]\n    };\n  } else if (isInstanceOfWebGLObject(value, win) || typeof value === \"object\") {\n    const name = value.constructor.name;\n    const index = saveWebGLVar(value, win, ctx);\n    return {\n      rr_type: name,\n      index\n    };\n  }\n  return value;\n}\nconst serializeArgs = (args, win, ctx) => {\n  return args.map((arg) => serializeArg(arg, win, ctx));\n};\nconst isInstanceOfWebGLObject = (value, win) => {\n  const webGLConstructorNames = [\n    \"WebGLActiveInfo\",\n    \"WebGLBuffer\",\n    \"WebGLFramebuffer\",\n    \"WebGLProgram\",\n    \"WebGLRenderbuffer\",\n    \"WebGLShader\",\n    \"WebGLShaderPrecisionFormat\",\n    \"WebGLTexture\",\n    \"WebGLUniformLocation\",\n    \"WebGLVertexArrayObject\",\n    // In old Chrome versions, value won't be an instanceof WebGLVertexArrayObject.\n    \"WebGLVertexArrayObjectOES\"\n  ];\n  const supportedWebGLConstructorNames = webGLConstructorNames.filter(\n    (name) => typeof win[name] === \"function\"\n  );\n  return Boolean(\n    supportedWebGLConstructorNames.find(\n      (name) => value instanceof win[name]\n    )\n  );\n};\nfunction initCanvas2DMutationObserver(cb, win, blockClass2, blockSelector, unblockSelector) {\n  const handlers = [];\n  const props2D = Object.getOwnPropertyNames(\n    win.CanvasRenderingContext2D.prototype\n  );\n  for (const prop of props2D) {\n    try {\n      if (typeof win.CanvasRenderingContext2D.prototype[prop] !== \"function\") {\n        continue;\n      }\n      const restoreHandler = patch(\n        win.CanvasRenderingContext2D.prototype,\n        prop,\n        function(original) {\n          return function(...args) {\n            if (!isBlocked(\n              this.canvas,\n              blockClass2,\n              blockSelector,\n              unblockSelector,\n              true\n            )) {\n              setTimeout$1(() => {\n                const recordArgs = serializeArgs(args, win, this);\n                cb(this.canvas, {\n                  type: CanvasContext[\"2D\"],\n                  property: prop,\n                  args: recordArgs\n                });\n              }, 0);\n            }\n            return original.apply(this, args);\n          };\n        }\n      );\n      handlers.push(restoreHandler);\n    } catch {\n      const hookHandler = hookSetter(\n        win.CanvasRenderingContext2D.prototype,\n        prop,\n        {\n          set(v2) {\n            cb(this.canvas, {\n              type: CanvasContext[\"2D\"],\n              property: prop,\n              args: [v2],\n              setter: true\n            });\n          }\n        }\n      );\n      handlers.push(hookHandler);\n    }\n  }\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\nfunction getNormalizedContextName(contextType) {\n  return contextType === \"experimental-webgl\" ? \"webgl\" : contextType;\n}\nfunction initCanvasContextObserver(win, blockClass, blockSelector, unblockSelector, setPreserveDrawingBufferToTrue) {\n  const handlers = [];\n  try {\n    const restoreHandler = patch(\n      win.HTMLCanvasElement.prototype,\n      \"getContext\",\n      function(original) {\n        return function(contextType, ...args) {\n          if (!isBlocked(this, blockClass, blockSelector, unblockSelector, true)) {\n            const ctxName = getNormalizedContextName(contextType);\n            if (!(\"__context\" in this)) this.__context = ctxName;\n            if (setPreserveDrawingBufferToTrue && [\"webgl\", \"webgl2\"].includes(ctxName)) {\n              if (args[0] && typeof args[0] === \"object\") {\n                const contextAttributes = args[0];\n                if (!contextAttributes.preserveDrawingBuffer) {\n                  contextAttributes.preserveDrawingBuffer = true;\n                }\n              } else {\n                args.splice(0, 1, {\n                  preserveDrawingBuffer: true\n                });\n              }\n            }\n          }\n          return original.apply(this, [contextType, ...args]);\n        };\n      }\n    );\n    handlers.push(restoreHandler);\n  } catch {\n    console.error(\"failed to patch HTMLCanvasElement.prototype.getContext\");\n  }\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\nfunction patchGLPrototype(prototype, type, cb, blockClass2, blockSelector, unblockSelector, _mirror2, win) {\n  const handlers = [];\n  const props = Object.getOwnPropertyNames(prototype);\n  for (const prop of props) {\n    if (\n      //prop.startsWith('get') ||  // e.g. getProgramParameter, but too risky\n      [\n        \"isContextLost\",\n        \"canvas\",\n        \"drawingBufferWidth\",\n        \"drawingBufferHeight\"\n      ].includes(prop)\n    ) {\n      continue;\n    }\n    try {\n      if (typeof prototype[prop] !== \"function\") {\n        continue;\n      }\n      const restoreHandler = patch(\n        prototype,\n        prop,\n        function(original) {\n          return function(...args) {\n            const result = original.apply(this, args);\n            saveWebGLVar(result, win, this);\n            if (\"tagName\" in this.canvas && !isBlocked(\n              this.canvas,\n              blockClass2,\n              blockSelector,\n              unblockSelector,\n              true\n            )) {\n              const recordArgs = serializeArgs(args, win, this);\n              const mutation = {\n                type,\n                property: prop,\n                args: recordArgs\n              };\n              cb(this.canvas, mutation);\n            }\n            return result;\n          };\n        }\n      );\n      handlers.push(restoreHandler);\n    } catch {\n      const hookHandler = hookSetter(prototype, prop, {\n        set(v2) {\n          cb(this.canvas, {\n            type,\n            property: prop,\n            args: [v2],\n            setter: true\n          });\n        }\n      });\n      handlers.push(hookHandler);\n    }\n  }\n  return handlers;\n}\nfunction initCanvasWebGLMutationObserver(cb, win, blockClass2, blockSelector, unblockSelector, mirror2) {\n  const handlers = [];\n  handlers.push(\n    ...patchGLPrototype(\n      win.WebGLRenderingContext.prototype,\n      CanvasContext.WebGL,\n      cb,\n      blockClass2,\n      blockSelector,\n      unblockSelector,\n      mirror2,\n      win\n    )\n  );\n  if (typeof win.WebGL2RenderingContext !== \"undefined\") {\n    handlers.push(\n      ...patchGLPrototype(\n        win.WebGL2RenderingContext.prototype,\n        CanvasContext.WebGL2,\n        cb,\n        blockClass2,\n        blockSelector,\n        unblockSelector,\n        mirror2,\n        win\n      )\n    );\n  }\n  return () => {\n    handlers.forEach((h) => h());\n  };\n}\nconst r$1 = `for(var e=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",t=\"undefined\"==typeof Uint8Array?[]:new Uint8Array(256),a=0;a<64;a++)t[e.charCodeAt(a)]=a;var n=function(t){var a,n=new Uint8Array(t),r=n.length,s=\"\";for(a=0;a<r;a+=3)s+=e[n[a]>>2],s+=e[(3&n[a])<<4|n[a+1]>>4],s+=e[(15&n[a+1])<<2|n[a+2]>>6],s+=e[63&n[a+2]];return r%3==2?s=s.substring(0,s.length-1)+\"=\":r%3==1&&(s=s.substring(0,s.length-2)+\"==\"),s};const r=new Map,s=new Map;const i=self;i.onmessage=async function(e){if(!(\"OffscreenCanvas\"in globalThis))return i.postMessage({id:e.data.id});{const{id:t,bitmap:a,width:o,height:f,maxCanvasSize:c,dataURLOptions:g}=e.data,u=async function(e,t,a){const r=e+\"-\"+t;if(\"OffscreenCanvas\"in globalThis){if(s.has(r))return s.get(r);const i=new OffscreenCanvas(e,t);i.getContext(\"2d\");const o=await i.convertToBlob(a),f=await o.arrayBuffer(),c=n(f);return s.set(r,c),c}return\"\"}(o,f,g),[h,d]=function(e,t,a){if(!a)return[e,t];const[n,r]=a;if(e<=n&&t<=r)return[e,t];let s=e,i=t;return s>n&&(i=Math.floor(n*t/e),s=n),i>r&&(s=Math.floor(r*e/t),i=r),[s,i]}(o,f,c),l=new OffscreenCanvas(h,d),w=l.getContext(\"bitmaprenderer\"),p=h===o&&d===f?a:await createImageBitmap(a,{resizeWidth:h,resizeHeight:d,resizeQuality:\"low\"});w?.transferFromImageBitmap(p),a.close();const y=await l.convertToBlob(g),v=y.type,b=await y.arrayBuffer(),m=n(b);if(p.close(),!r.has(t)&&await u===m)return r.set(t,m),i.postMessage({id:t});if(r.get(t)===m)return i.postMessage({id:t});i.postMessage({id:t,type:v,base64:m,width:o,height:f}),r.set(t,m)}};`;\nfunction t$1() {\n  const t2 = new Blob([r$1]);\n  return URL.createObjectURL(t2);\n}\nclass CanvasManagerNoop {\n  reset() {\n  }\n  freeze() {\n  }\n  unfreeze() {\n  }\n  lock() {\n  }\n  unlock() {\n  }\n  snapshot() {\n  }\n  addWindow() {\n  }\n  addShadowRoot() {\n  }\n  resetShadowRoots() {\n  }\n}\nclass CanvasManager {\n  constructor(options) {\n    this.pendingCanvasMutations = /* @__PURE__ */ new Map();\n    this.rafStamps = { latestId: 0, invokeId: null };\n    this.shadowDoms = /* @__PURE__ */ new Set();\n    this.windowsSet = /* @__PURE__ */ new WeakSet();\n    this.windows = [];\n    this.restoreHandlers = [];\n    this.frozen = false;\n    this.locked = false;\n    this.snapshotInProgressMap = /* @__PURE__ */ new Map();\n    this.worker = null;\n    this.lastSnapshotTime = 0;\n    this.processMutation = (target, mutation) => {\n      const newFrame = this.rafStamps.invokeId && this.rafStamps.latestId !== this.rafStamps.invokeId;\n      if (newFrame || !this.rafStamps.invokeId)\n        this.rafStamps.invokeId = this.rafStamps.latestId;\n      if (!this.pendingCanvasMutations.has(target)) {\n        this.pendingCanvasMutations.set(target, []);\n      }\n      this.pendingCanvasMutations.get(target).push(mutation);\n    };\n    const {\n      enableManualSnapshot,\n      sampling = \"all\",\n      win,\n      recordCanvas,\n      errorHandler: errorHandler2\n    } = options;\n    options.sampling = sampling;\n    this.mutationCb = options.mutationCb;\n    this.mirror = options.mirror;\n    this.options = options;\n    if (errorHandler2) {\n      registerErrorHandler(errorHandler2);\n    }\n    if (recordCanvas && typeof sampling === \"number\" || enableManualSnapshot) {\n      this.worker = this.initFPSWorker();\n    }\n    this.addWindow(win);\n    if (enableManualSnapshot) {\n      return;\n    }\n    callbackWrapper(() => {\n      if (recordCanvas && sampling === \"all\") {\n        this.startRAFTimestamping();\n        this.startPendingCanvasMutationFlusher();\n      }\n      if (recordCanvas && typeof sampling === \"number\") {\n        this.initCanvasFPSObserver();\n      }\n    })();\n  }\n  reset() {\n    this.pendingCanvasMutations.clear();\n    this.restoreHandlers.forEach((handler) => {\n      try {\n        handler();\n      } catch (e2) {\n      }\n    });\n    this.restoreHandlers = [];\n    this.windowsSet = /* @__PURE__ */ new WeakSet();\n    this.windows = [];\n    this.shadowDoms = /* @__PURE__ */ new Set();\n    this.worker?.terminate();\n    this.worker = null;\n    this.snapshotInProgressMap = /* @__PURE__ */ new Map();\n  }\n  freeze() {\n    this.frozen = true;\n  }\n  unfreeze() {\n    this.frozen = false;\n  }\n  lock() {\n    this.locked = true;\n  }\n  unlock() {\n    this.locked = false;\n  }\n  addWindow(win) {\n    const {\n      sampling = \"all\",\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      recordCanvas,\n      enableManualSnapshot\n    } = this.options;\n    if (this.windowsSet.has(win)) return;\n    if (enableManualSnapshot) {\n      this.windowsSet.add(win);\n      this.windows.push(new WeakRef(win));\n      return;\n    }\n    callbackWrapper(() => {\n      if (recordCanvas && sampling === \"all\") {\n        this.initCanvasMutationObserver(\n          win,\n          blockClass,\n          blockSelector,\n          unblockSelector\n        );\n      }\n      if (recordCanvas && typeof sampling === \"number\") {\n        const canvasContextReset = initCanvasContextObserver(\n          win,\n          blockClass,\n          blockSelector,\n          unblockSelector,\n          true\n        );\n        this.restoreHandlers.push(() => {\n          canvasContextReset();\n        });\n      }\n    })();\n    this.windowsSet.add(win);\n    this.windows.push(new WeakRef(win));\n  }\n  addShadowRoot(shadowRoot) {\n    this.shadowDoms.add(new WeakRef(shadowRoot));\n  }\n  resetShadowRoots() {\n    this.shadowDoms = /* @__PURE__ */ new Set();\n  }\n  snapshot(canvasElement, options) {\n    if (options?.skipRequestAnimationFrame) {\n      this.takeSnapshot(performance.now(), true, canvasElement);\n      return;\n    }\n    onRequestAnimationFrame(\n      (timestamp) => this.takeSnapshot(timestamp, true, canvasElement)\n    );\n  }\n  initFPSWorker() {\n    const worker = new Worker(t$1());\n    worker.onmessage = (e2) => {\n      const data = e2.data;\n      const { id } = data;\n      this.snapshotInProgressMap.set(id, false);\n      if (!(\"base64\" in data)) return;\n      const { base64, type, width, height } = data;\n      this.mutationCb({\n        id,\n        type: CanvasContext[\"2D\"],\n        commands: [\n          {\n            property: \"clearRect\",\n            // wipe canvas\n            args: [0, 0, width, height]\n          },\n          {\n            property: \"drawImage\",\n            // draws (semi-transparent) image\n            args: [\n              {\n                rr_type: \"ImageBitmap\",\n                args: [\n                  {\n                    rr_type: \"Blob\",\n                    data: [{ rr_type: \"ArrayBuffer\", base64 }],\n                    type\n                  }\n                ]\n              },\n              0,\n              0,\n              // The below args are needed if we enforce a max size, we want to\n              // retain the original size when drawing the image (which should be smaller)\n              width,\n              height\n            ]\n          }\n        ]\n      });\n    };\n    return worker;\n  }\n  initCanvasFPSObserver() {\n    let rafId;\n    if (!this.windows.length && !this.shadowDoms.size) {\n      return;\n    }\n    const rafCallback = (timestamp) => {\n      this.takeSnapshot(timestamp, false);\n      rafId = onRequestAnimationFrame(rafCallback);\n    };\n    rafId = onRequestAnimationFrame(rafCallback);\n    this.restoreHandlers.push(() => {\n      if (rafId) {\n        cancelAnimationFrame(rafId);\n      }\n    });\n  }\n  initCanvasMutationObserver(win, blockClass, blockSelector, unblockSelector) {\n    const canvasContextReset = initCanvasContextObserver(\n      win,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      false\n    );\n    const canvas2DReset = initCanvas2DMutationObserver(\n      this.processMutation.bind(this),\n      win,\n      blockClass,\n      blockSelector,\n      unblockSelector\n    );\n    const canvasWebGL1and2Reset = initCanvasWebGLMutationObserver(\n      this.processMutation.bind(this),\n      win,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      this.mirror\n    );\n    this.restoreHandlers.push(() => {\n      canvasContextReset();\n      canvas2DReset();\n      canvasWebGL1and2Reset();\n    });\n  }\n  /**\n   * Returns all `canvas` elements that are not blocked by the given selectors. Searches all windows and shadow roots.\n   */\n  getCanvasElements(blockClass, blockSelector, unblockSelector) {\n    const matchedCanvas = [];\n    const searchCanvas = (root) => {\n      root.querySelectorAll(\"canvas\").forEach((canvas) => {\n        if (!isBlocked(canvas, blockClass, blockSelector, unblockSelector, true)) {\n          matchedCanvas.push(canvas);\n        }\n      });\n    };\n    for (const item of this.windows) {\n      const window2 = item.deref();\n      let _document;\n      try {\n        _document = window2 && window2.document;\n      } catch {\n      }\n      if (_document) {\n        searchCanvas(_document);\n      }\n    }\n    for (const item of this.shadowDoms) {\n      const shadowRoot = item.deref();\n      if (shadowRoot) {\n        searchCanvas(shadowRoot);\n      }\n    }\n    return matchedCanvas;\n  }\n  /**\n   * Takes a snapshot of the provided canvas element, or will search all windows/shadow roots for canvases. Will self-throttle based on `options.sampling`.\n   *\n   * @returns `true` if the snapshot was taken, `false` if it was throttled.\n   */\n  takeSnapshot(timestamp, isManualSnapshot, canvasElement) {\n    const {\n      sampling,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      dataURLOptions,\n      maxCanvasSize\n    } = this.options;\n    const fps = sampling === \"all\" ? 2 : sampling || 2;\n    const timeBetweenSnapshots = 1e3 / fps;\n    const shouldThrottle = this.lastSnapshotTime && timestamp - this.lastSnapshotTime < timeBetweenSnapshots;\n    if (shouldThrottle) {\n      return false;\n    }\n    this.lastSnapshotTime = timestamp;\n    const canvases = canvasElement ? [canvasElement] : this.getCanvasElements(blockClass, blockSelector, unblockSelector);\n    canvases.forEach((canvas) => {\n      const id = this.mirror.getId(canvas);\n      if (!this.mirror.hasNode(canvas) || !canvas.width || !canvas.height || this.snapshotInProgressMap.get(id)) {\n        return;\n      }\n      this.snapshotInProgressMap.set(id, true);\n      if (!isManualSnapshot && [\"webgl\", \"webgl2\"].includes(canvas.__context)) {\n        const context = canvas.getContext(canvas.__context);\n        if (context?.getContextAttributes()?.preserveDrawingBuffer === false) {\n          context.clear(context.COLOR_BUFFER_BIT);\n        }\n      }\n      createImageBitmap(canvas).then((bitmap) => {\n        this.worker?.postMessage(\n          {\n            id,\n            bitmap,\n            width: canvas.width,\n            height: canvas.height,\n            dataURLOptions,\n            maxCanvasSize\n          },\n          [bitmap]\n        );\n      }).catch((error) => {\n        callbackWrapper(() => {\n          this.snapshotInProgressMap.delete(id);\n          throw error;\n        })();\n      });\n    });\n    return true;\n  }\n  startPendingCanvasMutationFlusher() {\n    onRequestAnimationFrame(() => this.flushPendingCanvasMutations());\n  }\n  startRAFTimestamping() {\n    const setLatestRAFTimestamp = (timestamp) => {\n      this.rafStamps.latestId = timestamp;\n      onRequestAnimationFrame(setLatestRAFTimestamp);\n    };\n    onRequestAnimationFrame(setLatestRAFTimestamp);\n  }\n  flushPendingCanvasMutations() {\n    this.pendingCanvasMutations.forEach(\n      (_values, canvas) => {\n        const id = this.mirror.getId(canvas);\n        this.flushPendingCanvasMutationFor(canvas, id);\n      }\n    );\n    onRequestAnimationFrame(() => this.flushPendingCanvasMutations());\n  }\n  flushPendingCanvasMutationFor(canvas, id) {\n    if (this.frozen || this.locked) {\n      return;\n    }\n    const valuesWithType = this.pendingCanvasMutations.get(canvas);\n    if (!valuesWithType || id === -1) return;\n    const values = valuesWithType.map((value) => {\n      const { type: type2, ...rest } = value;\n      return rest;\n    });\n    const { type } = valuesWithType[0];\n    this.mutationCb({ id, type, commands: values });\n    this.pendingCanvasMutations.delete(canvas);\n  }\n}\nclass StylesheetManager {\n  constructor(options) {\n    this.trackedLinkElements = /* @__PURE__ */ new WeakSet();\n    this.styleMirror = new StyleSheetMirror();\n    this.mutationCb = options.mutationCb;\n    this.adoptedStyleSheetCb = options.adoptedStyleSheetCb;\n  }\n  attachLinkElement(linkEl, childSn) {\n    if (\"_cssText\" in childSn.attributes)\n      this.mutationCb({\n        adds: [],\n        removes: [],\n        texts: [],\n        attributes: [\n          {\n            id: childSn.id,\n            attributes: childSn.attributes\n          }\n        ]\n      });\n    this.trackLinkElement(linkEl);\n  }\n  trackLinkElement(linkEl) {\n    if (this.trackedLinkElements.has(linkEl)) return;\n    this.trackedLinkElements.add(linkEl);\n    this.trackStylesheetInLinkElement(linkEl);\n  }\n  adoptStyleSheets(sheets, hostId) {\n    if (sheets.length === 0) return;\n    const adoptedStyleSheetData = {\n      id: hostId,\n      styleIds: []\n    };\n    const styles = [];\n    for (const sheet of sheets) {\n      let styleId;\n      if (!this.styleMirror.has(sheet)) {\n        styleId = this.styleMirror.add(sheet);\n        styles.push({\n          styleId,\n          rules: Array.from(sheet.rules || CSSRule, (r2, index) => ({\n            rule: stringifyRule(r2),\n            index\n          }))\n        });\n      } else styleId = this.styleMirror.getId(sheet);\n      adoptedStyleSheetData.styleIds.push(styleId);\n    }\n    if (styles.length > 0) adoptedStyleSheetData.styles = styles;\n    this.adoptedStyleSheetCb(adoptedStyleSheetData);\n  }\n  reset() {\n    this.styleMirror.reset();\n    this.trackedLinkElements = /* @__PURE__ */ new WeakSet();\n  }\n  // TODO: take snapshot on stylesheet reload by applying event listener\n  trackStylesheetInLinkElement(_linkEl) {\n  }\n}\nclass ProcessedNodeManager {\n  constructor() {\n    this.nodeMap = /* @__PURE__ */ new WeakMap();\n    this.active = false;\n  }\n  inOtherBuffer(node, thisBuffer) {\n    const buffers = this.nodeMap.get(node);\n    return buffers && Array.from(buffers).some((buffer) => buffer !== thisBuffer);\n  }\n  add(node, buffer) {\n    if (!this.active) {\n      this.active = true;\n      onRequestAnimationFrame(() => {\n        this.nodeMap = /* @__PURE__ */ new WeakMap();\n        this.active = false;\n      });\n    }\n    this.nodeMap.set(node, (this.nodeMap.get(node) || /* @__PURE__ */ new Set()).add(buffer));\n  }\n  destroy() {\n  }\n}\nlet wrappedEmit;\nlet _wrappedEmit;\nlet _takeFullSnapshot;\ntry {\n  if (Array.from([1], (x) => x * 2)[0] !== 2) {\n    const cleanFrame = document.createElement(\"iframe\");\n    document.body.appendChild(cleanFrame);\n    Array.from = cleanFrame.contentWindow?.Array.from || Array.from;\n    document.body.removeChild(cleanFrame);\n  }\n} catch (err) {\n  console.debug(\"Unable to override Array.from\", err);\n}\nconst mirror = createMirror$2();\nfunction record(options = {}) {\n  const {\n    emit,\n    checkoutEveryNms,\n    checkoutEveryNth,\n    blockClass = \"rr-block\",\n    blockSelector = null,\n    unblockSelector = null,\n    ignoreClass = \"rr-ignore\",\n    ignoreSelector = null,\n    maskAllText = false,\n    maskTextClass = \"rr-mask\",\n    unmaskTextClass = null,\n    maskTextSelector = null,\n    unmaskTextSelector = null,\n    inlineStylesheet = true,\n    maskAllInputs,\n    maskInputOptions: _maskInputOptions,\n    slimDOMOptions: _slimDOMOptions,\n    maskAttributeFn,\n    maskInputFn,\n    maskTextFn,\n    maxCanvasSize = null,\n    packFn,\n    sampling = {},\n    dataURLOptions = {},\n    mousemoveWait,\n    recordDOM = true,\n    recordCanvas = false,\n    recordCrossOriginIframes = false,\n    recordAfter = options.recordAfter === \"DOMContentLoaded\" ? options.recordAfter : \"load\",\n    userTriggeredOnInput = false,\n    collectFonts = false,\n    inlineImages = false,\n    plugins,\n    keepIframeSrcFn = () => false,\n    ignoreCSSAttributes = /* @__PURE__ */ new Set([]),\n    errorHandler: errorHandler2,\n    onMutation,\n    getCanvasManager\n  } = options;\n  registerErrorHandler(errorHandler2);\n  const inEmittingFrame = recordCrossOriginIframes ? window.parent === window : true;\n  let passEmitsToParent = false;\n  if (!inEmittingFrame) {\n    try {\n      if (window.parent.document) {\n        passEmitsToParent = false;\n      }\n    } catch (e2) {\n      passEmitsToParent = true;\n    }\n  }\n  if (inEmittingFrame && !emit) {\n    throw new Error(\"emit function is required\");\n  }\n  if (!inEmittingFrame && !passEmitsToParent) {\n    return () => {\n    };\n  }\n  if (mousemoveWait !== void 0 && sampling.mousemove === void 0) {\n    sampling.mousemove = mousemoveWait;\n  }\n  mirror.reset();\n  const maskInputOptions = maskAllInputs === true ? {\n    color: true,\n    date: true,\n    \"datetime-local\": true,\n    email: true,\n    month: true,\n    number: true,\n    range: true,\n    search: true,\n    tel: true,\n    text: true,\n    time: true,\n    url: true,\n    week: true,\n    textarea: true,\n    select: true,\n    radio: true,\n    checkbox: true\n  } : _maskInputOptions !== void 0 ? _maskInputOptions : {};\n  const slimDOMOptions = _slimDOMOptions === true || _slimDOMOptions === \"all\" ? {\n    script: true,\n    comment: true,\n    headFavicon: true,\n    headWhitespace: true,\n    headMetaSocial: true,\n    headMetaRobots: true,\n    headMetaHttpEquiv: true,\n    headMetaVerification: true,\n    // the following are off for slimDOMOptions === true,\n    // as they destroy some (hidden) info:\n    headMetaAuthorship: _slimDOMOptions === \"all\",\n    headMetaDescKeywords: _slimDOMOptions === \"all\"\n  } : _slimDOMOptions ? _slimDOMOptions : {};\n  polyfill$1();\n  let lastFullSnapshotEvent;\n  let incrementalSnapshotCount = 0;\n  const eventProcessor = (e2) => {\n    for (const plugin of plugins || []) {\n      if (plugin.eventProcessor) {\n        e2 = plugin.eventProcessor(e2);\n      }\n    }\n    if (packFn && // Disable packing events which will be emitted to parent frames.\n    !passEmitsToParent) {\n      e2 = packFn(e2);\n    }\n    return e2;\n  };\n  wrappedEmit = (r2, isCheckout) => {\n    const e2 = r2;\n    e2.timestamp = nowTimestamp();\n    if (mutationBuffers[0]?.isFrozen() && e2.type !== EventType.FullSnapshot && !(e2.type === EventType.IncrementalSnapshot && e2.data.source === IncrementalSource.Mutation)) {\n      mutationBuffers.forEach((buf) => buf.unfreeze());\n    }\n    if (inEmittingFrame) {\n      emit?.(eventProcessor(e2), isCheckout);\n    } else if (passEmitsToParent) {\n      const message = {\n        type: \"rrweb\",\n        event: eventProcessor(e2),\n        origin: window.location.origin,\n        isCheckout\n      };\n      window.parent.postMessage(message, \"*\");\n    }\n    if (e2.type === EventType.FullSnapshot) {\n      lastFullSnapshotEvent = e2;\n      incrementalSnapshotCount = 0;\n    } else if (e2.type === EventType.IncrementalSnapshot) {\n      if (e2.data.source === IncrementalSource.Mutation && e2.data.isAttachIframe) {\n        return;\n      }\n      incrementalSnapshotCount++;\n      const exceedCount = checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;\n      const exceedTime = checkoutEveryNms && lastFullSnapshotEvent && e2.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;\n      if (exceedCount || exceedTime) {\n        takeFullSnapshot2(true);\n      }\n    }\n  };\n  _wrappedEmit = wrappedEmit;\n  const wrappedMutationEmit = (m) => {\n    wrappedEmit({\n      type: EventType.IncrementalSnapshot,\n      data: {\n        source: IncrementalSource.Mutation,\n        ...m\n      }\n    });\n  };\n  const wrappedScrollEmit = (p) => wrappedEmit({\n    type: EventType.IncrementalSnapshot,\n    data: {\n      source: IncrementalSource.Scroll,\n      ...p\n    }\n  });\n  const wrappedCanvasMutationEmit = (p) => wrappedEmit({\n    type: EventType.IncrementalSnapshot,\n    data: {\n      source: IncrementalSource.CanvasMutation,\n      ...p\n    }\n  });\n  const wrappedAdoptedStyleSheetEmit = (a2) => wrappedEmit({\n    type: EventType.IncrementalSnapshot,\n    data: {\n      source: IncrementalSource.AdoptedStyleSheet,\n      ...a2\n    }\n  });\n  const stylesheetManager = new StylesheetManager({\n    mutationCb: wrappedMutationEmit,\n    adoptedStyleSheetCb: wrappedAdoptedStyleSheetEmit\n  });\n  const iframeManager = typeof __RRWEB_EXCLUDE_IFRAME__ === \"boolean\" && __RRWEB_EXCLUDE_IFRAME__ ? new IframeManagerNoop() : new IframeManager({\n    mirror,\n    mutationCb: wrappedMutationEmit,\n    stylesheetManager,\n    recordCrossOriginIframes,\n    wrappedEmit\n  });\n  for (const plugin of plugins || []) {\n    if (plugin.getMirror)\n      plugin.getMirror({\n        nodeMirror: mirror,\n        crossOriginIframeMirror: iframeManager.crossOriginIframeMirror,\n        crossOriginIframeStyleMirror: iframeManager.crossOriginIframeStyleMirror\n      });\n  }\n  const processedNodeManager = new ProcessedNodeManager();\n  const canvasManager = _getCanvasManager(\n    getCanvasManager,\n    {\n      mirror,\n      win: window,\n      mutationCb: (p) => wrappedEmit({\n        type: EventType.IncrementalSnapshot,\n        data: {\n          source: IncrementalSource.CanvasMutation,\n          ...p\n        }\n      }),\n      recordCanvas,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      maxCanvasSize,\n      sampling: sampling[\"canvas\"],\n      dataURLOptions,\n      errorHandler: errorHandler2\n    }\n  );\n  const shadowDomManager = typeof __RRWEB_EXCLUDE_SHADOW_DOM__ === \"boolean\" && __RRWEB_EXCLUDE_SHADOW_DOM__ ? new ShadowDomManagerNoop() : new ShadowDomManager({\n    mutationCb: wrappedMutationEmit,\n    scrollCb: wrappedScrollEmit,\n    bypassOptions: {\n      onMutation,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      maskAllText,\n      maskTextClass,\n      unmaskTextClass,\n      maskTextSelector,\n      unmaskTextSelector,\n      inlineStylesheet,\n      maskInputOptions,\n      dataURLOptions,\n      maskAttributeFn,\n      maskTextFn,\n      maskInputFn,\n      recordCanvas,\n      inlineImages,\n      sampling,\n      slimDOMOptions,\n      iframeManager,\n      stylesheetManager,\n      canvasManager,\n      keepIframeSrcFn,\n      processedNodeManager,\n      ignoreCSSAttributes\n    },\n    mirror\n  });\n  const takeFullSnapshot2 = (isCheckout = false) => {\n    if (!recordDOM) {\n      return;\n    }\n    wrappedEmit(\n      {\n        type: EventType.Meta,\n        data: {\n          href: window.location.href,\n          width: getWindowWidth(),\n          height: getWindowHeight()\n        }\n      },\n      isCheckout\n    );\n    stylesheetManager.reset();\n    shadowDomManager.init();\n    mutationBuffers.forEach((buf) => buf.lock());\n    const node = snapshot(document, {\n      mirror,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      maskAllText,\n      maskTextClass,\n      unmaskTextClass,\n      maskTextSelector,\n      unmaskTextSelector,\n      inlineStylesheet,\n      maskAllInputs: maskInputOptions,\n      maskAttributeFn,\n      maskInputFn,\n      maskTextFn,\n      slimDOM: slimDOMOptions,\n      dataURLOptions,\n      recordCanvas,\n      inlineImages,\n      onSerialize: (n2) => {\n        if (isSerializedIframe(n2, mirror)) {\n          iframeManager.addIframe(n2);\n        }\n        if (isSerializedStylesheet(n2, mirror)) {\n          stylesheetManager.trackLinkElement(n2);\n        }\n        if (hasShadowRoot(n2)) {\n          shadowDomManager.addShadowRoot(n2.shadowRoot, document);\n        }\n      },\n      onIframeLoad: (iframe, childSn) => {\n        iframeManager.attachIframe(iframe, childSn);\n        if (iframe.contentWindow) {\n          canvasManager.addWindow(iframe.contentWindow);\n        }\n        shadowDomManager.observeAttachShadow(iframe);\n      },\n      onStylesheetLoad: (linkEl, childSn) => {\n        stylesheetManager.attachLinkElement(linkEl, childSn);\n      },\n      onBlockedImageLoad: (_imageEl, serializedNode, { width, height }) => {\n        wrappedMutationEmit({\n          adds: [],\n          removes: [],\n          texts: [],\n          attributes: [\n            {\n              id: serializedNode.id,\n              attributes: {\n                style: {\n                  width: `${width}px`,\n                  height: `${height}px`\n                }\n              }\n            }\n          ]\n        });\n      },\n      keepIframeSrcFn,\n      ignoreCSSAttributes\n    });\n    if (!node) {\n      return console.warn(\"Failed to snapshot the document\");\n    }\n    wrappedEmit({\n      type: EventType.FullSnapshot,\n      data: {\n        node,\n        initialOffset: getWindowScroll(window)\n      }\n    });\n    mutationBuffers.forEach((buf) => buf.unlock());\n    if (document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0)\n      stylesheetManager.adoptStyleSheets(\n        document.adoptedStyleSheets,\n        mirror.getId(document)\n      );\n  };\n  _takeFullSnapshot = takeFullSnapshot2;\n  try {\n    const handlers = [];\n    const observe = (doc) => {\n      return callbackWrapper(initObservers)(\n        {\n          onMutation,\n          mutationCb: wrappedMutationEmit,\n          mousemoveCb: (positions, source) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source,\n              positions\n            }\n          }),\n          mouseInteractionCb: (d) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.MouseInteraction,\n              ...d\n            }\n          }),\n          scrollCb: wrappedScrollEmit,\n          viewportResizeCb: (d) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.ViewportResize,\n              ...d\n            }\n          }),\n          inputCb: (v2) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.Input,\n              ...v2\n            }\n          }),\n          mediaInteractionCb: (p) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.MediaInteraction,\n              ...p\n            }\n          }),\n          styleSheetRuleCb: (r2) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.StyleSheetRule,\n              ...r2\n            }\n          }),\n          styleDeclarationCb: (r2) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.StyleDeclaration,\n              ...r2\n            }\n          }),\n          canvasMutationCb: wrappedCanvasMutationEmit,\n          fontCb: (p) => wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: {\n              source: IncrementalSource.Font,\n              ...p\n            }\n          }),\n          selectionCb: (p) => {\n            wrappedEmit({\n              type: EventType.IncrementalSnapshot,\n              data: {\n                source: IncrementalSource.Selection,\n                ...p\n              }\n            });\n          },\n          customElementCb: (c2) => {\n            wrappedEmit({\n              type: EventType.IncrementalSnapshot,\n              data: {\n                source: IncrementalSource.CustomElement,\n                ...c2\n              }\n            });\n          },\n          blockClass,\n          ignoreClass,\n          ignoreSelector,\n          maskAllText,\n          maskTextClass,\n          unmaskTextClass,\n          maskTextSelector,\n          unmaskTextSelector,\n          maskInputOptions,\n          inlineStylesheet,\n          sampling,\n          recordDOM,\n          recordCanvas,\n          inlineImages,\n          userTriggeredOnInput,\n          collectFonts,\n          doc,\n          maskAttributeFn,\n          maskInputFn,\n          maskTextFn,\n          keepIframeSrcFn,\n          blockSelector,\n          unblockSelector,\n          slimDOMOptions,\n          dataURLOptions,\n          mirror,\n          iframeManager,\n          stylesheetManager,\n          shadowDomManager,\n          processedNodeManager,\n          canvasManager,\n          ignoreCSSAttributes,\n          plugins: plugins?.filter((p) => p.observer)?.map((p) => ({\n            observer: p.observer,\n            options: p.options,\n            callback: (payload) => wrappedEmit({\n              type: EventType.Plugin,\n              data: {\n                plugin: p.name,\n                payload\n              }\n            })\n          })) || []\n        },\n        {}\n      );\n    };\n    iframeManager.addLoadListener((iframeEl) => {\n      try {\n        handlers.push(observe(iframeEl.contentDocument));\n      } catch (error) {\n        console.warn(error);\n      }\n    });\n    const init = () => {\n      takeFullSnapshot2();\n      handlers.push(observe(document));\n    };\n    if (document.readyState === \"interactive\" || document.readyState === \"complete\") {\n      init();\n    } else {\n      handlers.push(\n        on(\"DOMContentLoaded\", () => {\n          wrappedEmit({\n            type: EventType.DomContentLoaded,\n            data: {}\n          });\n          if (recordAfter === \"DOMContentLoaded\") init();\n        })\n      );\n      handlers.push(\n        on(\n          \"load\",\n          () => {\n            wrappedEmit({\n              type: EventType.Load,\n              data: {}\n            });\n            if (recordAfter === \"load\") init();\n          },\n          window\n        )\n      );\n    }\n    return () => {\n      handlers.forEach((h) => h());\n      processedNodeManager.destroy();\n      _takeFullSnapshot = void 0;\n      unregisterErrorHandler();\n    };\n  } catch (error) {\n    console.warn(error);\n  }\n}\nfunction addCustomEvent(tag, payload) {\n  if (!_wrappedEmit) {\n    throw new Error(\"please add custom event after start recording\");\n  }\n  wrappedEmit({\n    type: EventType.Custom,\n    data: {\n      tag,\n      payload\n    }\n  });\n}\nfunction freezePage() {\n  mutationBuffers.forEach((buf) => buf.freeze());\n}\nfunction takeFullSnapshot(isCheckout) {\n  if (!_takeFullSnapshot) {\n    throw new Error(\"please take full snapshot after start recording\");\n  }\n  _takeFullSnapshot(isCheckout);\n}\nrecord.mirror = mirror;\nrecord.takeFullSnapshot = takeFullSnapshot;\nfunction _getCanvasManager(getCanvasManagerFn, options) {\n  try {\n    return getCanvasManagerFn ? getCanvasManagerFn(options) : new CanvasManagerNoop();\n  } catch {\n    console.warn(\"Unable to initialize CanvasManager\");\n    return new CanvasManagerNoop();\n  }\n}\nfunction mitt$1(n2) {\n  return { all: n2 = n2 || /* @__PURE__ */ new Map(), on: function(t2, e2) {\n    var i2 = n2.get(t2);\n    i2 ? i2.push(e2) : n2.set(t2, [e2]);\n  }, off: function(t2, e2) {\n    var i2 = n2.get(t2);\n    i2 && (e2 ? i2.splice(i2.indexOf(e2) >>> 0, 1) : n2.set(t2, []));\n  }, emit: function(t2, e2) {\n    var i2 = n2.get(t2);\n    i2 && i2.slice().map(function(n3) {\n      n3(e2);\n    }), (i2 = n2.get(\"*\")) && i2.slice().map(function(n3) {\n      n3(t2, e2);\n    });\n  } };\n}\nconst mittProxy = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  default: mitt$1\n}, Symbol.toStringTag, { value: \"Module\" }));\nfunction polyfill(w = window, d = document) {\n  if (\"scrollBehavior\" in d.documentElement.style && w.__forceSmoothScrollPolyfill__ !== true) {\n    return;\n  }\n  const Element2 = w.HTMLElement || w.Element;\n  const SCROLL_TIME = 468;\n  const original = {\n    scroll: w.scroll || w.scrollTo,\n    scrollBy: w.scrollBy,\n    elementScroll: Element2.prototype.scroll || scrollElement,\n    scrollIntoView: Element2.prototype.scrollIntoView\n  };\n  const now = w.performance && w.performance.now ? w.performance.now.bind(w.performance) : Date.now;\n  function isMicrosoftBrowser(userAgent) {\n    const userAgentPatterns = [\"MSIE \", \"Trident/\", \"Edge/\"];\n    return new RegExp(userAgentPatterns.join(\"|\")).test(userAgent);\n  }\n  const ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;\n  function scrollElement(x, y) {\n    this.scrollLeft = x;\n    this.scrollTop = y;\n  }\n  function ease(k) {\n    return 0.5 * (1 - Math.cos(Math.PI * k));\n  }\n  function shouldBailOut(firstArg) {\n    if (firstArg === null || typeof firstArg !== \"object\" || firstArg.behavior === void 0 || firstArg.behavior === \"auto\" || firstArg.behavior === \"instant\") {\n      return true;\n    }\n    if (typeof firstArg === \"object\" && firstArg.behavior === \"smooth\") {\n      return false;\n    }\n    throw new TypeError(\n      \"behavior member of ScrollOptions \" + firstArg.behavior + \" is not a valid value for enumeration ScrollBehavior.\"\n    );\n  }\n  function hasScrollableSpace(el, axis) {\n    if (axis === \"Y\") {\n      return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;\n    }\n    if (axis === \"X\") {\n      return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;\n    }\n  }\n  function canOverflow(el, axis) {\n    const overflowValue = w.getComputedStyle(el, null)[\"overflow\" + axis];\n    return overflowValue === \"auto\" || overflowValue === \"scroll\";\n  }\n  function isScrollable(el) {\n    const isScrollableY = hasScrollableSpace(el, \"Y\") && canOverflow(el, \"Y\");\n    const isScrollableX = hasScrollableSpace(el, \"X\") && canOverflow(el, \"X\");\n    return isScrollableY || isScrollableX;\n  }\n  function findScrollableParent(el) {\n    while (el !== d.body && isScrollable(el) === false) {\n      el = el.parentNode || el.host;\n    }\n    return el;\n  }\n  function step(context) {\n    const time = now();\n    let value;\n    let currentX;\n    let currentY;\n    let elapsed = (time - context.startTime) / SCROLL_TIME;\n    elapsed = elapsed > 1 ? 1 : elapsed;\n    value = ease(elapsed);\n    currentX = context.startX + (context.x - context.startX) * value;\n    currentY = context.startY + (context.y - context.startY) * value;\n    context.method.call(context.scrollable, currentX, currentY);\n    if (currentX !== context.x || currentY !== context.y) {\n      w.requestAnimationFrame(step.bind(w, context));\n    }\n  }\n  function smoothScroll(el, x, y) {\n    let scrollable;\n    let startX;\n    let startY;\n    let method;\n    const startTime = now();\n    if (el === d.body) {\n      scrollable = w;\n      startX = w.scrollX || w.pageXOffset;\n      startY = w.scrollY || w.pageYOffset;\n      method = original.scroll;\n    } else {\n      scrollable = el;\n      startX = el.scrollLeft;\n      startY = el.scrollTop;\n      method = scrollElement;\n    }\n    step({\n      scrollable,\n      method,\n      startTime,\n      startX,\n      startY,\n      x,\n      y\n    });\n  }\n  w.scroll = w.scrollTo = function() {\n    if (arguments[0] === void 0) {\n      return;\n    }\n    if (shouldBailOut(arguments[0]) === true) {\n      original.scroll.call(\n        w,\n        arguments[0].left !== void 0 ? arguments[0].left : typeof arguments[0] !== \"object\" ? arguments[0] : w.scrollX || w.pageXOffset,\n        // use top prop, second argument if present or fallback to scrollY\n        arguments[0].top !== void 0 ? arguments[0].top : arguments[1] !== void 0 ? arguments[1] : w.scrollY || w.pageYOffset\n      );\n      return;\n    }\n    smoothScroll.call(\n      w,\n      d.body,\n      arguments[0].left !== void 0 ? ~~arguments[0].left : w.scrollX || w.pageXOffset,\n      arguments[0].top !== void 0 ? ~~arguments[0].top : w.scrollY || w.pageYOffset\n    );\n  };\n  w.scrollBy = function() {\n    if (arguments[0] === void 0) {\n      return;\n    }\n    if (shouldBailOut(arguments[0])) {\n      original.scrollBy.call(\n        w,\n        arguments[0].left !== void 0 ? arguments[0].left : typeof arguments[0] !== \"object\" ? arguments[0] : 0,\n        arguments[0].top !== void 0 ? arguments[0].top : arguments[1] !== void 0 ? arguments[1] : 0\n      );\n      return;\n    }\n    smoothScroll.call(\n      w,\n      d.body,\n      ~~arguments[0].left + (w.scrollX || w.pageXOffset),\n      ~~arguments[0].top + (w.scrollY || w.pageYOffset)\n    );\n  };\n  Element2.prototype.scroll = Element2.prototype.scrollTo = function() {\n    if (arguments[0] === void 0) {\n      return;\n    }\n    if (shouldBailOut(arguments[0]) === true) {\n      if (typeof arguments[0] === \"number\" && arguments[1] === void 0) {\n        throw new SyntaxError(\"Value could not be converted\");\n      }\n      original.elementScroll.call(\n        this,\n        // use left prop, first number argument or fallback to scrollLeft\n        arguments[0].left !== void 0 ? ~~arguments[0].left : typeof arguments[0] !== \"object\" ? ~~arguments[0] : this.scrollLeft,\n        // use top prop, second argument or fallback to scrollTop\n        arguments[0].top !== void 0 ? ~~arguments[0].top : arguments[1] !== void 0 ? ~~arguments[1] : this.scrollTop\n      );\n      return;\n    }\n    const left = arguments[0].left;\n    const top = arguments[0].top;\n    smoothScroll.call(\n      this,\n      this,\n      typeof left === \"undefined\" ? this.scrollLeft : ~~left,\n      typeof top === \"undefined\" ? this.scrollTop : ~~top\n    );\n  };\n  Element2.prototype.scrollBy = function() {\n    if (arguments[0] === void 0) {\n      return;\n    }\n    if (shouldBailOut(arguments[0]) === true) {\n      original.elementScroll.call(\n        this,\n        arguments[0].left !== void 0 ? ~~arguments[0].left + this.scrollLeft : ~~arguments[0] + this.scrollLeft,\n        arguments[0].top !== void 0 ? ~~arguments[0].top + this.scrollTop : ~~arguments[1] + this.scrollTop\n      );\n      return;\n    }\n    this.scroll({\n      left: ~~arguments[0].left + this.scrollLeft,\n      top: ~~arguments[0].top + this.scrollTop,\n      behavior: arguments[0].behavior\n    });\n  };\n  Element2.prototype.scrollIntoView = function() {\n    if (shouldBailOut(arguments[0]) === true) {\n      original.scrollIntoView.call(\n        this,\n        arguments[0] === void 0 ? true : arguments[0]\n      );\n      return;\n    }\n    const scrollableParent = findScrollableParent(this);\n    const parentRects = scrollableParent.getBoundingClientRect();\n    const clientRects = this.getBoundingClientRect();\n    if (scrollableParent !== d.body) {\n      smoothScroll.call(\n        this,\n        scrollableParent,\n        scrollableParent.scrollLeft + clientRects.left - parentRects.left,\n        scrollableParent.scrollTop + clientRects.top - parentRects.top\n      );\n      if (w.getComputedStyle(scrollableParent).position !== \"fixed\") {\n        w.scrollBy({\n          left: parentRects.left,\n          top: parentRects.top,\n          behavior: \"smooth\"\n        });\n      }\n    } else {\n      w.scrollBy({\n        left: clientRects.left,\n        top: clientRects.top,\n        behavior: \"smooth\"\n      });\n    }\n  };\n}\nclass Timer {\n  constructor(actions = [], config) {\n    this.timeOffset = 0;\n    this.raf = null;\n    this.actions = actions;\n    this.speed = config.speed;\n  }\n  /**\n   * Add an action, possibly after the timer starts.\n   */\n  addAction(action) {\n    const rafWasActive = this.raf === true;\n    if (!this.actions.length || this.actions[this.actions.length - 1].delay <= action.delay) {\n      this.actions.push(action);\n    } else {\n      const index = this.findActionIndex(action);\n      this.actions.splice(index, 0, action);\n    }\n    if (rafWasActive) {\n      this.raf = onRequestAnimationFrame(this.rafCheck.bind(this));\n    }\n  }\n  start() {\n    this.timeOffset = 0;\n    this.lastTimestamp = performance.now();\n    this.raf = onRequestAnimationFrame(this.rafCheck.bind(this));\n  }\n  rafCheck() {\n    const time = performance.now();\n    this.timeOffset += (time - this.lastTimestamp) * this.speed;\n    this.lastTimestamp = time;\n    while (this.actions.length) {\n      const action = this.actions[0];\n      if (this.timeOffset >= action.delay) {\n        this.actions.shift();\n        action.doAction();\n      } else {\n        break;\n      }\n    }\n    if (this.actions.length > 0) {\n      this.raf = onRequestAnimationFrame(this.rafCheck.bind(this));\n    } else {\n      this.raf = true;\n    }\n  }\n  clear() {\n    if (this.raf) {\n      if (this.raf !== true) {\n        cancelAnimationFrame(this.raf);\n      }\n      this.raf = null;\n    }\n    this.actions.length = 0;\n  }\n  setSpeed(speed) {\n    this.speed = speed;\n  }\n  isActive() {\n    return this.raf !== null;\n  }\n  findActionIndex(action) {\n    let start = 0;\n    let end = this.actions.length - 1;\n    while (start <= end) {\n      const mid = Math.floor((start + end) / 2);\n      if (this.actions[mid].delay < action.delay) {\n        start = mid + 1;\n      } else if (this.actions[mid].delay > action.delay) {\n        end = mid - 1;\n      } else {\n        return mid + 1;\n      }\n    }\n    return start;\n  }\n}\nfunction addDelay(event, baselineTime) {\n  if (event.type === EventType.IncrementalSnapshot && event.data.source === IncrementalSource.MouseMove && event.data.positions && event.data.positions.length) {\n    const firstOffset = event.data.positions[0].timeOffset;\n    const firstTimestamp = event.timestamp + firstOffset;\n    event.delay = firstTimestamp - baselineTime;\n    return firstTimestamp - baselineTime;\n  }\n  event.delay = event.timestamp - baselineTime;\n  return event.delay;\n}\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nfunction t(t2, n2) {\n  var e2 = \"function\" == typeof Symbol && t2[Symbol.iterator];\n  if (!e2) return t2;\n  var r2, o2, i2 = e2.call(t2), a2 = [];\n  try {\n    for (; (void 0 === n2 || n2-- > 0) && !(r2 = i2.next()).done; ) a2.push(r2.value);\n  } catch (t3) {\n    o2 = { error: t3 };\n  } finally {\n    try {\n      r2 && !r2.done && (e2 = i2.return) && e2.call(i2);\n    } finally {\n      if (o2) throw o2.error;\n    }\n  }\n  return a2;\n}\nvar n;\n!function(t2) {\n  t2[t2.NotStarted = 0] = \"NotStarted\", t2[t2.Running = 1] = \"Running\", t2[t2.Stopped = 2] = \"Stopped\";\n}(n || (n = {}));\nvar e = { type: \"xstate.init\" };\nfunction r(t2) {\n  return void 0 === t2 ? [] : [].concat(t2);\n}\nfunction o(t2) {\n  return { type: \"xstate.assign\", assignment: t2 };\n}\nfunction i(t2, n2) {\n  return \"string\" == typeof (t2 = \"string\" == typeof t2 && n2 && n2[t2] ? n2[t2] : t2) ? { type: t2 } : \"function\" == typeof t2 ? { type: t2.name, exec: t2 } : t2;\n}\nfunction a(t2) {\n  return function(n2) {\n    return t2 === n2;\n  };\n}\nfunction u(t2) {\n  return \"string\" == typeof t2 ? { type: t2 } : t2;\n}\nfunction c(t2, n2) {\n  return { value: t2, context: n2, actions: [], changed: false, matches: a(t2) };\n}\nfunction f(t2, n2, e2) {\n  var r2 = n2, o2 = false;\n  return [t2.filter(function(t3) {\n    if (\"xstate.assign\" === t3.type) {\n      o2 = true;\n      var n3 = Object.assign({}, r2);\n      return \"function\" == typeof t3.assignment ? n3 = t3.assignment(r2, e2) : Object.keys(t3.assignment).forEach(function(o3) {\n        n3[o3] = \"function\" == typeof t3.assignment[o3] ? t3.assignment[o3](r2, e2) : t3.assignment[o3];\n      }), r2 = n3, false;\n    }\n    return true;\n  }), r2, o2];\n}\nfunction s(n2, o2) {\n  void 0 === o2 && (o2 = {});\n  var s2 = t(f(r(n2.states[n2.initial].entry).map(function(t2) {\n    return i(t2, o2.actions);\n  }), n2.context, e), 2), l2 = s2[0], v2 = s2[1], y = { config: n2, _options: o2, initialState: { value: n2.initial, actions: l2, context: v2, matches: a(n2.initial) }, transition: function(e2, o3) {\n    var s3, l3, v3 = \"string\" == typeof e2 ? { value: e2, context: n2.context } : e2, p = v3.value, g = v3.context, d = u(o3), x = n2.states[p];\n    if (x.on) {\n      var m = r(x.on[d.type]);\n      try {\n        for (var h = function(t2) {\n          var n3 = \"function\" == typeof Symbol && Symbol.iterator, e3 = n3 && t2[n3], r2 = 0;\n          if (e3) return e3.call(t2);\n          if (t2 && \"number\" == typeof t2.length) return { next: function() {\n            return t2 && r2 >= t2.length && (t2 = void 0), { value: t2 && t2[r2++], done: !t2 };\n          } };\n          throw new TypeError(n3 ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n        }(m), b = h.next(); !b.done; b = h.next()) {\n          var S = b.value;\n          if (void 0 === S) return c(p, g);\n          var w = \"string\" == typeof S ? { target: S } : S, j = w.target, E = w.actions, R = void 0 === E ? [] : E, N = w.cond, O = void 0 === N ? function() {\n            return true;\n          } : N, _ = void 0 === j, k = null != j ? j : p, T = n2.states[k];\n          if (O(g, d)) {\n            var q = t(f((_ ? r(R) : [].concat(x.exit, R, T.entry).filter(function(t2) {\n              return t2;\n            })).map(function(t2) {\n              return i(t2, y._options.actions);\n            }), g, d), 3), z = q[0], A = q[1], B = q[2], C = null != j ? j : p;\n            return { value: C, context: A, actions: z, changed: j !== p || z.length > 0 || B, matches: a(C) };\n          }\n        }\n      } catch (t2) {\n        s3 = { error: t2 };\n      } finally {\n        try {\n          b && !b.done && (l3 = h.return) && l3.call(h);\n        } finally {\n          if (s3) throw s3.error;\n        }\n      }\n    }\n    return c(p, g);\n  } };\n  return y;\n}\nvar l = function(t2, n2) {\n  return t2.actions.forEach(function(e2) {\n    var r2 = e2.exec;\n    return r2 && r2(t2.context, n2);\n  });\n};\nfunction v(t2) {\n  var r2 = t2.initialState, o2 = n.NotStarted, i2 = /* @__PURE__ */ new Set(), c2 = { _machine: t2, send: function(e2) {\n    o2 === n.Running && (r2 = t2.transition(r2, e2), l(r2, u(e2)), i2.forEach(function(t3) {\n      return t3(r2);\n    }));\n  }, subscribe: function(t3) {\n    return i2.add(t3), t3(r2), { unsubscribe: function() {\n      return i2.delete(t3);\n    } };\n  }, start: function(i3) {\n    if (i3) {\n      var u2 = \"object\" == typeof i3 ? i3 : { context: t2.config.context, value: i3 };\n      r2 = { value: u2.value, actions: [], context: u2.context, matches: a(u2.value) };\n    }\n    return o2 = n.Running, l(r2, e), c2;\n  }, stop: function() {\n    return o2 = n.Stopped, i2.clear(), c2;\n  }, get state() {\n    return r2;\n  }, get status() {\n    return o2;\n  } };\n  return c2;\n}\nfunction discardPriorSnapshots(events, baselineTime) {\n  for (let idx = events.length - 1; idx >= 0; idx--) {\n    const event = events[idx];\n    if (event.type === EventType.Meta) {\n      if (event.timestamp <= baselineTime) {\n        return events.slice(idx);\n      }\n    }\n  }\n  return events;\n}\nfunction createPlayerService(context, { getCastFn, applyEventsSynchronously, emitter }) {\n  const playerMachine = s(\n    {\n      id: \"player\",\n      context,\n      initial: \"paused\",\n      states: {\n        playing: {\n          on: {\n            PAUSE: {\n              target: \"paused\",\n              actions: [\"pause\"]\n            },\n            CAST_EVENT: {\n              target: \"playing\",\n              actions: \"castEvent\"\n            },\n            END: {\n              target: \"paused\",\n              actions: [\"resetLastPlayedEvent\", \"pause\"]\n            },\n            ADD_EVENT: {\n              target: \"playing\",\n              actions: [\"addEvent\"]\n            }\n          }\n        },\n        paused: {\n          on: {\n            PLAY: {\n              target: \"playing\",\n              actions: [\"recordTimeOffset\", \"play\"]\n            },\n            CAST_EVENT: {\n              target: \"paused\",\n              actions: \"castEvent\"\n            },\n            TO_LIVE: {\n              target: \"live\",\n              actions: [\"startLive\"]\n            },\n            ADD_EVENT: {\n              target: \"paused\",\n              actions: [\"addEvent\"]\n            }\n          }\n        },\n        live: {\n          on: {\n            ADD_EVENT: {\n              target: \"live\",\n              actions: [\"addEvent\"]\n            },\n            CAST_EVENT: {\n              target: \"live\",\n              actions: [\"castEvent\"]\n            }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        castEvent: o({\n          lastPlayedEvent: (ctx, event) => {\n            if (event.type === \"CAST_EVENT\") {\n              return event.payload.event;\n            }\n            return ctx.lastPlayedEvent;\n          }\n        }),\n        recordTimeOffset: o((ctx, event) => {\n          let timeOffset = ctx.timeOffset;\n          if (\"payload\" in event && \"timeOffset\" in event.payload) {\n            timeOffset = event.payload.timeOffset;\n          }\n          return {\n            ...ctx,\n            timeOffset,\n            baselineTime: ctx.events[0].timestamp + timeOffset\n          };\n        }),\n        play(ctx) {\n          const { timer, events, baselineTime, lastPlayedEvent } = ctx;\n          timer.clear();\n          for (const event of events) {\n            addDelay(event, baselineTime);\n          }\n          const neededEvents = discardPriorSnapshots(events, baselineTime);\n          let lastPlayedTimestamp = lastPlayedEvent?.timestamp;\n          if (lastPlayedEvent?.type === EventType.IncrementalSnapshot && lastPlayedEvent.data.source === IncrementalSource.MouseMove) {\n            lastPlayedTimestamp = lastPlayedEvent.timestamp + lastPlayedEvent.data.positions[0]?.timeOffset;\n          }\n          if (baselineTime < (lastPlayedTimestamp || 0)) {\n            emitter.emit(ReplayerEvents.PlayBack);\n          }\n          const syncEvents = new Array();\n          for (const event of neededEvents) {\n            if (lastPlayedTimestamp && lastPlayedTimestamp < baselineTime && (event.timestamp <= lastPlayedTimestamp || event === lastPlayedEvent)) {\n              continue;\n            }\n            if (event.timestamp < baselineTime) {\n              syncEvents.push(event);\n            } else {\n              const castFn = getCastFn(event, false);\n              timer.addAction({\n                doAction: () => {\n                  castFn();\n                },\n                delay: event.delay\n              });\n            }\n          }\n          applyEventsSynchronously(syncEvents);\n          emitter.emit(ReplayerEvents.Flush);\n          timer.start();\n        },\n        pause(ctx) {\n          ctx.timer.clear();\n        },\n        resetLastPlayedEvent: o((ctx) => {\n          return {\n            ...ctx,\n            lastPlayedEvent: null\n          };\n        }),\n        startLive: o({\n          baselineTime: (ctx, event) => {\n            ctx.timer.start();\n            if (event.type === \"TO_LIVE\" && event.payload.baselineTime) {\n              return event.payload.baselineTime;\n            }\n            return Date.now();\n          }\n        }),\n        addEvent: o((ctx, machineEvent) => {\n          const { baselineTime, timer, events } = ctx;\n          if (machineEvent.type === \"ADD_EVENT\") {\n            const { event } = machineEvent.payload;\n            addDelay(event, baselineTime);\n            let end = events.length - 1;\n            if (!events[end] || events[end].timestamp <= event.timestamp) {\n              events.push(event);\n            } else {\n              let insertionIndex = -1;\n              let start = 0;\n              while (start <= end) {\n                const mid = Math.floor((start + end) / 2);\n                if (events[mid].timestamp <= event.timestamp) {\n                  start = mid + 1;\n                } else {\n                  end = mid - 1;\n                }\n              }\n              if (insertionIndex === -1) {\n                insertionIndex = start;\n              }\n              events.splice(insertionIndex, 0, event);\n            }\n            const isSync = event.timestamp < baselineTime;\n            const castFn = getCastFn(event, isSync);\n            if (isSync) {\n              castFn();\n            } else if (timer.isActive()) {\n              timer.addAction({\n                doAction: () => {\n                  castFn();\n                },\n                delay: event.delay\n              });\n            }\n          }\n          return { ...ctx, events };\n        })\n      }\n    }\n  );\n  return v(playerMachine);\n}\nfunction createSpeedService(context) {\n  const speedMachine = s(\n    {\n      id: \"speed\",\n      context,\n      initial: \"normal\",\n      states: {\n        normal: {\n          on: {\n            FAST_FORWARD: {\n              target: \"skipping\",\n              actions: [\"recordSpeed\", \"setSpeed\"]\n            },\n            SET_SPEED: {\n              target: \"normal\",\n              actions: [\"setSpeed\"]\n            }\n          }\n        },\n        skipping: {\n          on: {\n            BACK_TO_NORMAL: {\n              target: \"normal\",\n              actions: [\"restoreSpeed\"]\n            },\n            SET_SPEED: {\n              target: \"normal\",\n              actions: [\"setSpeed\"]\n            }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        setSpeed: (ctx, event) => {\n          if (\"payload\" in event) {\n            ctx.timer.setSpeed(event.payload.speed);\n          }\n        },\n        recordSpeed: o({\n          normalSpeed: (ctx) => ctx.timer.speed\n        }),\n        restoreSpeed: (ctx) => {\n          ctx.timer.setSpeed(ctx.normalSpeed);\n        }\n      }\n    }\n  );\n  return v(speedMachine);\n}\nconst rules = (blockClass) => [\n  `.${blockClass} { background: currentColor }`,\n  \"noscript { display: none !important; }\"\n];\nconst webGLVarMap = /* @__PURE__ */ new Map();\nfunction variableListFor(ctx, ctor) {\n  let contextMap = webGLVarMap.get(ctx);\n  if (!contextMap) {\n    contextMap = /* @__PURE__ */ new Map();\n    webGLVarMap.set(ctx, contextMap);\n  }\n  if (!contextMap.has(ctor)) {\n    contextMap.set(ctor, []);\n  }\n  return contextMap.get(ctor);\n}\nfunction deserializeArg(imageMap, ctx, preload) {\n  return async (arg) => {\n    if (arg && typeof arg === \"object\" && \"rr_type\" in arg) {\n      if (preload) preload.isUnchanged = false;\n      if (arg.rr_type === \"ImageBitmap\" && \"args\" in arg) {\n        const args = await deserializeArg(imageMap, ctx, preload)(arg.args);\n        return await createImageBitmap.apply(null, args);\n      } else if (\"index\" in arg) {\n        if (preload || ctx === null) return arg;\n        const { rr_type: name, index } = arg;\n        return variableListFor(ctx, name)[index];\n      } else if (\"args\" in arg) {\n        const { rr_type: name, args } = arg;\n        const ctor = window[name];\n        return new ctor(\n          ...await Promise.all(\n            args.map(deserializeArg(imageMap, ctx, preload))\n          )\n        );\n      } else if (\"base64\" in arg) {\n        return decode(arg.base64);\n      } else if (\"src\" in arg) {\n        const image = imageMap.get(arg.src);\n        if (image) {\n          return image;\n        } else {\n          const image2 = new Image();\n          image2.src = arg.src;\n          imageMap.set(arg.src, image2);\n          return image2;\n        }\n      } else if (\"data\" in arg && arg.rr_type === \"Blob\") {\n        const blobContents = await Promise.all(\n          arg.data.map(deserializeArg(imageMap, ctx, preload))\n        );\n        const blob = new Blob(blobContents, {\n          type: arg.type\n        });\n        return blob;\n      }\n    } else if (Array.isArray(arg)) {\n      const result = await Promise.all(\n        arg.map(deserializeArg(imageMap, ctx, preload))\n      );\n      return result;\n    }\n    return arg;\n  };\n}\nfunction getContext(target, type) {\n  try {\n    if (type === CanvasContext.WebGL) {\n      return target.getContext(\"webgl\") || target.getContext(\"experimental-webgl\");\n    }\n    return target.getContext(\"webgl2\");\n  } catch (e2) {\n    return null;\n  }\n}\nconst WebGLVariableConstructorsNames = [\n  \"WebGLActiveInfo\",\n  \"WebGLBuffer\",\n  \"WebGLFramebuffer\",\n  \"WebGLProgram\",\n  \"WebGLRenderbuffer\",\n  \"WebGLShader\",\n  \"WebGLShaderPrecisionFormat\",\n  \"WebGLTexture\",\n  \"WebGLUniformLocation\",\n  \"WebGLVertexArrayObject\"\n];\nfunction saveToWebGLVarMap(ctx, result) {\n  if (!result?.constructor) return;\n  const { name } = result.constructor;\n  if (!WebGLVariableConstructorsNames.includes(name)) return;\n  const variables = variableListFor(ctx, name);\n  if (!variables.includes(result)) variables.push(result);\n}\nasync function webglMutation({\n  mutation,\n  target,\n  type,\n  imageMap,\n  errorHandler: errorHandler2\n}) {\n  try {\n    const ctx = getContext(target, type);\n    if (!ctx) return;\n    if (mutation.setter) {\n      ctx[mutation.property] = mutation.args[0];\n      return;\n    }\n    const original = ctx[mutation.property];\n    const args = await Promise.all(\n      mutation.args.map(deserializeArg(imageMap, ctx))\n    );\n    const result = original.apply(ctx, args);\n    saveToWebGLVarMap(ctx, result);\n    const debugMode = false;\n    if (debugMode) ;\n  } catch (error) {\n    errorHandler2(mutation, error);\n  }\n}\nasync function canvasMutation$1({\n  event,\n  mutations,\n  target,\n  imageMap,\n  errorHandler: errorHandler2\n}) {\n  const ctx = target.getContext(\"2d\");\n  if (!ctx) {\n    errorHandler2(mutations[0], new Error(\"Canvas context is null\"));\n    return;\n  }\n  const mutationArgsPromises = mutations.map(\n    async (mutation) => {\n      return Promise.all(mutation.args.map(deserializeArg(imageMap, ctx)));\n    }\n  );\n  const args = await Promise.all(mutationArgsPromises);\n  args.forEach((args2, index) => {\n    const mutation = mutations[index];\n    try {\n      if (mutation.setter) {\n        ctx[mutation.property] = mutation.args[0];\n        return;\n      }\n      const original = ctx[mutation.property];\n      if (mutation.property === \"drawImage\" && typeof mutation.args[0] === \"string\") {\n        imageMap.get(event);\n        original.apply(ctx, mutation.args);\n      } else {\n        original.apply(ctx, args2);\n      }\n    } catch (error) {\n      errorHandler2(mutation, error);\n    }\n    return;\n  });\n}\nasync function canvasMutation({\n  event,\n  mutation,\n  target,\n  imageMap,\n  canvasEventMap,\n  errorHandler: errorHandler2\n}) {\n  try {\n    const precomputedMutation = canvasEventMap.get(event) || mutation;\n    const commands = \"commands\" in precomputedMutation ? precomputedMutation.commands : [precomputedMutation];\n    if ([CanvasContext.WebGL, CanvasContext.WebGL2].includes(mutation.type)) {\n      for (let i2 = 0; i2 < commands.length; i2++) {\n        const command = commands[i2];\n        await webglMutation({\n          mutation: command,\n          type: mutation.type,\n          target,\n          imageMap,\n          errorHandler: errorHandler2\n        });\n      }\n      return;\n    }\n    await canvasMutation$1({\n      event,\n      mutations: commands,\n      target,\n      imageMap,\n      errorHandler: errorHandler2\n    });\n  } catch (error) {\n    errorHandler2(mutation, error);\n  }\n}\nconst SKIP_TIME_INTERVAL = 5 * 1e3;\nconst mitt = mitt$1 || mittProxy;\nconst REPLAY_CONSOLE_PREFIX = \"[replayer]\";\nfunction getEventIndex(events, eventTime) {\n  let result = -1;\n  if (events.length === 0) {\n    return result;\n  }\n  let left = 0, right = events.length - 1;\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (events[mid].timestamp <= eventTime) {\n      result = mid;\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n  return result;\n}\nconst defaultMouseTailConfig = {\n  duration: 500,\n  lineCap: \"round\",\n  lineWidth: 3,\n  strokeStyle: \"red\"\n};\nfunction indicatesTouchDevice(e2) {\n  return e2.type == EventType.IncrementalSnapshot && (e2.data.source == IncrementalSource.TouchMove || e2.data.source == IncrementalSource.MouseInteraction && e2.data.type == MouseInteractions.TouchStart);\n}\nfunction getPointerId(d) {\n  const pointerId = \"pointerId\" in d && typeof d.pointerId === \"number\" ? d.pointerId : -1;\n  return pointerId;\n}\nclass Replayer {\n  constructor(events, config) {\n    this.usingVirtualDom = false;\n    this.virtualDom = new RRDocument();\n    this.emitter = mitt();\n    this.legacy_missingNodeRetryMap = {};\n    this.cache = createCache();\n    this.imageMap = /* @__PURE__ */ new Map();\n    this.canvasEventMap = /* @__PURE__ */ new Map();\n    this.mirror = createMirror$2();\n    this.styleMirror = new StyleSheetMirror();\n    this.firstFullSnapshot = null;\n    this.newDocumentQueue = [];\n    this.pointers = {};\n    this.lastMouseDownEvent = null;\n    this.lastSelectionData = null;\n    this.constructedStyleMutations = [];\n    this.adoptedStyleSheets = [];\n    this.handleResize = (dimension) => {\n      this.iframe.style.display = \"inherit\";\n      for (const el of [\n        ...Object.values(this.pointers).flatMap((a2) => a2.mouseTail),\n        this.iframe\n      ]) {\n        if (!el) {\n          continue;\n        }\n        el.setAttribute(\"width\", String(dimension.width));\n        el.setAttribute(\"height\", String(dimension.height));\n      }\n    };\n    this.applyEventsSynchronously = (events2) => {\n      for (const event of events2) {\n        switch (event.type) {\n          case EventType.DomContentLoaded:\n          case EventType.Load:\n          case EventType.Custom:\n            continue;\n          case EventType.FullSnapshot:\n          case EventType.Meta:\n          case EventType.Plugin:\n          case EventType.IncrementalSnapshot:\n            break;\n        }\n        const castFn = this.getCastFn(event, true);\n        castFn();\n      }\n    };\n    this.getCastFn = (event, isSync = false) => {\n      let castFn;\n      switch (event.type) {\n        case EventType.DomContentLoaded:\n        case EventType.Load:\n          break;\n        case EventType.Custom:\n          castFn = () => {\n            this.emitter.emit(ReplayerEvents.CustomEvent, event);\n          };\n          break;\n        case EventType.Meta:\n          castFn = () => this.emitter.emit(ReplayerEvents.Resize, {\n            width: event.data.width,\n            height: event.data.height\n          });\n          break;\n        case EventType.FullSnapshot:\n          castFn = () => {\n            if (this.firstFullSnapshot) {\n              if (this.firstFullSnapshot === event) {\n                this.firstFullSnapshot = true;\n                return;\n              }\n            } else {\n              this.firstFullSnapshot = true;\n            }\n            this.rebuildFullSnapshot(event, isSync);\n            this.iframe.contentWindow?.scrollTo(event.data.initialOffset);\n            this.styleMirror.reset();\n          };\n          break;\n        case EventType.IncrementalSnapshot:\n          castFn = () => {\n            this.applyIncremental(event, isSync);\n            if (isSync) {\n              return;\n            }\n            if (event === this.nextUserInteractionEvent) {\n              this.nextUserInteractionEvent = null;\n              this.backToNormal();\n            }\n            if (this.config.skipInactive && !this.nextUserInteractionEvent) {\n              for (const _event of this.service.state.context.events) {\n                if (_event.timestamp <= event.timestamp) {\n                  continue;\n                }\n                if (this.isUserInteraction(_event)) {\n                  if (\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    _event.delay - event.delay > this.config.inactivePeriodThreshold * this.speedService.state.context.timer.speed\n                  ) {\n                    this.nextUserInteractionEvent = _event;\n                  }\n                  break;\n                }\n              }\n              if (this.nextUserInteractionEvent) {\n                const skipTime = (\n                  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                  this.nextUserInteractionEvent.delay - event.delay\n                );\n                const payload = {\n                  speed: Math.min(\n                    Math.round(skipTime / SKIP_TIME_INTERVAL),\n                    this.config.maxSpeed\n                  )\n                };\n                this.speedService.send({ type: \"FAST_FORWARD\", payload });\n                this.emitter.emit(ReplayerEvents.SkipStart, payload);\n              }\n            }\n          };\n          break;\n      }\n      const wrappedCastFn = () => {\n        if (castFn) {\n          castFn();\n        }\n        for (const plugin of this.config.plugins || []) {\n          if (plugin.handler) plugin.handler(event, isSync, { replayer: this });\n        }\n        this.service.send({ type: \"CAST_EVENT\", payload: { event } });\n        const last_index = this.service.state.context.events.length - 1;\n        if (!this.config.liveMode && event === this.service.state.context.events[last_index]) {\n          const finish = () => {\n            if (last_index < this.service.state.context.events.length - 1) {\n              return;\n            }\n            this.backToNormal();\n            this.service.send(\"END\");\n            this.emitter.emit(ReplayerEvents.Finish);\n          };\n          let finish_buffer = 50;\n          if (event.type === EventType.IncrementalSnapshot && event.data.source === IncrementalSource.MouseMove && event.data.positions.length) {\n            finish_buffer += Math.max(0, -event.data.positions[0].timeOffset);\n          }\n          setTimeout$1(finish, finish_buffer);\n        }\n        this.emitter.emit(ReplayerEvents.EventCast, event);\n      };\n      return wrappedCastFn;\n    };\n    if (!config?.liveMode && events.length < 2) {\n      throw new Error(\"Replayer need at least 2 events.\");\n    }\n    const defaultConfig = {\n      speed: 1,\n      maxSpeed: 360,\n      root: document.body,\n      loadTimeout: 0,\n      skipInactive: false,\n      inactivePeriodThreshold: 10 * 1e3,\n      showWarning: true,\n      showDebug: false,\n      blockClass: \"rr-block\",\n      liveMode: false,\n      insertStyleRules: [],\n      triggerFocus: true,\n      UNSAFE_replayCanvas: false,\n      pauseAnimation: true,\n      mouseTail: defaultMouseTailConfig,\n      useVirtualDom: true,\n      // Virtual-dom optimization is enabled by default.\n      logger: console\n    };\n    this.config = Object.assign({}, defaultConfig, config);\n    this.handleResize = this.handleResize.bind(this);\n    this.getCastFn = this.getCastFn.bind(this);\n    this.applyEventsSynchronously = this.applyEventsSynchronously.bind(this);\n    this.emitter.on(ReplayerEvents.Resize, this.handleResize);\n    this.setupDom();\n    for (const plugin of this.config.plugins || []) {\n      if (plugin.getMirror) plugin.getMirror({ nodeMirror: this.mirror });\n    }\n    this.emitter.on(ReplayerEvents.Flush, () => {\n      if (this.usingVirtualDom) {\n        const replayerHandler = {\n          mirror: this.mirror,\n          applyCanvas: (canvasEvent, canvasMutationData2, target) => {\n            void canvasMutation({\n              event: canvasEvent,\n              mutation: canvasMutationData2,\n              target,\n              imageMap: this.imageMap,\n              canvasEventMap: this.canvasEventMap,\n              errorHandler: this.warnCanvasMutationFailed.bind(this)\n            });\n          },\n          applyInput: this.applyInput.bind(this),\n          applyScroll: this.applyScroll.bind(this),\n          applyStyleSheetMutation: (data, styleSheet) => {\n            if (data.source === IncrementalSource.StyleSheetRule)\n              this.applyStyleSheetRule(data, styleSheet);\n            else if (data.source === IncrementalSource.StyleDeclaration)\n              this.applyStyleDeclaration(data, styleSheet);\n          },\n          afterAppend: (node, id) => {\n            for (const plugin of this.config.plugins || []) {\n              if (plugin.onBuild) plugin.onBuild(node, { id, replayer: this });\n            }\n          }\n        };\n        const iframeDoc = getIFrameContentDocument(this.iframe);\n        if (iframeDoc)\n          try {\n            diff(\n              iframeDoc,\n              this.virtualDom,\n              replayerHandler,\n              this.virtualDom.mirror\n            );\n          } catch (e2) {\n            console.warn(e2);\n          }\n        this.virtualDom.destroyTree();\n        this.usingVirtualDom = false;\n        if (Object.keys(this.legacy_missingNodeRetryMap).length) {\n          for (const key in this.legacy_missingNodeRetryMap) {\n            try {\n              const value = this.legacy_missingNodeRetryMap[key];\n              const realNode = createOrGetNode(\n                value.node,\n                this.mirror,\n                this.virtualDom.mirror\n              );\n              diff(\n                realNode,\n                value.node,\n                replayerHandler,\n                this.virtualDom.mirror\n              );\n              value.node = realNode;\n            } catch (error) {\n              this.warn(error);\n            }\n          }\n        }\n        this.constructedStyleMutations.forEach((data) => {\n          this.applyStyleSheetMutation(data);\n        });\n        this.constructedStyleMutations = [];\n        this.adoptedStyleSheets.forEach((data) => {\n          this.applyAdoptedStyleSheet(data);\n        });\n        this.adoptedStyleSheets = [];\n      }\n      for (const [\n        pointerId,\n        { pointerPosition, touchActive }\n      ] of Object.entries(this.pointers)) {\n        const id = parseInt(pointerId);\n        const pointer = this.pointers[id];\n        if (pointerPosition) {\n          this.moveAndHover(\n            pointerPosition.x,\n            pointerPosition.y,\n            pointerPosition.id,\n            true,\n            pointerPosition.debugData,\n            id\n          );\n          pointer.pointerPosition = null;\n        }\n        if (touchActive === true) {\n          pointer.pointerEl.classList.add(\"touch-active\");\n        } else if (touchActive === false) {\n          pointer.pointerEl.classList.remove(\"touch-active\");\n        }\n        pointer.touchActive = null;\n      }\n      if (this.lastMouseDownEvent) {\n        const [target, event] = this.lastMouseDownEvent;\n        target.dispatchEvent(event);\n      }\n      this.lastMouseDownEvent = null;\n      if (this.lastSelectionData) {\n        this.applySelection(this.lastSelectionData);\n        this.lastSelectionData = null;\n      }\n    });\n    this.emitter.on(ReplayerEvents.PlayBack, () => {\n      this.firstFullSnapshot = null;\n      this.mirror.reset();\n      this.styleMirror.reset();\n    });\n    const timer = new Timer([], {\n      speed: this.config.speed\n    });\n    this.service = createPlayerService(\n      {\n        events: events.map((e2) => {\n          if (config && config.unpackFn) {\n            return config.unpackFn(e2);\n          }\n          return e2;\n        }).sort((a1, a2) => a1.timestamp - a2.timestamp),\n        timer,\n        timeOffset: 0,\n        baselineTime: 0,\n        lastPlayedEvent: null\n      },\n      {\n        getCastFn: this.getCastFn,\n        applyEventsSynchronously: this.applyEventsSynchronously,\n        emitter: this.emitter\n      }\n    );\n    this.service.start();\n    this.service.subscribe((state) => {\n      this.emitter.emit(ReplayerEvents.StateChange, {\n        player: state\n      });\n    });\n    this.speedService = createSpeedService({\n      normalSpeed: -1,\n      timer\n    });\n    this.speedService.start();\n    this.speedService.subscribe((state) => {\n      this.emitter.emit(ReplayerEvents.StateChange, {\n        speed: state\n      });\n    });\n    const firstMeta = this.service.state.context.events.find(\n      (e2) => e2.type === EventType.Meta\n    );\n    const firstFullsnapshot = this.service.state.context.events.find(\n      (e2) => e2.type === EventType.FullSnapshot\n    );\n    if (firstMeta) {\n      const { width, height } = firstMeta.data;\n      setTimeout$1(() => {\n        this.emitter.emit(ReplayerEvents.Resize, {\n          width,\n          height\n        });\n      }, 0);\n    }\n    if (firstFullsnapshot) {\n      setTimeout$1(() => {\n        if (this.firstFullSnapshot) {\n          return;\n        }\n        this.firstFullSnapshot = firstFullsnapshot;\n        this.rebuildFullSnapshot(\n          firstFullsnapshot\n        );\n        this.iframe.contentWindow?.scrollTo(\n          firstFullsnapshot.data.initialOffset\n        );\n      }, 1);\n    }\n  }\n  get timer() {\n    return this.service.state.context.timer;\n  }\n  createPointer(pointerId, event) {\n    const mouseTail = document.createElement(\"canvas\");\n    mouseTail.classList.add(\"replayer-mouse-tail\");\n    mouseTail.width = Number.parseFloat(this.iframe.width);\n    mouseTail.height = Number.parseFloat(this.iframe.height);\n    this.wrapper.insertBefore(mouseTail, this.iframe);\n    mouseTail.style.display = this.config.mouseTail === false ? \"none\" : \"inherit\";\n    const newMouse = document.createElement(\"div\");\n    newMouse.classList.add(\"replayer-mouse\");\n    this.pointers[pointerId] = {\n      touchActive: null,\n      pointerEl: newMouse,\n      tailPositions: [],\n      pointerPosition: null,\n      mouseTail\n    };\n    if (indicatesTouchDevice(event)) {\n      newMouse.classList.add(\"touch-device\");\n    }\n    this.wrapper.appendChild(newMouse);\n  }\n  on(event, handler) {\n    this.emitter.on(event, handler);\n    return this;\n  }\n  off(event, handler) {\n    this.emitter.off(event, handler);\n    return this;\n  }\n  setConfig(config) {\n    const previousSkipInactive = this.config.skipInactive;\n    Object.keys(config).forEach((key) => {\n      config[key];\n      this.config[key] = config[key];\n    });\n    if (!this.config.skipInactive) {\n      this.backToNormal();\n    } else if (previousSkipInactive === false && this.config.skipInactive === true) {\n      this.reevaluateFastForward();\n    }\n    if (typeof config.speed !== \"undefined\") {\n      this.speedService.send({\n        type: \"SET_SPEED\",\n        payload: {\n          speed: config.speed\n        }\n      });\n    }\n    if (typeof config.mouseTail !== \"undefined\") {\n      if (config.mouseTail === false) {\n        for (const { mouseTail } of Object.values(this.pointers)) {\n          if (mouseTail) {\n            mouseTail.style.display = \"none\";\n          }\n        }\n      } else {\n        for (let { mouseTail } of Object.values(this.pointers)) {\n          if (!mouseTail) {\n            mouseTail = document.createElement(\"canvas\");\n            mouseTail.width = Number.parseFloat(this.iframe.width);\n            mouseTail.height = Number.parseFloat(this.iframe.height);\n            mouseTail.classList.add(\"replayer-mouse-tail\");\n            this.wrapper.insertBefore(mouseTail, this.iframe);\n          }\n          mouseTail.style.display = \"inherit\";\n        }\n      }\n    }\n  }\n  getMetaData() {\n    const firstEvent = this.service.state.context.events[0];\n    const lastEvent = this.service.state.context.events[this.service.state.context.events.length - 1];\n    return {\n      startTime: firstEvent.timestamp,\n      endTime: lastEvent.timestamp,\n      totalTime: lastEvent.timestamp - firstEvent.timestamp\n    };\n  }\n  getCurrentTime() {\n    return this.timer.timeOffset + this.getTimeOffset();\n  }\n  getTimeOffset() {\n    const { baselineTime, events } = this.service.state.context;\n    return baselineTime - events[0].timestamp;\n  }\n  getMirror() {\n    return this.mirror;\n  }\n  /**\n   * This API was designed to be used as play at any time offset.\n   * Since we minimized the data collected from recorder, we do not\n   * have the ability of undo an event.\n   * So the implementation of play at any time offset will always iterate\n   * all of the events, cast event before the offset synchronously\n   * and cast event after the offset asynchronously with timer.\n   * @param timeOffset - number\n   */\n  play(timeOffset = 0) {\n    if (this.config.skipInactive && this.speedService.state.matches(\"skipping\")) {\n      this.backToNormal();\n    }\n    if (this.service.state.matches(\"paused\")) {\n      this.service.send({ type: \"PLAY\", payload: { timeOffset } });\n    } else {\n      this.service.send({ type: \"PAUSE\" });\n      this.service.send({ type: \"PLAY\", payload: { timeOffset } });\n    }\n    const iframeDoc = getIFrameContentDocument(this.iframe);\n    iframeDoc?.getElementsByTagName(\"html\")[0]?.classList.remove(\"rrweb-paused\");\n    this.emitter.emit(ReplayerEvents.Start);\n    if (this.config.skipInactive) {\n      this.reevaluateFastForward();\n    }\n  }\n  pause(timeOffset) {\n    if (timeOffset === void 0 && this.service.state.matches(\"playing\")) {\n      this.service.send({ type: \"PAUSE\" });\n    }\n    if (typeof timeOffset === \"number\") {\n      this.play(timeOffset);\n      this.service.send({ type: \"PAUSE\" });\n    }\n    const iframeDoc = getIFrameContentDocument(this.iframe);\n    iframeDoc?.getElementsByTagName(\"html\")[0]?.classList.add(\"rrweb-paused\");\n    this.emitter.emit(ReplayerEvents.Pause);\n  }\n  resume(timeOffset = 0) {\n    this.warn(\n      `The 'resume' was deprecated in 1.0. Please use 'play' method which has the same interface.`\n    );\n    this.play(timeOffset);\n    this.emitter.emit(ReplayerEvents.Resume);\n  }\n  /**\n   * Totally destroy this replayer and please be careful that this operation is irreversible.\n   * Memory occupation can be released by removing all references to this replayer.\n   */\n  destroy() {\n    this.pause();\n    this.config.root.removeChild(this.wrapper);\n    this.emitter.emit(ReplayerEvents.Destroy);\n  }\n  startLive(baselineTime) {\n    this.service.send({ type: \"TO_LIVE\", payload: { baselineTime } });\n  }\n  addEvent(rawEvent) {\n    const event = this.config.unpackFn ? this.config.unpackFn(rawEvent) : rawEvent;\n    void Promise.resolve().then(\n      () => this.service.send({ type: \"ADD_EVENT\", payload: { event } })\n    );\n  }\n  enableInteract() {\n    this.iframe.setAttribute(\"scrolling\", \"auto\");\n    this.iframe.style.pointerEvents = \"auto\";\n  }\n  disableInteract() {\n    this.iframe.setAttribute(\"scrolling\", \"no\");\n    this.iframe.style.pointerEvents = \"none\";\n  }\n  /**\n   * Empties the replayer's cache and reclaims memory.\n   * The replayer will use this cache to speed up the playback.\n   */\n  resetCache() {\n    this.cache = createCache();\n  }\n  reevaluateFastForward() {\n    if (!this.config.skipInactive) {\n      return;\n    }\n    this.nextUserInteractionEvent = null;\n    const events = this.service.state.context.events;\n    const firstEvent = events[0];\n    if (!firstEvent) {\n      return;\n    }\n    const currentEventTime = firstEvent.timestamp + this.getCurrentTime();\n    const currentEventIndex = getEventIndex(events, currentEventTime);\n    if (currentEventIndex === -1) {\n      return;\n    }\n    const currentEvent = events[currentEventIndex];\n    const threshold = this.config.inactivePeriodThreshold * this.speedService.state.context.timer.speed;\n    for (let i2 = currentEventIndex + 1; i2 < events.length; i2++) {\n      const event = events[i2];\n      if (this.isUserInteraction(event)) {\n        const gapTime = event.timestamp - currentEvent.timestamp;\n        if (gapTime > threshold) {\n          this.nextUserInteractionEvent = event;\n          const payload = {\n            speed: Math.min(\n              Math.round(gapTime / SKIP_TIME_INTERVAL),\n              this.config.maxSpeed\n            )\n          };\n          this.speedService.send({ type: \"FAST_FORWARD\", payload });\n          this.emitter.emit(ReplayerEvents.SkipStart, payload);\n        }\n        break;\n      }\n    }\n  }\n  setupDom() {\n    this.wrapper = document.createElement(\"div\");\n    this.wrapper.classList.add(\"replayer-wrapper\");\n    this.config.root.appendChild(this.wrapper);\n    this.iframe = document.createElement(\"iframe\");\n    const attributes2 = [\"allow-same-origin\"];\n    if (this.config.UNSAFE_replayCanvas) {\n      attributes2.push(\"allow-scripts\");\n    }\n    this.iframe.style.display = \"none\";\n    this.iframe.setAttribute(\"sandbox\", attributes2.join(\" \"));\n    this.disableInteract();\n    this.wrapper.appendChild(this.iframe);\n    const iframeDoc = getIFrameContentDocument(this.iframe);\n    const iframeWindow = getIFrameContentWindow(this.iframe);\n    if (iframeWindow && iframeDoc) {\n      polyfill(iframeWindow, iframeDoc);\n      polyfill$1(iframeWindow);\n    }\n  }\n  rebuildFullSnapshot(event, isSync = false) {\n    const iframeDoc = getIFrameContentDocument(this.iframe);\n    if (!iframeDoc) {\n      return this.warn(\"Looks like your replayer has been destroyed.\");\n    }\n    if (Object.keys(this.legacy_missingNodeRetryMap).length) {\n      this.warn(\n        \"Found unresolved missing node map\",\n        this.legacy_missingNodeRetryMap\n      );\n    }\n    this.legacy_missingNodeRetryMap = {};\n    const collected = [];\n    const afterAppend = (builtNode, id) => {\n      this.collectIframeAndAttachDocument(collected, builtNode);\n      for (const plugin of this.config.plugins || []) {\n        if (plugin.onBuild)\n          plugin.onBuild(builtNode, {\n            id,\n            replayer: this\n          });\n      }\n    };\n    if (this.usingVirtualDom) {\n      this.virtualDom.destroyTree();\n      this.usingVirtualDom = false;\n    }\n    this.mirror.reset();\n    rebuild(event.data.node, {\n      doc: iframeDoc,\n      afterAppend,\n      cache: this.cache,\n      mirror: this.mirror\n    });\n    afterAppend(iframeDoc, event.data.node.id);\n    for (const { mutationInQueue, builtNode } of collected) {\n      this.attachDocumentToIframe(mutationInQueue, builtNode);\n      this.newDocumentQueue = this.newDocumentQueue.filter(\n        (m) => m !== mutationInQueue\n      );\n    }\n    const { documentElement, head } = iframeDoc;\n    this.insertStyleRules(documentElement, head);\n    if (!this.service.state.matches(\"playing\")) {\n      const iframeHtmlElement = iframeDoc.getElementsByTagName(\"html\")[0];\n      iframeHtmlElement && iframeHtmlElement.classList.add(\"rrweb-paused\");\n    }\n    this.emitter.emit(ReplayerEvents.FullsnapshotRebuilded, event);\n    if (!isSync) {\n      this.waitForStylesheetLoad();\n    }\n    if (this.config.UNSAFE_replayCanvas) {\n      void this.preloadAllImages();\n    }\n  }\n  insertStyleRules(documentElement, head) {\n    const injectStylesRules = rules(\n      this.config.blockClass\n    ).concat(this.config.insertStyleRules);\n    if (this.config.pauseAnimation) {\n      injectStylesRules.push(\n        \"html.rrweb-paused *, html.rrweb-paused *:before, html.rrweb-paused *:after { animation-play-state: paused !important; }\"\n      );\n    }\n    if (this.usingVirtualDom) {\n      const styleEl = this.virtualDom.createElement(\"style\");\n      this.virtualDom.mirror.add(\n        styleEl,\n        getDefaultSN(styleEl, this.virtualDom.unserializedId)\n      );\n      documentElement.insertBefore(styleEl, head);\n      styleEl.rules.push({\n        source: IncrementalSource.StyleSheetRule,\n        adds: injectStylesRules.map((cssText, index) => ({\n          rule: cssText,\n          index\n        }))\n      });\n    } else {\n      const styleEl = document.createElement(\"style\");\n      documentElement.insertBefore(\n        styleEl,\n        head\n      );\n      for (let idx = 0; idx < injectStylesRules.length; idx++) {\n        styleEl.sheet?.insertRule(injectStylesRules[idx], idx);\n      }\n    }\n  }\n  attachDocumentToIframe(mutation, iframeEl) {\n    const mirror2 = this.usingVirtualDom ? this.virtualDom.mirror : this.mirror;\n    const iframeContentDoc = getIFrameContentDocument(\n      iframeEl\n    );\n    const collected = [];\n    const afterAppend = (builtNode, id) => {\n      this.collectIframeAndAttachDocument(collected, builtNode);\n      const sn = mirror2.getMeta(builtNode);\n      if (sn?.type === NodeType$2.Element && sn?.tagName.toUpperCase() === \"HTML\" && iframeContentDoc) {\n        const { documentElement, head } = iframeContentDoc;\n        this.insertStyleRules(\n          documentElement,\n          head\n        );\n      }\n      if (this.usingVirtualDom) return;\n      for (const plugin of this.config.plugins || []) {\n        if (plugin.onBuild)\n          plugin.onBuild(builtNode, {\n            id,\n            replayer: this\n          });\n      }\n    };\n    buildNodeWithSN(mutation.node, {\n      doc: iframeContentDoc,\n      mirror: mirror2,\n      hackCss: true,\n      skipChild: false,\n      afterAppend,\n      cache: this.cache\n    });\n    afterAppend(iframeContentDoc, mutation.node.id);\n    for (const { mutationInQueue, builtNode } of collected) {\n      this.attachDocumentToIframe(mutationInQueue, builtNode);\n      this.newDocumentQueue = this.newDocumentQueue.filter(\n        (m) => m !== mutationInQueue\n      );\n    }\n  }\n  collectIframeAndAttachDocument(collected, builtNode) {\n    if (isSerializedIframe(builtNode, this.mirror)) {\n      const mutationInQueue = this.newDocumentQueue.find(\n        (m) => m.parentId === this.mirror.getId(builtNode)\n      );\n      if (mutationInQueue) {\n        collected.push({\n          mutationInQueue,\n          builtNode\n        });\n      }\n    }\n  }\n  /**\n   * pause when loading style sheet, resume when loaded all timeout exceed\n   */\n  waitForStylesheetLoad() {\n    const iframeDoc = getIFrameContentDocument(this.iframe);\n    const head = iframeDoc?.head;\n    if (head) {\n      const unloadSheets = /* @__PURE__ */ new Set();\n      let timer;\n      let beforeLoadState = this.service.state;\n      const stateHandler = () => {\n        beforeLoadState = this.service.state;\n      };\n      this.emitter.on(ReplayerEvents.Start, stateHandler);\n      this.emitter.on(ReplayerEvents.Pause, stateHandler);\n      const unsubscribe = () => {\n        this.emitter.off(ReplayerEvents.Start, stateHandler);\n        this.emitter.off(ReplayerEvents.Pause, stateHandler);\n      };\n      head.querySelectorAll('link[rel=\"stylesheet\"]').forEach((css) => {\n        if (!css.sheet) {\n          unloadSheets.add(css);\n          css.addEventListener(\"load\", () => {\n            unloadSheets.delete(css);\n            if (unloadSheets.size === 0 && timer !== -1) {\n              if (beforeLoadState.matches(\"playing\")) {\n                this.play(this.getCurrentTime());\n              }\n              this.emitter.emit(ReplayerEvents.LoadStylesheetEnd);\n              if (timer) {\n                clearTimeout(timer);\n              }\n              unsubscribe();\n            }\n          });\n        }\n      });\n      if (unloadSheets.size > 0) {\n        this.service.send({ type: \"PAUSE\" });\n        this.emitter.emit(ReplayerEvents.LoadStylesheetStart);\n        timer = setTimeout$1(() => {\n          if (beforeLoadState.matches(\"playing\")) {\n            this.play(this.getCurrentTime());\n          }\n          timer = -1;\n          unsubscribe();\n        }, this.config.loadTimeout);\n      }\n    }\n  }\n  /**\n   * pause when there are some canvas drawImage args need to be loaded\n   */\n  async preloadAllImages() {\n    const promises = [];\n    for (const event of this.service.state.context.events) {\n      if (event.type === EventType.IncrementalSnapshot && event.data.source === IncrementalSource.CanvasMutation) {\n        promises.push(\n          this.deserializeAndPreloadCanvasEvents(event.data, event)\n        );\n        const commands = \"commands\" in event.data ? event.data.commands : [event.data];\n        commands.forEach((c2) => {\n          this.preloadImages(c2, event);\n        });\n      }\n    }\n    return Promise.all(promises);\n  }\n  preloadImages(data, event) {\n    if (data.property === \"drawImage\" && typeof data.args[0] === \"string\" && !this.imageMap.has(event)) {\n      const canvas = document.createElement(\"canvas\");\n      const ctx = canvas.getContext(\"2d\");\n      const imgd = ctx?.createImageData(canvas.width, canvas.height);\n      ctx?.putImageData(imgd, 0, 0);\n    }\n  }\n  async deserializeAndPreloadCanvasEvents(data, event) {\n    if (!this.canvasEventMap.has(event)) {\n      const status = {\n        isUnchanged: true\n      };\n      if (\"commands\" in data) {\n        const commands = await Promise.all(\n          data.commands.map(async (c2) => {\n            const args = await Promise.all(\n              c2.args.map(deserializeArg(this.imageMap, null, status))\n            );\n            return { ...c2, args };\n          })\n        );\n        if (status.isUnchanged === false)\n          this.canvasEventMap.set(event, { ...data, commands });\n      } else {\n        const args = await Promise.all(\n          data.args.map(deserializeArg(this.imageMap, null, status))\n        );\n        if (status.isUnchanged === false)\n          this.canvasEventMap.set(event, { ...data, args });\n      }\n    }\n  }\n  applyIncremental(e2, isSync) {\n    const { data: d } = e2;\n    switch (d.source) {\n      case IncrementalSource.Mutation: {\n        try {\n          this.applyMutation(d, isSync);\n        } catch (error) {\n          this.warn(`Exception in mutation ${error.message || error}`, d);\n        }\n        break;\n      }\n      case IncrementalSource.Drag:\n      case IncrementalSource.TouchMove:\n      case IncrementalSource.MouseMove: {\n        const pointerId = getPointerId(d);\n        if (!this.pointers[pointerId]) {\n          this.createPointer(pointerId, e2);\n        }\n        const pointer = this.pointers[pointerId];\n        if (isSync) {\n          const lastPosition = d.positions[d.positions.length - 1];\n          pointer.pointerPosition = {\n            x: lastPosition.x,\n            y: lastPosition.y,\n            id: lastPosition.id,\n            debugData: d\n          };\n        } else {\n          d.positions.forEach((p) => {\n            const action = {\n              doAction: () => {\n                this.moveAndHover(p.x, p.y, p.id, isSync, d, pointerId);\n              },\n              delay: p.timeOffset + e2.timestamp - this.service.state.context.baselineTime\n            };\n            this.timer.addAction(action);\n          });\n          this.timer.addAction({\n            doAction() {\n            },\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            delay: e2.delay - d.positions[0]?.timeOffset\n          });\n        }\n        break;\n      }\n      case IncrementalSource.MouseInteraction: {\n        const pointerId = getPointerId(d);\n        if (!this.pointers[pointerId]) {\n          this.createPointer(pointerId, e2);\n        }\n        const pointer = this.pointers[pointerId];\n        if (d.id === -1) {\n          break;\n        }\n        const event = new Event(toLowerCase(MouseInteractions[d.type]));\n        const target = this.mirror.getNode(d.id);\n        if (!target) {\n          return this.debugNodeNotFound(d, d.id);\n        }\n        this.emitter.emit(ReplayerEvents.MouseInteraction, {\n          type: d.type,\n          target\n        });\n        const { triggerFocus } = this.config;\n        switch (d.type) {\n          case MouseInteractions.Blur:\n            if (\"blur\" in target) {\n              target.blur();\n            }\n            break;\n          case MouseInteractions.Focus:\n            if (triggerFocus && target.focus) {\n              target.focus({\n                preventScroll: true\n              });\n            }\n            break;\n          case MouseInteractions.Click:\n          case MouseInteractions.TouchStart:\n          case MouseInteractions.TouchEnd:\n          case MouseInteractions.MouseDown:\n          case MouseInteractions.MouseUp:\n            if (isSync) {\n              if (d.type === MouseInteractions.TouchStart) {\n                pointer.touchActive = true;\n                Object.values(this.pointers).forEach((p) => {\n                  if (p !== pointer && !p.touchActive) {\n                    p.touchActive = false;\n                  }\n                });\n              } else if (d.type === MouseInteractions.TouchEnd) {\n                pointer.touchActive = false;\n                pointer.pointerEl.remove();\n                if (pointer.mouseTail) {\n                  pointer.mouseTail.remove();\n                }\n                delete this.pointers[pointerId];\n              }\n              if (d.type === MouseInteractions.MouseDown) {\n                this.lastMouseDownEvent = [target, event];\n              } else if (d.type === MouseInteractions.MouseUp) {\n                this.lastMouseDownEvent = null;\n              }\n              pointer.pointerPosition = {\n                x: d.x || 0,\n                y: d.y || 0,\n                id: d.id,\n                debugData: d\n              };\n            } else {\n              if (d.type === MouseInteractions.TouchStart) {\n                pointer.tailPositions.length = 0;\n              }\n              this.moveAndHover(d.x || 0, d.y || 0, d.id, isSync, d, pointerId);\n              if (d.type === MouseInteractions.Click) {\n                pointer.pointerEl.classList.remove(\"active\");\n                void pointer.pointerEl.offsetWidth;\n                pointer.pointerEl.classList.add(\"active\");\n              } else if (d.type === MouseInteractions.TouchStart) {\n                void pointer.pointerEl.offsetWidth;\n                pointer.pointerEl.classList.add(\"touch-active\");\n              } else if (d.type === MouseInteractions.TouchEnd) {\n                pointer.pointerEl.remove();\n                if (pointer.mouseTail) {\n                  pointer.mouseTail.remove();\n                }\n                delete this.pointers[pointerId];\n              } else {\n                target.dispatchEvent(event);\n              }\n            }\n            break;\n          case MouseInteractions.TouchCancel:\n            if (isSync) {\n              pointer.touchActive = false;\n            } else {\n              pointer.pointerEl.classList.remove(\"touch-active\");\n            }\n            break;\n          default:\n            target.dispatchEvent(event);\n        }\n        break;\n      }\n      case IncrementalSource.Scroll: {\n        if (d.id === -1) {\n          break;\n        }\n        if (this.usingVirtualDom) {\n          const target = this.virtualDom.mirror.getNode(d.id);\n          if (!target) {\n            return this.debugNodeNotFound(d, d.id);\n          }\n          target.scrollData = d;\n          break;\n        }\n        this.applyScroll(d, isSync);\n        break;\n      }\n      case IncrementalSource.ViewportResize:\n        this.emitter.emit(ReplayerEvents.Resize, {\n          width: d.width,\n          height: d.height\n        });\n        break;\n      case IncrementalSource.Input: {\n        if (d.id === -1) {\n          break;\n        }\n        if (this.usingVirtualDom) {\n          const target = this.virtualDom.mirror.getNode(d.id);\n          if (!target) {\n            return this.debugNodeNotFound(d, d.id);\n          }\n          target.inputData = d;\n          break;\n        }\n        this.applyInput(d);\n        break;\n      }\n      case IncrementalSource.MediaInteraction: {\n        const target = this.usingVirtualDom ? this.virtualDom.mirror.getNode(d.id) : this.mirror.getNode(d.id);\n        if (!target) {\n          return this.debugNodeNotFound(d, d.id);\n        }\n        const mediaEl = target;\n        try {\n          if (d.currentTime !== void 0) {\n            mediaEl.currentTime = d.currentTime;\n          }\n          if (d.volume !== void 0) {\n            mediaEl.volume = d.volume;\n          }\n          if (d.muted !== void 0) {\n            mediaEl.muted = d.muted;\n          }\n          if (d.type === MediaInteractions.Pause) {\n            mediaEl.pause();\n          }\n          if (d.type === MediaInteractions.Play) {\n            const maybePlayPromise = mediaEl.play();\n            if (typeof maybePlayPromise?.catch === \"function\") {\n              maybePlayPromise.catch((err) => {\n                console.warn(err);\n              });\n            }\n          }\n          if (d.type === MediaInteractions.RateChange) {\n            mediaEl.playbackRate = d.playbackRate;\n          }\n        } catch (error) {\n          this.warn(\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/restrict-template-expressions\n            `Failed to replay media interactions: ${error.message || error}`\n          );\n        }\n        break;\n      }\n      case IncrementalSource.StyleSheetRule:\n      case IncrementalSource.StyleDeclaration: {\n        if (this.usingVirtualDom) {\n          if (d.styleId) this.constructedStyleMutations.push(d);\n          else if (d.id)\n            this.virtualDom.mirror.getNode(d.id)?.rules?.push(d);\n        } else this.applyStyleSheetMutation(d);\n        break;\n      }\n      case IncrementalSource.CanvasMutation: {\n        if (!this.config.UNSAFE_replayCanvas) {\n          return;\n        }\n        if (this.usingVirtualDom) {\n          const target = this.virtualDom.mirror.getNode(\n            d.id\n          );\n          if (!target) {\n            return this.debugNodeNotFound(d, d.id);\n          }\n          target.canvasMutations.push({\n            event: e2,\n            mutation: d\n          });\n        } else {\n          const target = this.mirror.getNode(d.id);\n          if (!target) {\n            return this.debugNodeNotFound(d, d.id);\n          }\n          void canvasMutation({\n            event: e2,\n            mutation: d,\n            target,\n            imageMap: this.imageMap,\n            canvasEventMap: this.canvasEventMap,\n            errorHandler: this.warnCanvasMutationFailed.bind(this)\n          });\n        }\n        break;\n      }\n      case IncrementalSource.Font: {\n        try {\n          const fontFace = new FontFace(\n            d.family,\n            d.buffer ? new Uint8Array(JSON.parse(d.fontSource)) : d.fontSource,\n            d.descriptors\n          );\n          getIFrameContentDocument(this.iframe)?.fonts.add(fontFace);\n        } catch (error) {\n          this.warn(error);\n        }\n        break;\n      }\n      case IncrementalSource.Selection: {\n        if (isSync) {\n          this.lastSelectionData = d;\n          break;\n        }\n        this.applySelection(d);\n        break;\n      }\n      case IncrementalSource.AdoptedStyleSheet: {\n        if (this.usingVirtualDom) this.adoptedStyleSheets.push(d);\n        else this.applyAdoptedStyleSheet(d);\n        break;\n      }\n    }\n  }\n  applyMutation(d, isSync) {\n    if (this.config.useVirtualDom && !this.usingVirtualDom && isSync) {\n      this.usingVirtualDom = true;\n      const iframeDoc = getIFrameContentDocument(this.iframe);\n      if (iframeDoc) {\n        buildFromDom(iframeDoc, this.mirror, this.virtualDom);\n      }\n      if (Object.keys(this.legacy_missingNodeRetryMap).length) {\n        for (const key in this.legacy_missingNodeRetryMap) {\n          try {\n            const value = this.legacy_missingNodeRetryMap[key];\n            const virtualNode = buildFromNode(\n              value.node,\n              this.virtualDom,\n              this.mirror\n            );\n            if (virtualNode) value.node = virtualNode;\n          } catch (error) {\n            this.warn(error);\n          }\n        }\n      }\n    }\n    const mirror2 = this.usingVirtualDom ? this.virtualDom.mirror : this.mirror;\n    d.removes = d.removes.filter((mutation) => {\n      if (!mirror2.getNode(mutation.id)) {\n        this.warnNodeNotFound(d, mutation.id);\n        return false;\n      }\n      return true;\n    });\n    d.removes.forEach((mutation) => {\n      const target = mirror2.getNode(mutation.id);\n      if (!target) {\n        return;\n      }\n      let parent = mirror2.getNode(\n        mutation.parentId\n      );\n      if (!parent) {\n        return this.warnNodeNotFound(d, mutation.parentId);\n      }\n      if (mutation.isShadow && hasShadowRoot(parent)) {\n        parent = parent.shadowRoot;\n      }\n      mirror2.removeNodeFromMap(target);\n      if (parent)\n        try {\n          parent.removeChild(target);\n          if (this.usingVirtualDom && target.nodeName === \"#text\" && parent.nodeName === \"STYLE\" && parent.rules?.length > 0)\n            parent.rules = [];\n        } catch (error) {\n          if (error instanceof DOMException) {\n            this.warn(\n              \"parent could not remove child in mutation\",\n              parent,\n              target,\n              d\n            );\n          } else {\n            throw error;\n          }\n        }\n    });\n    const legacy_missingNodeMap = {\n      ...this.legacy_missingNodeRetryMap\n    };\n    const queue = [];\n    const nextNotInDOM = (mutation) => {\n      let next = null;\n      if (mutation.nextId) {\n        next = mirror2.getNode(mutation.nextId);\n      }\n      if (mutation.nextId !== null && mutation.nextId !== void 0 && mutation.nextId !== -1 && !next) {\n        return true;\n      }\n      return false;\n    };\n    const appendNode = (mutation) => {\n      const iframeDoc = getIFrameContentDocument(this.iframe);\n      if (!iframeDoc) {\n        return this.warn(\"Looks like your replayer has been destroyed.\");\n      }\n      let parent = mirror2.getNode(\n        mutation.parentId\n      );\n      if (!parent) {\n        if (mutation.node.type === NodeType$2.Document) {\n          return this.newDocumentQueue.push(mutation);\n        }\n        return queue.push(mutation);\n      }\n      if (mutation.node.isShadow) {\n        if (!hasShadowRoot(parent)) {\n          parent.attachShadow({ mode: \"open\" });\n          parent = parent.shadowRoot;\n        } else parent = parent.shadowRoot;\n      }\n      let previous = null;\n      let next = null;\n      if (mutation.previousId) {\n        previous = mirror2.getNode(mutation.previousId);\n      }\n      if (mutation.nextId) {\n        next = mirror2.getNode(mutation.nextId);\n      }\n      if (nextNotInDOM(mutation)) {\n        return queue.push(mutation);\n      }\n      if (mutation.node.rootId && !mirror2.getNode(mutation.node.rootId)) {\n        return;\n      }\n      const targetDoc = mutation.node.rootId ? mirror2.getNode(mutation.node.rootId) : this.usingVirtualDom ? this.virtualDom : iframeDoc;\n      if (isSerializedIframe(parent, mirror2)) {\n        this.attachDocumentToIframe(\n          mutation,\n          parent\n        );\n        return;\n      }\n      const afterAppend = (node, id) => {\n        if (this.usingVirtualDom) return;\n        for (const plugin of this.config.plugins || []) {\n          if (plugin.onBuild) plugin.onBuild(node, { id, replayer: this });\n        }\n      };\n      const target = buildNodeWithSN(mutation.node, {\n        doc: targetDoc,\n        // can be Document or RRDocument\n        mirror: mirror2,\n        // can be this.mirror or virtualDom.mirror\n        skipChild: true,\n        hackCss: true,\n        cache: this.cache,\n        /**\n         * caveat: `afterAppend` only gets called on child nodes of target\n         * we have to call it again below when this target was added to the DOM\n         */\n        afterAppend\n      });\n      if (mutation.previousId === -1 || mutation.nextId === -1) {\n        legacy_missingNodeMap[mutation.node.id] = {\n          node: target,\n          mutation\n        };\n        return;\n      }\n      const parentSn = mirror2.getMeta(parent);\n      if (parentSn && parentSn.type === NodeType$2.Element && parentSn.tagName === \"textarea\" && mutation.node.type === NodeType$2.Text) {\n        const childNodeArray = Array.isArray(parent.childNodes) ? parent.childNodes : Array.from(parent.childNodes);\n        for (const c2 of childNodeArray) {\n          if (c2.nodeType === parent.TEXT_NODE) {\n            parent.removeChild(c2);\n          }\n        }\n      } else if (parentSn?.type === NodeType$2.Document) {\n        const parentDoc = parent;\n        if (mutation.node.type === NodeType$2.DocumentType && parentDoc.childNodes[0]?.nodeType === Node.DOCUMENT_TYPE_NODE)\n          parentDoc.removeChild(parentDoc.childNodes[0]);\n        if (target.nodeName === \"HTML\" && parentDoc.documentElement)\n          parentDoc.removeChild(\n            parentDoc.documentElement\n          );\n      }\n      if (previous && previous.nextSibling && previous.nextSibling.parentNode) {\n        parent.insertBefore(\n          target,\n          previous.nextSibling\n        );\n      } else if (next && next.parentNode) {\n        parent.contains(next) ? parent.insertBefore(target, next) : parent.insertBefore(target, null);\n      } else {\n        parent.appendChild(target);\n      }\n      afterAppend(target, mutation.node.id);\n      if (this.usingVirtualDom && target.nodeName === \"#text\" && parent.nodeName === \"STYLE\" && parent.rules?.length > 0)\n        parent.rules = [];\n      if (isSerializedIframe(target, this.mirror)) {\n        const targetId = this.mirror.getId(target);\n        const mutationInQueue = this.newDocumentQueue.find(\n          (m) => m.parentId === targetId\n        );\n        if (mutationInQueue) {\n          this.attachDocumentToIframe(\n            mutationInQueue,\n            target\n          );\n          this.newDocumentQueue = this.newDocumentQueue.filter(\n            (m) => m !== mutationInQueue\n          );\n        }\n      }\n      if (mutation.previousId || mutation.nextId) {\n        this.legacy_resolveMissingNode(\n          legacy_missingNodeMap,\n          parent,\n          target,\n          mutation\n        );\n      }\n    };\n    d.adds.forEach((mutation) => {\n      appendNode(mutation);\n    });\n    const startTime = Date.now();\n    while (queue.length) {\n      const resolveTrees = queueToResolveTrees(queue);\n      queue.length = 0;\n      if (Date.now() - startTime > 500) {\n        this.warn(\n          \"Timeout in the loop, please check the resolve tree data:\",\n          resolveTrees\n        );\n        break;\n      }\n      for (const tree of resolveTrees) {\n        const parent = mirror2.getNode(tree.value.parentId);\n        if (!parent) {\n          this.debug(\n            \"Drop resolve tree since there is no parent for the root node.\",\n            tree\n          );\n        } else {\n          iterateResolveTree(tree, (mutation) => {\n            appendNode(mutation);\n          });\n        }\n      }\n    }\n    if (Object.keys(legacy_missingNodeMap).length) {\n      Object.assign(this.legacy_missingNodeRetryMap, legacy_missingNodeMap);\n    }\n    uniqueTextMutations(d.texts).forEach((mutation) => {\n      const target = mirror2.getNode(mutation.id);\n      if (!target) {\n        if (d.removes.find((r2) => r2.id === mutation.id)) {\n          return;\n        }\n        return this.warnNodeNotFound(d, mutation.id);\n      }\n      target.textContent = mutation.value;\n      if (this.usingVirtualDom) {\n        const parent = target.parentNode;\n        if (parent?.rules?.length > 0) parent.rules = [];\n      }\n    });\n    d.attributes.forEach((mutation) => {\n      const target = mirror2.getNode(mutation.id);\n      if (!target) {\n        if (d.removes.find((r2) => r2.id === mutation.id)) {\n          return;\n        }\n        return this.warnNodeNotFound(d, mutation.id);\n      }\n      for (const attributeName in mutation.attributes) {\n        if (typeof attributeName === \"string\") {\n          const value = mutation.attributes[attributeName];\n          if (value === null) {\n            target.removeAttribute(attributeName);\n          } else if (typeof value === \"string\") {\n            try {\n              if (attributeName === \"_cssText\" && (target.nodeName === \"LINK\" || target.nodeName === \"STYLE\")) {\n                try {\n                  const newSn = mirror2.getMeta(\n                    target\n                  );\n                  const newNode = buildNodeWithSN(\n                    {\n                      ...newSn,\n                      attributes: {\n                        ...newSn.attributes,\n                        ...mutation.attributes\n                      }\n                    },\n                    {\n                      doc: target.ownerDocument,\n                      // can be Document or RRDocument\n                      mirror: mirror2,\n                      skipChild: true,\n                      hackCss: true,\n                      cache: this.cache\n                    }\n                  );\n                  const siblingNode = target.nextSibling;\n                  const parentNode = target.parentNode;\n                  if (newNode && parentNode) {\n                    parentNode.removeChild(target);\n                    parentNode.insertBefore(\n                      newNode,\n                      siblingNode\n                    );\n                    mirror2.replace(mutation.id, newNode);\n                    break;\n                  }\n                } catch (e2) {\n                }\n              }\n              if (target.nodeType !== 3) {\n                target.setAttribute(\n                  attributeName,\n                  value\n                );\n              }\n            } catch (error) {\n              this.warn(\n                \"An error occurred may due to the checkout feature.\",\n                error\n              );\n            }\n          } else if (attributeName === \"style\") {\n            const styleValues = value;\n            const targetEl = target;\n            for (const s2 in styleValues) {\n              if (styleValues[s2] === false) {\n                targetEl.style.removeProperty(s2);\n              } else if (styleValues[s2] instanceof Array) {\n                const svp = styleValues[s2];\n                targetEl.style.setProperty(s2, svp[0], svp[1]);\n              } else {\n                const svs = styleValues[s2];\n                targetEl.style.setProperty(s2, svs);\n              }\n            }\n          }\n        }\n      }\n    });\n  }\n  /**\n   * Apply the scroll data on real elements.\n   * If the replayer is in sync mode, smooth scroll behavior should be disabled.\n   * @param d - the scroll data\n   * @param isSync - whether the replayer is in sync mode(fast-forward)\n   */\n  applyScroll(d, isSync) {\n    const target = this.mirror.getNode(d.id);\n    if (!target) {\n      return this.debugNodeNotFound(d, d.id);\n    }\n    const sn = this.mirror.getMeta(target);\n    const iframeDoc = getIFrameContentDocument(this.iframe);\n    if (target === iframeDoc) {\n      this.iframe.contentWindow?.scrollTo({\n        top: d.y,\n        left: d.x,\n        behavior: isSync ? \"auto\" : \"smooth\"\n      });\n    } else if (sn?.type === NodeType$2.Document) {\n      target.defaultView?.scrollTo({\n        top: d.y,\n        left: d.x,\n        behavior: isSync ? \"auto\" : \"smooth\"\n      });\n    } else {\n      try {\n        target.scrollTo({\n          top: d.y,\n          left: d.x,\n          behavior: isSync ? \"auto\" : \"smooth\"\n        });\n      } catch (error) {\n      }\n    }\n  }\n  applyInput(d) {\n    const target = this.mirror.getNode(d.id);\n    if (!target) {\n      return this.debugNodeNotFound(d, d.id);\n    }\n    try {\n      target.checked = d.isChecked;\n      target.value = d.text;\n    } catch (error) {\n    }\n  }\n  applySelection(d) {\n    try {\n      const selectionSet = /* @__PURE__ */ new Set();\n      const ranges = d.ranges.map(({ start, startOffset, end, endOffset }) => {\n        const startContainer = this.mirror.getNode(start);\n        const endContainer = this.mirror.getNode(end);\n        if (!startContainer || !endContainer) return;\n        const result = new Range();\n        result.setStart(startContainer, startOffset);\n        result.setEnd(endContainer, endOffset);\n        const doc = startContainer.ownerDocument;\n        const selection = doc?.getSelection();\n        selection && selectionSet.add(selection);\n        return {\n          range: result,\n          selection\n        };\n      });\n      selectionSet.forEach((s2) => s2.removeAllRanges());\n      ranges.forEach((r2) => r2 && r2.selection?.addRange(r2.range));\n    } catch (error) {\n    }\n  }\n  applyStyleSheetMutation(data) {\n    let styleSheet = null;\n    if (data.styleId) styleSheet = this.styleMirror.getStyle(data.styleId);\n    else if (data.id)\n      styleSheet = this.mirror.getNode(data.id)?.sheet || null;\n    if (!styleSheet) return;\n    if (data.source === IncrementalSource.StyleSheetRule)\n      this.applyStyleSheetRule(data, styleSheet);\n    else if (data.source === IncrementalSource.StyleDeclaration)\n      this.applyStyleDeclaration(data, styleSheet);\n  }\n  applyStyleSheetRule(data, styleSheet) {\n    data.adds?.forEach(({ rule, index: nestedIndex }) => {\n      try {\n        if (Array.isArray(nestedIndex)) {\n          const { positions, index } = getPositionsAndIndex(nestedIndex);\n          const nestedRule = getNestedRule(styleSheet.cssRules, positions);\n          nestedRule.insertRule(rule, index);\n        } else {\n          const index = nestedIndex === void 0 ? void 0 : Math.min(nestedIndex, styleSheet.cssRules.length);\n          styleSheet?.insertRule(rule, index);\n        }\n      } catch (e2) {\n      }\n    });\n    data.removes?.forEach(({ index: nestedIndex }) => {\n      try {\n        if (Array.isArray(nestedIndex)) {\n          const { positions, index } = getPositionsAndIndex(nestedIndex);\n          const nestedRule = getNestedRule(styleSheet.cssRules, positions);\n          nestedRule.deleteRule(index || 0);\n        } else {\n          styleSheet?.deleteRule(nestedIndex);\n        }\n      } catch (e2) {\n      }\n    });\n    if (data.replace)\n      try {\n        void styleSheet.replace?.(data.replace);\n      } catch (e2) {\n      }\n    if (data.replaceSync)\n      try {\n        styleSheet.replaceSync?.(data.replaceSync);\n      } catch (e2) {\n      }\n  }\n  applyStyleDeclaration(data, styleSheet) {\n    if (data.set) {\n      const rule = getNestedRule(\n        styleSheet.rules,\n        data.index\n      );\n      rule && rule.style && rule.style.setProperty(\n        data.set.property,\n        data.set.value,\n        data.set.priority\n      );\n    }\n    if (data.remove) {\n      const rule = getNestedRule(\n        styleSheet.rules,\n        data.index\n      );\n      rule && rule.style && rule.style.removeProperty(data.remove.property);\n    }\n  }\n  applyAdoptedStyleSheet(data) {\n    const targetHost = this.mirror.getNode(data.id);\n    if (!targetHost) return;\n    data.styles?.forEach((style) => {\n      let newStyleSheet = null;\n      let hostWindow = null;\n      if (hasShadowRoot(targetHost))\n        hostWindow = targetHost.ownerDocument?.defaultView || null;\n      else if (targetHost.nodeName === \"#document\")\n        hostWindow = targetHost.defaultView;\n      if (!hostWindow) return;\n      try {\n        newStyleSheet = new hostWindow.CSSStyleSheet();\n        this.styleMirror.add(newStyleSheet, style.styleId);\n        this.applyStyleSheetRule(\n          {\n            source: IncrementalSource.StyleSheetRule,\n            adds: style.rules\n          },\n          newStyleSheet\n        );\n      } catch (e2) {\n      }\n    });\n    const MAX_RETRY_TIME = 10;\n    let count = 0;\n    const adoptStyleSheets = (targetHost2, styleIds) => {\n      const stylesToAdopt = styleIds.map((styleId) => this.styleMirror.getStyle(styleId)).filter((style) => style !== null);\n      if (hasShadowRoot(targetHost2))\n        targetHost2.shadowRoot.adoptedStyleSheets = stylesToAdopt;\n      else if (targetHost2.nodeName === \"#document\")\n        targetHost2.adoptedStyleSheets = stylesToAdopt;\n      if (stylesToAdopt.length !== styleIds.length && count < MAX_RETRY_TIME) {\n        setTimeout$1(\n          () => adoptStyleSheets(targetHost2, styleIds),\n          0 + 100 * count\n        );\n        count++;\n      }\n    };\n    adoptStyleSheets(targetHost, data.styleIds);\n  }\n  legacy_resolveMissingNode(map, parent, target, targetMutation) {\n    const { previousId, nextId } = targetMutation;\n    const previousInMap = previousId && map[previousId];\n    const nextInMap = nextId && map[nextId];\n    if (previousInMap) {\n      const { node, mutation } = previousInMap;\n      parent.insertBefore(node, target);\n      delete map[mutation.node.id];\n      delete this.legacy_missingNodeRetryMap[mutation.node.id];\n      if (mutation.previousId || mutation.nextId) {\n        this.legacy_resolveMissingNode(map, parent, node, mutation);\n      }\n    }\n    if (nextInMap) {\n      const { node, mutation } = nextInMap;\n      parent.insertBefore(\n        node,\n        target.nextSibling\n      );\n      delete map[mutation.node.id];\n      delete this.legacy_missingNodeRetryMap[mutation.node.id];\n      if (mutation.previousId || mutation.nextId) {\n        this.legacy_resolveMissingNode(map, parent, node, mutation);\n      }\n    }\n  }\n  moveAndHover(x, y, id, isSync, debugData, pointerId) {\n    const target = this.mirror.getNode(id);\n    if (!target) {\n      return this.debugNodeNotFound(debugData, id);\n    }\n    const base = getBaseDimension(target, this.iframe);\n    const _x = x * base.absoluteScale + base.x;\n    const _y = y * base.absoluteScale + base.y;\n    const pointer = this.pointers[pointerId];\n    if (pointer && pointer.pointerEl) {\n      pointer.pointerEl.style.left = `${_x}px`;\n      pointer.pointerEl.style.top = `${_y}px`;\n    }\n    if (!isSync) {\n      this.drawMouseTail({ x: _x, y: _y }, pointerId);\n    }\n    this.hoverElements(target);\n  }\n  drawMouseTail(position, pointerId) {\n    const pointer = this.pointers[pointerId];\n    if (!pointer || !pointer.mouseTail) {\n      return;\n    }\n    const { lineCap, lineWidth, strokeStyle, duration } = this.config.mouseTail === true ? defaultMouseTailConfig : Object.assign({}, defaultMouseTailConfig, this.config.mouseTail);\n    const draw = () => {\n      if (!pointer || !pointer.mouseTail) {\n        return;\n      }\n      const mouseTail = pointer.mouseTail;\n      const ctx = mouseTail.getContext(\"2d\");\n      if (!ctx || !pointer.tailPositions.length) {\n        return;\n      }\n      ctx.clearRect(0, 0, mouseTail.width, mouseTail.height);\n      ctx.beginPath();\n      ctx.lineWidth = lineWidth;\n      ctx.lineCap = lineCap;\n      ctx.strokeStyle = strokeStyle;\n      ctx.moveTo(pointer.tailPositions[0].x, pointer.tailPositions[0].y);\n      pointer.tailPositions.forEach((p) => ctx.lineTo(p.x, p.y));\n      ctx.stroke();\n    };\n    pointer.tailPositions.push(position);\n    draw();\n    setTimeout$1(() => {\n      if (pointerId in this.pointers) {\n        pointer.tailPositions = pointer.tailPositions.filter(\n          (p) => p !== position\n        );\n        draw();\n      }\n    }, duration / this.speedService.state.context.timer.speed);\n  }\n  hoverElements(el) {\n    const iframeDoc = getIFrameContentDocument(this.iframe);\n    const rootElement = this.lastHoveredRootNode || iframeDoc;\n    if (rootElement && typeof rootElement.querySelectorAll === \"function\") {\n      rootElement.querySelectorAll(\".\\\\:hover\").forEach((hoveredEl) => {\n        hoveredEl.classList.remove(\":hover\");\n      });\n    }\n    this.lastHoveredRootNode = el.getRootNode();\n    let currentEl = el;\n    while (currentEl) {\n      if (currentEl.classList) {\n        currentEl.classList.add(\":hover\");\n      }\n      currentEl = currentEl.parentElement;\n    }\n  }\n  isUserInteraction(event) {\n    if (event.type !== EventType.IncrementalSnapshot) {\n      return false;\n    }\n    return event.data.source > IncrementalSource.Mutation && event.data.source <= IncrementalSource.Input;\n  }\n  backToNormal() {\n    this.nextUserInteractionEvent = null;\n    if (this.speedService.state.matches(\"normal\")) {\n      return;\n    }\n    this.speedService.send({ type: \"BACK_TO_NORMAL\" });\n    this.emitter.emit(ReplayerEvents.SkipEnd, {\n      speed: this.speedService.state.context.normalSpeed\n    });\n  }\n  warnNodeNotFound(d, id) {\n    this.warn(`Node with id '${id}' not found. `, d);\n  }\n  warnCanvasMutationFailed(d, error) {\n    this.warn(`Has error on canvas update`, error, \"canvas mutation:\", d);\n  }\n  debugNodeNotFound(d, id) {\n    this.debug(`Node with id '${id}' not found. `, d);\n  }\n  warn(...args) {\n    if (!this.config.showWarning) {\n      return;\n    }\n    this.config.logger.warn(REPLAY_CONSOLE_PREFIX, ...args);\n  }\n  debug(...args) {\n    if (!this.config.showDebug) {\n      return;\n    }\n    this.config.logger.log(REPLAY_CONSOLE_PREFIX, ...args);\n  }\n}\nexport {\n  CanvasManager,\n  EventType,\n  IncrementalSource,\n  MouseInteractions,\n  Replayer,\n  ReplayerEvents,\n  addCustomEvent,\n  canvasMutation,\n  deserializeArg,\n  freezePage,\n  record,\n  takeFullSnapshot,\n  utils\n};\n//# sourceMappingURL=rrweb.js.map\n","import type { Integration, IntegrationFn } from '@sentry/core';\nimport { defineIntegration } from '@sentry/core';\nimport type { CanvasManagerInterface, CanvasManagerOptions } from '@sentry-internal/replay';\nimport { CanvasManager } from '@sentry-internal/rrweb';\n\ninterface SnapshotOptions {\n  skipRequestAnimationFrame?: boolean;\n}\n\ninterface ReplayCanvasIntegration extends Integration {\n  snapshot: (canvasElement?: HTMLCanvasElement, options?: SnapshotOptions) => Promise<void>;\n}\n\ninterface ReplayCanvasOptions {\n  enableManualSnapshot?: boolean;\n  maxCanvasSize?: [width: number, height: number];\n  quality: 'low' | 'medium' | 'high';\n}\n\ntype GetCanvasManager = (options: CanvasManagerOptions) => CanvasManagerInterface;\nexport interface ReplayCanvasIntegrationOptions {\n  enableManualSnapshot?: boolean;\n  maxCanvasSize?: number;\n  recordCanvas: true;\n  getCanvasManager: GetCanvasManager;\n  sampling: {\n    canvas: number;\n  };\n  dataURLOptions: {\n    type: string;\n    quality: number;\n  };\n}\n\nconst CANVAS_QUALITY = {\n  low: {\n    sampling: {\n      canvas: 1,\n    },\n    dataURLOptions: {\n      type: 'image/webp',\n      quality: 0.25,\n    },\n  },\n  medium: {\n    sampling: {\n      canvas: 2,\n    },\n    dataURLOptions: {\n      type: 'image/webp',\n      quality: 0.4,\n    },\n  },\n  high: {\n    sampling: {\n      canvas: 4,\n    },\n    dataURLOptions: {\n      type: 'image/webp',\n      quality: 0.5,\n    },\n  },\n};\n\nconst INTEGRATION_NAME = 'ReplayCanvas';\nconst DEFAULT_MAX_CANVAS_SIZE = 1280;\n\n/** Exported only for type safe tests. */\nexport const _replayCanvasIntegration = ((options: Partial<ReplayCanvasOptions> = {}) => {\n  const [maxCanvasWidth, maxCanvasHeight] = options.maxCanvasSize || [];\n  const _canvasOptions = {\n    quality: options.quality || 'medium',\n    enableManualSnapshot: options.enableManualSnapshot,\n    maxCanvasSize: [\n      maxCanvasWidth ? Math.min(maxCanvasWidth, DEFAULT_MAX_CANVAS_SIZE) : DEFAULT_MAX_CANVAS_SIZE,\n      maxCanvasHeight ? Math.min(maxCanvasHeight, DEFAULT_MAX_CANVAS_SIZE) : DEFAULT_MAX_CANVAS_SIZE,\n    ] as [number, number],\n  };\n\n  let canvasManagerResolve: (value: CanvasManager) => void;\n  const _canvasManager: Promise<CanvasManager> = new Promise(resolve => (canvasManagerResolve = resolve));\n\n  return {\n    name: INTEGRATION_NAME,\n    getOptions(): ReplayCanvasIntegrationOptions {\n      const { quality, enableManualSnapshot, maxCanvasSize } = _canvasOptions;\n\n      return {\n        enableManualSnapshot,\n        recordCanvas: true,\n        getCanvasManager: (getCanvasManagerOptions: CanvasManagerOptions) => {\n          const manager = new CanvasManager({\n            ...getCanvasManagerOptions,\n            enableManualSnapshot,\n            maxCanvasSize,\n            errorHandler: (err: unknown) => {\n              try {\n                if (typeof err === 'object') {\n                  (err as Error & { __rrweb__?: boolean }).__rrweb__ = true;\n                }\n              } catch {\n                // ignore errors here\n                // this can happen if the error is frozen or does not allow mutation for other reasons\n              }\n            },\n          });\n          canvasManagerResolve(manager);\n          return manager;\n        },\n        ...(CANVAS_QUALITY[quality || 'medium'] || CANVAS_QUALITY.medium),\n      };\n    },\n    async snapshot(canvasElement?: HTMLCanvasElement, options?: SnapshotOptions) {\n      const canvasManager = await _canvasManager;\n\n      canvasManager.snapshot(canvasElement, options);\n    },\n  };\n}) satisfies IntegrationFn<ReplayCanvasIntegration>;\n\n/**\n * Add this in addition to `replayIntegration()` to enable canvas recording.\n */\nexport const replayCanvasIntegration = defineIntegration(\n  _replayCanvasIntegration,\n) as IntegrationFn<ReplayCanvasIntegration>;\n"],"names":[],"mappings":"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"}}]
}