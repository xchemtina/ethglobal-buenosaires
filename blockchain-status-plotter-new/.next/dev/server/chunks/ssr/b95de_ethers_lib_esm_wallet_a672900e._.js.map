{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/ethers/lib.esm/wallet/mnemonic.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/ethers/src.ts/wallet/mnemonic.ts"],"sourcesContent":["import { pbkdf2, sha256 } from \"../crypto/index.js\";\nimport {\n    defineProperties, getBytes, hexlify, assertNormalize, assertPrivate, assertArgument, toUtf8Bytes\n} from \"../utils/index.js\";\nimport { LangEn } from \"../wordlists/lang-en.js\";\n\nimport type { BytesLike } from \"../utils/index.js\";\nimport type { Wordlist } from \"../wordlists/index.js\";\n\n\n// Returns a byte with the MSB bits set\nfunction getUpperMask(bits: number): number {\n   return ((1 << bits) - 1) << (8 - bits) & 0xff;\n}\n\n// Returns a byte with the LSB bits set\nfunction getLowerMask(bits: number): number {\n   return ((1 << bits) - 1) & 0xff;\n}\n\n\nfunction mnemonicToEntropy(mnemonic: string, wordlist?: null | Wordlist): string {\n    assertNormalize(\"NFKD\");\n\n    if (wordlist == null) { wordlist = LangEn.wordlist(); }\n\n    const words = wordlist.split(mnemonic);\n    assertArgument((words.length % 3) === 0 && words.length >= 12 && words.length <= 24,\n        \"invalid mnemonic length\", \"mnemonic\", \"[ REDACTED ]\");\n\n    const entropy = new Uint8Array(Math.ceil(11 * words.length / 8));\n\n    let offset = 0;\n    for (let i = 0; i < words.length; i++) {\n        let index = wordlist.getWordIndex(words[i].normalize(\"NFKD\"));\n        assertArgument(index >= 0, `invalid mnemonic word at index ${ i }`, \"mnemonic\", \"[ REDACTED ]\");\n\n        for (let bit = 0; bit < 11; bit++) {\n            if (index & (1 << (10 - bit))) {\n                entropy[offset >> 3] |= (1 << (7 - (offset % 8)));\n            }\n            offset++;\n        }\n    }\n\n    const entropyBits = 32 * words.length / 3;\n\n\n    const checksumBits = words.length / 3;\n    const checksumMask = getUpperMask(checksumBits);\n\n    const checksum = getBytes(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n\n    assertArgument(checksum === (entropy[entropy.length - 1] & checksumMask),\n        \"invalid mnemonic checksum\", \"mnemonic\", \"[ REDACTED ]\");\n\n    return hexlify(entropy.slice(0, entropyBits / 8));\n}\n\nfunction entropyToMnemonic(entropy: Uint8Array, wordlist?: null | Wordlist): string {\n\n    assertArgument((entropy.length % 4) === 0 && entropy.length >= 16 && entropy.length <= 32,\n        \"invalid entropy size\", \"entropy\", \"[ REDACTED ]\");\n\n    if (wordlist == null) { wordlist = LangEn.wordlist(); }\n\n    const indices: Array<number> = [ 0 ];\n\n    let remainingBits = 11;\n    for (let i = 0; i < entropy.length; i++) {\n\n        // Consume the whole byte (with still more to go)\n        if (remainingBits > 8) {\n            indices[indices.length - 1] <<= 8;\n            indices[indices.length - 1] |= entropy[i];\n\n            remainingBits -= 8;\n\n        // This byte will complete an 11-bit index\n        } else {\n            indices[indices.length - 1] <<= remainingBits;\n            indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);\n\n            // Start the next word\n            indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n\n            remainingBits += 3;\n        }\n    }\n\n    // Compute the checksum bits\n    const checksumBits = entropy.length / 4;\n    const checksum = parseInt(sha256(entropy).substring(2, 4), 16) & getUpperMask(checksumBits);\n\n    // Shift the checksum into the word indices\n    indices[indices.length - 1] <<= checksumBits;\n    indices[indices.length - 1] |= (checksum >> (8 - checksumBits));\n\n    return wordlist.join(indices.map((index) => (<Wordlist>wordlist).getWord(index)));\n}\n\nconst _guard = { };\n\n/**\n *  A **Mnemonic** wraps all properties required to compute [[link-bip-39]]\n *  seeds and convert between phrases and entropy.\n */\nexport class Mnemonic {\n    /**\n     *  The mnemonic phrase of 12, 15, 18, 21 or 24 words.\n     *\n     *  Use the [[wordlist]] ``split`` method to get the individual words.\n     */\n    readonly phrase!: string;\n\n    /**\n     *  The password used for this mnemonic. If no password is used this\n     *  is the empty string (i.e. ``\"\"``) as per the specification.\n     */\n    readonly password!: string;\n\n    /**\n     *  The wordlist for this mnemonic.\n     */\n    readonly wordlist!: Wordlist;\n\n    /**\n     *  The underlying entropy which the mnemonic encodes.\n     */\n    readonly entropy!: string;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, entropy: string, phrase: string, password?: null | string, wordlist?: null | Wordlist) {\n        if (password == null) { password = \"\"; }\n        if (wordlist == null) { wordlist = LangEn.wordlist(); }\n        assertPrivate(guard, _guard, \"Mnemonic\");\n        defineProperties<Mnemonic>(this, { phrase, password, wordlist, entropy });\n    }\n\n    /**\n     *  Returns the seed for the mnemonic.\n     */\n    computeSeed(): string {\n        const salt = toUtf8Bytes(\"mnemonic\" + this.password, \"NFKD\");\n        return pbkdf2(toUtf8Bytes(this.phrase, \"NFKD\"), salt, 2048, 64, \"sha512\");\n    }\n\n    /**\n     *  Creates a new Mnemonic for the %%phrase%%.\n     *\n     *  The default %%password%% is the empty string and the default\n     *  wordlist is the [English wordlists](LangEn).\n     */\n    static fromPhrase(phrase: string, password?: null | string, wordlist?: null | Wordlist): Mnemonic {\n        // Normalize the case and space; throws if invalid\n        const entropy = mnemonicToEntropy(phrase, wordlist);\n        phrase = entropyToMnemonic(getBytes(entropy), wordlist);\n        return new Mnemonic(_guard, entropy, phrase, password, wordlist);\n    }\n\n    /**\n     *  Create a new **Mnemonic** from the %%entropy%%.\n     *\n     *  The default %%password%% is the empty string and the default\n     *  wordlist is the [English wordlists](LangEn).\n     */\n    static fromEntropy(_entropy: BytesLike, password?: null | string, wordlist?: null | Wordlist): Mnemonic {\n        const entropy = getBytes(_entropy, \"entropy\");\n        const phrase = entropyToMnemonic(entropy, wordlist);\n        return new Mnemonic(_guard, hexlify(entropy), phrase, password, wordlist);\n    }\n\n    /**\n     *  Returns the phrase for %%mnemonic%%.\n     */\n    static entropyToPhrase(_entropy: BytesLike, wordlist?: null | Wordlist): string {\n        const entropy = getBytes(_entropy, \"entropy\");\n        return entropyToMnemonic(entropy, wordlist);\n    }\n\n    /**\n     *  Returns the entropy for %%phrase%%.\n     */\n    static phraseToEntropy(phrase: string, wordlist?: null | Wordlist): string {\n        return mnemonicToEntropy(phrase, wordlist);\n    }\n\n    /**\n     *  Returns true if %%phrase%% is a valid [[link-bip-39]] phrase.\n     *\n     *  This checks all the provided words belong to the %%wordlist%%,\n     *  that the length is valid and the checksum is correct.\n     */\n    static isValidMnemonic(phrase: string, wordlist?: null | Wordlist): boolean {\n        try {\n            mnemonicToEntropy(phrase, wordlist);\n            return true;\n        } catch (error) { }\n        return false;\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 173, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/ethers/lib.esm/wallet/base-wallet.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/ethers/src.ts/wallet/base-wallet.ts"],"sourcesContent":["import { getAddress, resolveAddress } from \"../address/index.js\";\nimport {\n    hashAuthorization, hashMessage, TypedDataEncoder\n} from \"../hash/index.js\";\nimport { AbstractSigner, copyRequest } from \"../providers/index.js\";\nimport { computeAddress, Transaction } from \"../transaction/index.js\";\nimport {\n    defineProperties, getBigInt, resolveProperties, assert, assertArgument\n} from \"../utils/index.js\";\n\nimport type { SigningKey } from \"../crypto/index.js\";\nimport type {\n    AuthorizationRequest, TypedDataDomain, TypedDataField\n} from \"../hash/index.js\";\nimport type { Provider, TransactionRequest } from \"../providers/index.js\";\nimport type { Authorization, TransactionLike } from \"../transaction/index.js\";\n\n\n/**\n *  The **BaseWallet** is a stream-lined implementation of a\n *  [[Signer]] that operates with a private key.\n *\n *  It is preferred to use the [[Wallet]] class, as it offers\n *  additional functionality and simplifies loading a variety\n *  of JSON formats, Mnemonic Phrases, etc.\n *\n *  This class may be of use for those attempting to implement\n *  a minimal Signer.\n */\nexport class BaseWallet extends AbstractSigner {\n    /**\n     *  The wallet address.\n     */\n    readonly address!: string;\n\n    readonly #signingKey: SigningKey;\n\n    /**\n     *  Creates a new BaseWallet for %%privateKey%%, optionally\n     *  connected to %%provider%%.\n     *\n     *  If %%provider%% is not specified, only offline methods can\n     *  be used.\n     */\n    constructor(privateKey: SigningKey, provider?: null | Provider) {\n        super(provider);\n\n        assertArgument(privateKey && typeof(privateKey.sign) === \"function\", \"invalid private key\", \"privateKey\", \"[ REDACTED ]\");\n\n        this.#signingKey = privateKey;\n\n        const address = computeAddress(this.signingKey.publicKey);\n        defineProperties<BaseWallet>(this, { address });\n    }\n\n    // Store private values behind getters to reduce visibility\n    // in console.log\n\n    /**\n     *  The [[SigningKey]] used for signing payloads.\n     */\n    get signingKey(): SigningKey { return this.#signingKey; }\n\n    /**\n     *  The private key for this wallet.\n     */\n    get privateKey(): string { return this.signingKey.privateKey; }\n\n    async getAddress(): Promise<string> { return this.address; }\n\n    connect(provider: null | Provider): BaseWallet {\n        return new BaseWallet(this.#signingKey, provider);\n    }\n\n    async signTransaction(tx: TransactionRequest): Promise<string> {\n        tx = copyRequest(tx);\n\n        // Replace any Addressable or ENS name with an address\n        const { to, from } = await resolveProperties({\n            to: (tx.to ? resolveAddress(tx.to, this): undefined),\n            from: (tx.from ? resolveAddress(tx.from, this): undefined)\n        });\n\n        if (to != null) { tx.to = to; }\n        if (from != null) { tx.from = from; }\n\n        if (tx.from != null) {\n            assertArgument(getAddress(<string>(tx.from)) === this.address,\n                \"transaction from address mismatch\", \"tx.from\", tx.from);\n            delete tx.from;\n        }\n\n        // Build the transaction\n        const btx = Transaction.from(<TransactionLike<string>>tx);\n        btx.signature = this.signingKey.sign(btx.unsignedHash);\n\n        return btx.serialized;\n    }\n\n    async signMessage(message: string | Uint8Array): Promise<string> {\n        return this.signMessageSync(message);\n    }\n\n    // @TODO: Add a secialized signTx and signTyped sync that enforces\n    // all parameters are known?\n    /**\n     *  Returns the signature for %%message%% signed with this wallet.\n     */\n    signMessageSync(message: string | Uint8Array): string {\n        return this.signingKey.sign(hashMessage(message)).serialized;\n    }\n\n    /**\n     *  Returns the Authorization for %%auth%%.\n     */\n    authorizeSync(auth: AuthorizationRequest): Authorization {\n        assertArgument(typeof(auth.address) === \"string\",\n          \"invalid address for authorizeSync\", \"auth.address\", auth);\n\n        const signature = this.signingKey.sign(hashAuthorization(auth));\n        return Object.assign({ }, {\n            address: getAddress(auth.address),\n            nonce: getBigInt(auth.nonce || 0),\n            chainId: getBigInt(auth.chainId || 0),\n        }, { signature });\n    }\n\n    /**\n     *  Resolves to the Authorization for %%auth%%.\n     */\n    async authorize(auth: AuthorizationRequest): Promise<Authorization> {\n        auth = Object.assign({ }, auth, {\n            address: await resolveAddress(auth.address, this)\n        });\n        return this.authorizeSync(await this.populateAuthorization(auth));\n    }\n\n    async signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string> {\n\n        // Populate any ENS names\n        const populated = await TypedDataEncoder.resolveNames(domain, types, value, async (name: string) => {\n            // @TODO: this should use resolveName; addresses don't\n            //        need a provider\n\n            assert(this.provider != null, \"cannot resolve ENS names without a provider\", \"UNSUPPORTED_OPERATION\", {\n                operation: \"resolveName\",\n                info: { name }\n            });\n\n            const address = await this.provider.resolveName(name);\n            assert(address != null, \"unconfigured ENS name\", \"UNCONFIGURED_NAME\", {\n                value: name\n            });\n\n            return address;\n        });\n\n        return this.signingKey.sign(TypedDataEncoder.hash(populated.domain, types, populated.value)).serialized;\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 309, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/ethers/lib.esm/wallet/utils.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/ethers/src.ts/wallet/utils.ts"],"sourcesContent":["/**\n *  @_ignore\n */\n\nimport {\n    getBytesCopy, assertArgument, toUtf8Bytes\n} from \"../utils/index.js\";\n\nexport function looseArrayify(hexString: string): Uint8Array {\n    if (typeof(hexString) === \"string\" && !hexString.startsWith(\"0x\")) {\n        hexString = \"0x\" + hexString;\n    }\n    return getBytesCopy(hexString);\n}\n\nexport function zpad(value: String | number, length: number): String {\n    value = String(value);\n    while (value.length < length) { value = '0' + value; }\n    return value;\n}\n\nexport function getPassword(password: string | Uint8Array): Uint8Array {\n    if (typeof(password) === 'string') {\n        return toUtf8Bytes(password, \"NFKC\");\n    }\n    return getBytesCopy(password);\n}\n\nexport function spelunk<T>(object: any, _path: string): T {\n\n    const match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);\n    assertArgument(match != null, \"invalid path\", \"path\", _path);\n\n    const path = match[1];\n    const type = match[3];\n    const reqd = (match[4] === \"!\");\n\n    let cur = object;\n    for (const comp of path.toLowerCase().split('.')) {\n\n        // Search for a child object with a case-insensitive matching key\n        if (Array.isArray(cur)) {\n            if (!comp.match(/^[0-9]+$/)) { break; }\n            cur = cur[parseInt(comp)];\n\n        } else if (typeof(cur) === \"object\") {\n            let found: any = null;\n            for (const key in cur) {\n                 if (key.toLowerCase() === comp) {\n                     found = cur[key];\n                     break;\n                 }\n            }\n            cur = found;\n\n        } else {\n            cur = null;\n        }\n\n        if (cur == null) { break; }\n    }\n\n    assertArgument(!reqd || cur != null, \"missing required value\", \"path\", path);\n\n    if (type && cur != null) {\n        if (type === \"int\") {\n            if (typeof(cur) === \"string\" && cur.match(/^-?[0-9]+$/)) {\n                return <T><unknown>parseInt(cur);\n            } else if (Number.isSafeInteger(cur)) {\n                return cur;\n            }\n        }\n\n        if (type === \"number\") {\n            if (typeof(cur) === \"string\" && cur.match(/^-?[0-9.]*$/)) {\n                return <T><unknown>parseFloat(cur);\n            }\n        }\n\n        if (type === \"data\") {\n            if (typeof(cur) === \"string\") { return <T><unknown>looseArrayify(cur); }\n        }\n\n        if (type === \"array\" && Array.isArray(cur)) { return <T><unknown>cur; }\n        if (type === typeof(cur)) { return cur; }\n\n        assertArgument(false, `wrong type found for ${ type } `, \"path\", path);\n    }\n\n    return cur;\n}\n/*\nexport function follow(object: any, path: string): null | string {\n    let currentChild = object;\n\n    for (const comp of path.toLowerCase().split('/')) {\n\n        // Search for a child object with a case-insensitive matching key\n        let matchingChild = null;\n        for (const key in currentChild) {\n             if (key.toLowerCase() === comp) {\n                 matchingChild = currentChild[key];\n                 break;\n             }\n        }\n\n        if (matchingChild === null) { return null; }\n\n        currentChild = matchingChild;\n    }\n\n    return currentChild;\n}\n\n// \"path/to/something:type!\"\nexport function followRequired(data: any, path: string): string {\n    const value = follow(data, path);\n    if (value != null) { return value; }\n    return logger.throwArgumentError(\"invalid value\", `data:${ path }`,\n    JSON.stringify(data));\n}\n*/\n// See: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)\n/*\nexport function uuidV4(randomBytes: BytesLike): string {\n    const bytes = getBytes(randomBytes, \"randomBytes\");\n\n    // Section: 4.1.3:\n    // - time_hi_and_version[12:16] = 0b0100\n    bytes[6] = (bytes[6] & 0x0f) | 0x40;\n\n    // Section 4.4\n    // - clock_seq_hi_and_reserved[6] = 0b0\n    // - clock_seq_hi_and_reserved[7] = 0b1\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n\n    const value = hexlify(bytes);\n\n    return [\n       value.substring(2, 10),\n       value.substring(10, 14),\n       value.substring(14, 18),\n       value.substring(18, 22),\n       value.substring(22, 34),\n    ].join(\"-\");\n}\n*/\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 461, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/ethers/lib.esm/wallet/json-keystore.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/ethers/src.ts/wallet/json-keystore.ts"],"sourcesContent":["/**\n *  The JSON Wallet formats allow a simple way to store the private\n *  keys needed in Ethereum along with related information and allows\n *  for extensible forms of encryption.\n *\n *  These utilities facilitate decrypting and encrypting the most common\n *  JSON Wallet formats.\n *\n *  @_subsection: api/wallet:JSON Wallets  [json-wallets]\n */\n\nimport { CTR } from \"aes-js\";\n\nimport { getAddress } from \"../address/index.js\";\nimport { keccak256, pbkdf2, randomBytes, scrypt, scryptSync } from \"../crypto/index.js\";\nimport { computeAddress } from \"../transaction/index.js\";\nimport {\n    concat, getBytes, hexlify, uuidV4, assert, assertArgument\n} from \"../utils/index.js\";\n\nimport { getPassword, spelunk, zpad } from \"./utils.js\";\n\nimport type { ProgressCallback } from \"../crypto/index.js\";\nimport type { BytesLike } from \"../utils/index.js\";\n\nimport { version } from \"../_version.js\";\n\n\nconst defaultPath = \"m/44'/60'/0'/0/0\";\n\n/**\n *  The contents of a JSON Keystore Wallet.\n */\nexport type KeystoreAccount = {\n    address: string;\n    privateKey: string;\n    mnemonic?: {\n        path?: string;\n        locale?: string;\n        entropy: string;\n    }\n};\n\n/**\n *  The parameters to use when encrypting a JSON Keystore Wallet.\n */\nexport type EncryptOptions = {\n   progressCallback?: ProgressCallback;\n   iv?: BytesLike;\n   entropy?: BytesLike;\n   client?: string;\n   salt?: BytesLike;\n   uuid?: string;\n   scrypt?: {\n       N?: number;\n       r?: number;\n       p?: number;\n   }\n}\n\n/**\n *  Returns true if %%json%% is a valid JSON Keystore Wallet.\n */\nexport function isKeystoreJson(json: string): boolean {\n    try {\n        const data = JSON.parse(json);\n        const version = ((data.version != null) ? parseInt(data.version): 0);\n        if (version === 3) { return true; }\n    } catch (error) { }\n    return false;\n}\n\nfunction decrypt(data: any, key: Uint8Array, ciphertext: Uint8Array): string {\n    const cipher = spelunk<string>(data, \"crypto.cipher:string\");\n    if (cipher === \"aes-128-ctr\") {\n        const iv = spelunk<Uint8Array>(data, \"crypto.cipherparams.iv:data!\")\n        const aesCtr = new CTR(key, iv);\n        return hexlify(aesCtr.decrypt(ciphertext));\n    }\n\n    assert(false, \"unsupported cipher\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"decrypt\"\n    });\n}\n\nfunction getAccount(data: any, _key: string): KeystoreAccount {\n    const key = getBytes(_key);\n    const ciphertext = spelunk<Uint8Array>(data, \"crypto.ciphertext:data!\");\n\n    const computedMAC = hexlify(keccak256(concat([ key.slice(16, 32), ciphertext ]))).substring(2);\n    assertArgument(computedMAC === spelunk<string>(data, \"crypto.mac:string!\").toLowerCase(),\n        \"incorrect password\", \"password\", \"[ REDACTED ]\");\n\n    const privateKey = decrypt(data, key.slice(0, 16), ciphertext);\n\n    const address = computeAddress(privateKey);\n    if (data.address) {\n        let check = data.address.toLowerCase();\n        if (!check.startsWith(\"0x\")) { check = \"0x\" + check; }\n\n        assertArgument(getAddress(check) === address, \"keystore address/privateKey mismatch\", \"address\", data.address);\n    }\n\n    const account: KeystoreAccount = { address, privateKey };\n\n    // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase\n    const version = spelunk(data, \"x-ethers.version:string\");\n    if (version === \"0.1\") {\n        const mnemonicKey = key.slice(32, 64);\n\n        const mnemonicCiphertext = spelunk<Uint8Array>(data, \"x-ethers.mnemonicCiphertext:data!\");\n        const mnemonicIv = spelunk<Uint8Array>(data, \"x-ethers.mnemonicCounter:data!\");\n\n        const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);\n\n        account.mnemonic = {\n            path: (spelunk<null | string>(data, \"x-ethers.path:string\") || defaultPath),\n            locale: (spelunk<null | string>(data, \"x-ethers.locale:string\") || \"en\"),\n            entropy: hexlify(getBytes(mnemonicAesCtr.decrypt(mnemonicCiphertext)))\n        };\n    }\n\n    return account;\n}\n\ntype ScryptParams = {\n    name: \"scrypt\";\n    salt: Uint8Array;\n    N: number;\n    r: number;\n    p: number;\n    dkLen: number;\n};\n\ntype KdfParams = ScryptParams | {\n    name: \"pbkdf2\";\n    salt: Uint8Array;\n    count: number;\n    dkLen: number;\n    algorithm: \"sha256\" | \"sha512\";\n};\n\nfunction getDecryptKdfParams<T>(data: any): KdfParams {\n    const kdf = spelunk(data, \"crypto.kdf:string\");\n    if (kdf && typeof(kdf) === \"string\") {\n        if (kdf.toLowerCase() === \"scrypt\") {\n            const salt = spelunk<Uint8Array>(data, \"crypto.kdfparams.salt:data!\");\n            const N = spelunk<number>(data, \"crypto.kdfparams.n:int!\");\n            const r = spelunk<number>(data, \"crypto.kdfparams.r:int!\");\n            const p = spelunk<number>(data, \"crypto.kdfparams.p:int!\");\n\n            // Make sure N is a power of 2\n            assertArgument(N > 0 && (N & (N - 1)) === 0, \"invalid kdf.N\", \"kdf.N\", N);\n            assertArgument(r > 0 && p > 0, \"invalid kdf\", \"kdf\", kdf);\n\n            const dkLen = spelunk<number>(data, \"crypto.kdfparams.dklen:int!\");\n            assertArgument(dkLen === 32, \"invalid kdf.dklen\", \"kdf.dflen\", dkLen);\n\n            return { name: \"scrypt\", salt, N, r, p, dkLen: 64 };\n\n        } else if (kdf.toLowerCase() === \"pbkdf2\") {\n\n            const salt = spelunk<Uint8Array>(data, \"crypto.kdfparams.salt:data!\");\n\n            const prf = spelunk<string>(data, \"crypto.kdfparams.prf:string!\");\n            const algorithm = prf.split(\"-\").pop();\n            assertArgument(algorithm === \"sha256\" || algorithm === \"sha512\", \"invalid kdf.pdf\", \"kdf.pdf\", prf);\n\n            const count = spelunk<number>(data, \"crypto.kdfparams.c:int!\");\n\n            const dkLen = spelunk<number>(data, \"crypto.kdfparams.dklen:int!\");\n            assertArgument(dkLen === 32, \"invalid kdf.dklen\", \"kdf.dklen\", dkLen);\n\n            return { name: \"pbkdf2\", salt, count, dkLen, algorithm };\n        }\n    }\n\n    assertArgument(false, \"unsupported key-derivation function\", \"kdf\", kdf);\n}\n\n\n/**\n *  Returns the account details for the JSON Keystore Wallet %%json%%\n *  using %%password%%.\n *\n *  It is preferred to use the [async version](decryptKeystoreJson)\n *  instead, which allows a [[ProgressCallback]] to keep the user informed\n *  as to the decryption status.\n *\n *  This method will block the event loop (freezing all UI) until decryption\n *  is complete, which can take quite some time, depending on the wallet\n *  paramters and platform.\n */\nexport function decryptKeystoreJsonSync(json: string, _password: string | Uint8Array): KeystoreAccount {\n    const data = JSON.parse(json);\n\n    const password = getPassword(_password);\n\n    const params = getDecryptKdfParams(data);\n    if (params.name === \"pbkdf2\") {\n        const { salt, count, dkLen, algorithm } = params;\n        const key = pbkdf2(password, salt, count, dkLen, algorithm);\n        return getAccount(data, key);\n    }\n\n    assert(params.name === \"scrypt\", \"cannot be reached\", \"UNKNOWN_ERROR\", { params })\n\n    const { salt, N, r, p, dkLen } = params;\n    const key = scryptSync(password, salt, N, r, p, dkLen);\n    return getAccount(data, key);\n}\n\nfunction stall(duration: number): Promise<void> {\n    return new Promise((resolve) => { setTimeout(() => { resolve(); }, duration); });\n}\n\n/**\n *  Resolves to the decrypted JSON Keystore Wallet %%json%% using the\n *  %%password%%.\n *\n *  If provided, %%progress%% will be called periodically during the\n *  decrpytion to provide feedback, and if the function returns\n *  ``false`` will halt decryption.\n *\n *  The %%progressCallback%% will **always** receive ``0`` before\n *  decryption begins and ``1`` when complete.\n */\nexport async function decryptKeystoreJson(json: string, _password: string | Uint8Array, progress?: ProgressCallback): Promise<KeystoreAccount> {\n    const data = JSON.parse(json);\n\n    const password = getPassword(_password);\n\n    const params = getDecryptKdfParams(data);\n    if (params.name === \"pbkdf2\") {\n        if (progress) {\n            progress(0);\n            await stall(0);\n        }\n        const { salt, count, dkLen, algorithm } = params;\n        const key = pbkdf2(password, salt, count, dkLen, algorithm);\n        if (progress) {\n            progress(1);\n            await stall(0);\n        }\n        return getAccount(data, key);\n    }\n\n    assert(params.name === \"scrypt\", \"cannot be reached\", \"UNKNOWN_ERROR\", { params })\n\n    const { salt, N, r, p, dkLen } = params;\n    const key = await scrypt(password, salt, N, r, p, dkLen, progress);\n    return getAccount(data, key);\n}\n\nfunction getEncryptKdfParams(options: EncryptOptions): ScryptParams {\n    // Check/generate the salt\n    const salt = (options.salt != null) ? getBytes(options.salt, \"options.salt\"): randomBytes(32);\n\n    // Override the scrypt password-based key derivation function parameters\n    let N = (1 << 17), r = 8, p = 1;\n    if (options.scrypt) {\n        if (options.scrypt.N) { N = options.scrypt.N; }\n        if (options.scrypt.r) { r = options.scrypt.r; }\n        if (options.scrypt.p) { p = options.scrypt.p; }\n    }\n    assertArgument(typeof(N) === \"number\" && N > 0 && Number.isSafeInteger(N) && (BigInt(N) & BigInt(N - 1)) === BigInt(0), \"invalid scrypt N parameter\", \"options.N\", N);\n    assertArgument(typeof(r) === \"number\" && r > 0 && Number.isSafeInteger(r), \"invalid scrypt r parameter\", \"options.r\", r);\n    assertArgument(typeof(p) === \"number\" && p > 0 && Number.isSafeInteger(p), \"invalid scrypt p parameter\", \"options.p\", p);\n\n    return { name: \"scrypt\", dkLen: 32, salt, N, r, p };\n}\n\nfunction _encryptKeystore(key: Uint8Array, kdf: ScryptParams, account: KeystoreAccount, options: EncryptOptions): any {\n\n    const privateKey = getBytes(account.privateKey, \"privateKey\");\n\n    // Override initialization vector\n    const iv = (options.iv != null) ? getBytes(options.iv, \"options.iv\"): randomBytes(16);\n    assertArgument(iv.length === 16, \"invalid options.iv length\", \"options.iv\", options.iv);\n\n    // Override the uuid\n    const uuidRandom = (options.uuid != null) ? getBytes(options.uuid, \"options.uuid\"): randomBytes(16);\n    assertArgument(uuidRandom.length === 16, \"invalid options.uuid length\", \"options.uuid\", options.iv);\n\n    // This will be used to encrypt the wallet (as per Web3 secret storage)\n    // - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)\n    // - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)\n    const derivedKey = key.slice(0, 16);\n    const macPrefix = key.slice(16, 32);\n\n    // Encrypt the private key\n    const aesCtr = new CTR(derivedKey, iv);\n    const ciphertext = getBytes(aesCtr.encrypt(privateKey));\n\n    // Compute the message authentication code, used to check the password\n    const mac = keccak256(concat([ macPrefix, ciphertext ]))\n\n    // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\n    const data: { [key: string]: any } = {\n        address: account.address.substring(2).toLowerCase(),\n        id: uuidV4(uuidRandom),\n        version: 3,\n        Crypto: {\n            cipher: \"aes-128-ctr\",\n            cipherparams: {\n                iv: hexlify(iv).substring(2),\n            },\n            ciphertext: hexlify(ciphertext).substring(2),\n            kdf: \"scrypt\",\n            kdfparams: {\n                salt: hexlify(kdf.salt).substring(2),\n                n: kdf.N,\n                dklen: 32,\n                p: kdf.p,\n                r: kdf.r\n            },\n            mac: mac.substring(2)\n        }\n    };\n\n    // If we have a mnemonic, encrypt it into the JSON wallet\n    if (account.mnemonic) {\n        const client = (options.client != null) ? options.client: `ethers/${ version }`;\n\n        const path = account.mnemonic.path || defaultPath;\n        const locale = account.mnemonic.locale || \"en\";\n\n        const mnemonicKey = key.slice(32, 64);\n\n        const entropy = getBytes(account.mnemonic.entropy, \"account.mnemonic.entropy\");\n        const mnemonicIv = randomBytes(16);\n        const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);\n        const mnemonicCiphertext = getBytes(mnemonicAesCtr.encrypt(entropy));\n\n        const now = new Date();\n        const timestamp = (now.getUTCFullYear() + \"-\" +\n                           zpad(now.getUTCMonth() + 1, 2) + \"-\" +\n                           zpad(now.getUTCDate(), 2) + \"T\" +\n                           zpad(now.getUTCHours(), 2) + \"-\" +\n                           zpad(now.getUTCMinutes(), 2) + \"-\" +\n                           zpad(now.getUTCSeconds(), 2) + \".0Z\");\n        const gethFilename = (\"UTC--\" + timestamp + \"--\" + data.address);\n\n        data[\"x-ethers\"] = {\n            client, gethFilename, path, locale,\n            mnemonicCounter: hexlify(mnemonicIv).substring(2),\n            mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),\n            version: \"0.1\"\n        };\n    }\n\n    return JSON.stringify(data);\n}\n\n/**\n *  Return the JSON Keystore Wallet for %%account%% encrypted with\n *  %%password%%.\n *\n *  The %%options%% can be used to tune the password-based key\n *  derivation function parameters, explicitly set the random values\n *  used. Any provided [[ProgressCallback]] is ignord.\n */\nexport function encryptKeystoreJsonSync(account: KeystoreAccount, password: string | Uint8Array, options?: EncryptOptions): string {\n    if (options == null) { options = { }; }\n\n    const passwordBytes = getPassword(password);\n    const kdf = getEncryptKdfParams(options);\n    const key = scryptSync(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64);\n    return _encryptKeystore(getBytes(key), kdf, account, options);\n}\n\n/**\n *  Resolved to the JSON Keystore Wallet for %%account%% encrypted\n *  with %%password%%.\n *\n *  The %%options%% can be used to tune the password-based key\n *  derivation function parameters, explicitly set the random values\n *  used and provide a [[ProgressCallback]] to receive periodic updates\n *  on the completion status..\n */\nexport async function encryptKeystoreJson(account: KeystoreAccount, password: string | Uint8Array, options?: EncryptOptions): Promise<string> {\n    if (options == null) { options = { }; }\n\n    const passwordBytes = getPassword(password);\n    const kdf = getEncryptKdfParams(options);\n    const key = await scrypt(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64, options.progressCallback);\n    return _encryptKeystore(getBytes(key), kdf, account, options);\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 765, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/ethers/lib.esm/wallet/hdwallet.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/ethers/src.ts/wallet/hdwallet.ts"],"sourcesContent":["/**\n *  Explain HD Wallets..\n *\n *  @_subsection: api/wallet:HD Wallets  [hd-wallets]\n */\nimport { computeHmac, randomBytes, ripemd160, SigningKey, sha256 } from \"../crypto/index.js\";\nimport { VoidSigner } from \"../providers/index.js\";\nimport { computeAddress } from \"../transaction/index.js\";\nimport {\n    concat, dataSlice, decodeBase58, defineProperties, encodeBase58,\n    getBytes, hexlify, isBytesLike,\n    getNumber, toBeArray, toBigInt, toBeHex,\n    assertPrivate, assert, assertArgument\n} from \"../utils/index.js\";\nimport { LangEn } from \"../wordlists/lang-en.js\";\n\nimport { BaseWallet } from \"./base-wallet.js\";\nimport { Mnemonic } from \"./mnemonic.js\";\nimport {\n    encryptKeystoreJson, encryptKeystoreJsonSync,\n} from \"./json-keystore.js\";\n\nimport type { ProgressCallback } from \"../crypto/index.js\";\nimport type { Provider } from \"../providers/index.js\";\nimport type { BytesLike, Numeric } from \"../utils/index.js\";\nimport type { Wordlist } from \"../wordlists/index.js\";\n\nimport type { KeystoreAccount } from \"./json-keystore.js\";\n\n/**\n *  The default derivation path for Ethereum HD Nodes. (i.e. ``\"m/44'/60'/0'/0/0\"``)\n */\nexport const defaultPath: string = \"m/44'/60'/0'/0/0\";\n\n\n// \"Bitcoin seed\"\nconst MasterSecret = new Uint8Array([ 66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100 ]);\n\nconst HardenedBit = 0x80000000;\n\nconst N = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\n\nconst Nibbles = \"0123456789abcdef\";\nfunction zpad(value: number, length: number): string {\n    let result = \"\";\n    while (value) {\n        result = Nibbles[value % 16] + result;\n        value = Math.trunc(value / 16);\n    }\n    while (result.length < length * 2) { result = \"0\" + result; }\n    return \"0x\" + result;\n}\n\nfunction encodeBase58Check(_value: BytesLike): string {\n    const value = getBytes(_value);\n    const check = dataSlice(sha256(sha256(value)), 0, 4);\n    const bytes = concat([ value, check ]);\n    return encodeBase58(bytes);\n}\n\nconst _guard = { };\n\nfunction ser_I(index: number, chainCode: string, publicKey: string, privateKey: null | string): { IL: Uint8Array, IR: Uint8Array } {\n    const data = new Uint8Array(37);\n\n    if (index & HardenedBit) {\n        assert(privateKey != null, \"cannot derive child of neutered node\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"deriveChild\"\n        });\n\n        // Data = 0x00 || ser_256(k_par)\n        data.set(getBytes(privateKey), 1);\n\n    } else {\n        // Data = ser_p(point(k_par))\n        data.set(getBytes(publicKey));\n    }\n\n    // Data += ser_32(i)\n    for (let i = 24; i >= 0; i -= 8) { data[33 + (i >> 3)] = ((index >> (24 - i)) & 0xff); }\n    const I = getBytes(computeHmac(\"sha512\", chainCode, data));\n\n    return { IL: I.slice(0, 32), IR: I.slice(32) };\n}\n\ntype HDNodeLike<T> = { depth: number, deriveChild: (i: number) => T };\nfunction derivePath<T extends HDNodeLike<T>>(node: T, path: string): T {\n    const components = path.split(\"/\");\n\n    assertArgument(components.length > 0, \"invalid path\", \"path\", path);\n\n    if (components[0] === \"m\") {\n        assertArgument(node.depth === 0, `cannot derive root path (i.e. path starting with \"m/\") for a node at non-zero depth ${ node.depth }`, \"path\", path);\n        components.shift();\n    }\n\n    let result: T = node;\n    for (let i = 0; i < components.length; i++) {\n        const component = components[i];\n\n        if (component.match(/^[0-9]+'$/)) {\n            const index = parseInt(component.substring(0, component.length - 1));\n            assertArgument(index < HardenedBit, \"invalid path index\", `path[${ i }]`, component);\n            result = result.deriveChild(HardenedBit + index);\n\n        } else if (component.match(/^[0-9]+$/)) {\n            const index = parseInt(component);\n            assertArgument(index < HardenedBit, \"invalid path index\", `path[${ i }]`, component);\n            result = result.deriveChild(index);\n\n        } else {\n            assertArgument(false, \"invalid path component\", `path[${ i }]`, component);\n        }\n    }\n\n    return result;\n}\n\n/**\n *  An **HDNodeWallet** is a [[Signer]] backed by the private key derived\n *  from an HD Node using the [[link-bip-32]] stantard.\n *\n *  An HD Node forms a hierarchal structure with each HD Node having a\n *  private key and the ability to derive child HD Nodes, defined by\n *  a path indicating the index of each child.\n */\nexport class HDNodeWallet extends BaseWallet {\n    /**\n     *  The compressed public key.\n     */\n    readonly publicKey!: string;\n\n    /**\n     *  The fingerprint.\n     *\n     *  A fingerprint allows quick qay to detect parent and child nodes,\n     *  but developers should be prepared to deal with collisions as it\n     *  is only 4 bytes.\n     */\n    readonly fingerprint!: string;\n\n    /**\n     *  The parent fingerprint.\n     */\n    readonly parentFingerprint!: string;\n\n    /**\n     *  The mnemonic used to create this HD Node, if available.\n     *\n     *  Sources such as extended keys do not encode the mnemonic, in\n     *  which case this will be ``null``.\n     */\n    readonly mnemonic!: null | Mnemonic;\n\n    /**\n     *  The chaincode, which is effectively a public key used\n     *  to derive children.\n     */\n    readonly chainCode!: string;\n\n    /**\n     *  The derivation path of this wallet.\n     *\n     *  Since extended keys do not provide full path details, this\n     *  may be ``null``, if instantiated from a source that does not\n     *  encode it.\n     */\n    readonly path!: null | string;\n\n    /**\n     *  The child index of this wallet. Values over ``2 *\\* 31`` indicate\n     *  the node is hardened.\n     */\n    readonly index!: number;\n\n    /**\n     *  The depth of this wallet, which is the number of components\n     *  in its path.\n     */\n    readonly depth!: number;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, signingKey: SigningKey, parentFingerprint: string, chainCode: string, path: null | string, index: number, depth: number, mnemonic: null | Mnemonic, provider: null | Provider) {\n        super(signingKey, provider);\n        assertPrivate(guard, _guard, \"HDNodeWallet\");\n\n        defineProperties<HDNodeWallet>(this, { publicKey: signingKey.compressedPublicKey });\n\n        const fingerprint = dataSlice(ripemd160(sha256(this.publicKey)), 0, 4);\n        defineProperties<HDNodeWallet>(this, {\n            parentFingerprint, fingerprint,\n            chainCode, path, index, depth\n        });\n\n        defineProperties<HDNodeWallet>(this, { mnemonic });\n    }\n\n    connect(provider: null | Provider): HDNodeWallet {\n        return new HDNodeWallet(_guard, this.signingKey, this.parentFingerprint,\n            this.chainCode, this.path, this.index, this.depth, this.mnemonic, provider);\n    }\n\n    #account(): KeystoreAccount {\n        const account: KeystoreAccount = { address: this.address, privateKey: this.privateKey };\n        const m = this.mnemonic;\n        if (this.path && m && m.wordlist.locale === \"en\" && m.password === \"\") {\n            account.mnemonic = {\n                path: this.path,\n                locale: \"en\",\n                entropy: m.entropy\n            };\n        }\n\n        return account;\n    }\n\n    /**\n     *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with\n     *  %%password%%.\n     *\n     *  If %%progressCallback%% is specified, it will receive periodic\n     *  updates as the encryption process progreses.\n     */\n    async encrypt(password: Uint8Array | string, progressCallback?: ProgressCallback): Promise<string> {\n        return await encryptKeystoreJson(this.#account(), password, { progressCallback });\n    }\n\n    /**\n     *  Returns a [JSON Keystore Wallet](json-wallets) encryped with\n     *  %%password%%.\n     *\n     *  It is preferred to use the [async version](encrypt) instead,\n     *  which allows a [[ProgressCallback]] to keep the user informed.\n     *\n     *  This method will block the event loop (freezing all UI) until\n     *  it is complete, which may be a non-trivial duration.\n     */\n    encryptSync(password: Uint8Array | string): string {\n        return encryptKeystoreJsonSync(this.#account(), password);\n    }\n\n    /**\n     *  The extended key.\n     *\n     *  This key will begin with the prefix ``xpriv`` and can be used to\n     *  reconstruct this HD Node to derive its children.\n     */\n    get extendedKey(): string {\n        // We only support the mainnet values for now, but if anyone needs\n        // testnet values, let me know. I believe current sentiment is that\n        // we should always use mainnet, and use BIP-44 to derive the network\n        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n        //   - Testnet: public=0x043587CF, private=0x04358394\n\n        assert(this.depth < 256, \"Depth too deep\", \"UNSUPPORTED_OPERATION\", { operation: \"extendedKey\" });\n\n        return encodeBase58Check(concat([\n            \"0x0488ADE4\", zpad(this.depth, 1), this.parentFingerprint,\n            zpad(this.index, 4), this.chainCode,\n            concat([ \"0x00\", this.privateKey ])\n        ]));\n    }\n\n    /**\n     *  Returns true if this wallet has a path, providing a Type Guard\n     *  that the path is non-null.\n     */\n    hasPath(): this is { path: string } { return (this.path != null); }\n\n    /**\n     *  Returns a neutered HD Node, which removes the private details\n     *  of an HD Node.\n     *\n     *  A neutered node has no private key, but can be used to derive\n     *  child addresses and other public data about the HD Node.\n     */\n    neuter(): HDNodeVoidWallet {\n        return new HDNodeVoidWallet(_guard, this.address, this.publicKey,\n            this.parentFingerprint, this.chainCode, this.path, this.index,\n            this.depth, this.provider);\n    }\n\n    /**\n     *  Return the child for %%index%%.\n     */\n    deriveChild(_index: Numeric): HDNodeWallet {\n        const index = getNumber(_index, \"index\");\n        assertArgument(index <= 0xffffffff, \"invalid index\", \"index\", index);\n\n        // Base path\n        let path = this.path;\n        if (path) {\n            path += \"/\" + (index & ~HardenedBit);\n            if (index & HardenedBit) { path += \"'\"; }\n        }\n\n        const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, this.privateKey);\n        const ki = new SigningKey(toBeHex((toBigInt(IL) + BigInt(this.privateKey)) % N, 32));\n\n        return new HDNodeWallet(_guard, ki, this.fingerprint, hexlify(IR),\n            path, index, this.depth + 1, this.mnemonic, this.provider);\n\n    }\n\n    /**\n     *  Return the HDNode for %%path%% from this node.\n     */\n    derivePath(path: string): HDNodeWallet {\n        return derivePath<HDNodeWallet>(this, path);\n    }\n\n    static #fromSeed(_seed: BytesLike, mnemonic: null | Mnemonic): HDNodeWallet {\n        assertArgument(isBytesLike(_seed), \"invalid seed\", \"seed\", \"[REDACTED]\");\n\n        const seed = getBytes(_seed, \"seed\");\n        assertArgument(seed.length >= 16 && seed.length <= 64 , \"invalid seed\", \"seed\", \"[REDACTED]\");\n\n        const I = getBytes(computeHmac(\"sha512\", MasterSecret, seed));\n        const signingKey = new SigningKey(hexlify(I.slice(0, 32)));\n\n        return new HDNodeWallet(_guard, signingKey, \"0x00000000\", hexlify(I.slice(32)),\n            \"m\", 0, 0, mnemonic, null);\n    }\n\n    /**\n     *  Creates a new HD Node from %%extendedKey%%.\n     *\n     *  If the %%extendedKey%% will either have a prefix or ``xpub`` or\n     *  ``xpriv``, returning a neutered HD Node ([[HDNodeVoidWallet]])\n     *  or full HD Node ([[HDNodeWallet) respectively.\n     */\n    static fromExtendedKey(extendedKey: string): HDNodeWallet | HDNodeVoidWallet {\n        const bytes = toBeArray(decodeBase58(extendedKey)); // @TODO: redact\n\n        assertArgument(bytes.length === 82 || encodeBase58Check(bytes.slice(0, 78)) === extendedKey,\n            \"invalid extended key\", \"extendedKey\", \"[ REDACTED ]\");\n\n        const depth = bytes[4];\n        const parentFingerprint = hexlify(bytes.slice(5, 9));\n        const index = parseInt(hexlify(bytes.slice(9, 13)).substring(2), 16);\n        const chainCode = hexlify(bytes.slice(13, 45));\n        const key = bytes.slice(45, 78);\n\n        switch (hexlify(bytes.slice(0, 4))) {\n            // Public Key\n            case \"0x0488b21e\": case \"0x043587cf\": {\n                const publicKey = hexlify(key);\n                return new HDNodeVoidWallet(_guard, computeAddress(publicKey), publicKey,\n                    parentFingerprint, chainCode, null, index, depth, null);\n            }\n\n            // Private Key\n            case \"0x0488ade4\": case \"0x04358394 \":\n                if (key[0] !== 0) { break; }\n                return new HDNodeWallet(_guard, new SigningKey(key.slice(1)),\n                    parentFingerprint, chainCode, null, index, depth, null, null);\n        }\n\n\n        assertArgument(false, \"invalid extended key prefix\", \"extendedKey\", \"[ REDACTED ]\");\n    }\n\n    /**\n     *  Creates a new random HDNode.\n     */\n    static createRandom(password?: string, path?: string, wordlist?: Wordlist): HDNodeWallet {\n        if (password == null) { password = \"\"; }\n        if (path == null) { path = defaultPath; }\n        if (wordlist == null) { wordlist = LangEn.wordlist(); }\n        const mnemonic = Mnemonic.fromEntropy(randomBytes(16), password, wordlist)\n        return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);\n    }\n\n    /**\n     *  Create an HD Node from %%mnemonic%%.\n     */\n    static fromMnemonic(mnemonic: Mnemonic, path?: string): HDNodeWallet {\n        if (!path) { path = defaultPath; }\n        return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);\n    }\n\n    /**\n     *  Creates an HD Node from a mnemonic %%phrase%%.\n     */\n    static fromPhrase(phrase: string, password?: string, path?: string, wordlist?: Wordlist): HDNodeWallet {\n        if (password == null) { password = \"\"; }\n        if (path == null) { path = defaultPath; }\n        if (wordlist == null) { wordlist = LangEn.wordlist(); }\n        const mnemonic = Mnemonic.fromPhrase(phrase, password, wordlist)\n        return HDNodeWallet.#fromSeed(mnemonic.computeSeed(), mnemonic).derivePath(path);\n    }\n\n    /**\n     *  Creates an HD Node from a %%seed%%.\n     */\n    static fromSeed(seed: BytesLike): HDNodeWallet {\n        return HDNodeWallet.#fromSeed(seed, null);\n    }\n}\n\n/**\n *  A **HDNodeVoidWallet** cannot sign, but provides access to\n *  the children nodes of a [[link-bip-32]] HD wallet addresses.\n *\n *  The can be created by using an extended ``xpub`` key to\n *  [[HDNodeWallet_fromExtendedKey]] or by \n *  [nuetering](HDNodeWallet-neuter) a [[HDNodeWallet]].\n */\nexport class HDNodeVoidWallet extends VoidSigner {\n    /**\n     *  The compressed public key.\n     */\n    readonly publicKey!: string;\n\n    /**\n     *  The fingerprint.\n     *\n     *  A fingerprint allows quick qay to detect parent and child nodes,\n     *  but developers should be prepared to deal with collisions as it\n     *  is only 4 bytes.\n     */\n    readonly fingerprint!: string;\n\n    /**\n     *  The parent node fingerprint.\n     */\n    readonly parentFingerprint!: string;\n\n    /**\n     *  The chaincode, which is effectively a public key used\n     *  to derive children.\n     */\n    readonly chainCode!: string;\n\n    /**\n     *  The derivation path of this wallet.\n     *\n     *  Since extended keys do not provider full path details, this\n     *  may be ``null``, if instantiated from a source that does not\n     *  enocde it.\n     */\n    readonly path!: null | string;\n\n    /**\n     *  The child index of this wallet. Values over ``2 *\\* 31`` indicate\n     *  the node is hardened.\n     */\n    readonly index!: number;\n\n    /**\n     *  The depth of this wallet, which is the number of components\n     *  in its path.\n     */\n    readonly depth!: number;\n\n    /**\n     *  @private\n     */\n    constructor(guard: any, address: string, publicKey: string, parentFingerprint: string, chainCode: string, path: null | string, index: number, depth: number, provider: null | Provider) {\n        super(address, provider);\n        assertPrivate(guard, _guard, \"HDNodeVoidWallet\");\n\n        defineProperties<HDNodeVoidWallet>(this, { publicKey });\n\n        const fingerprint = dataSlice(ripemd160(sha256(publicKey)), 0, 4);\n        defineProperties<HDNodeVoidWallet>(this, {\n            publicKey, fingerprint, parentFingerprint, chainCode, path, index, depth\n        });\n    }\n\n    connect(provider: null | Provider): HDNodeVoidWallet {\n        return new HDNodeVoidWallet(_guard, this.address, this.publicKey,\n            this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, provider);\n    }\n\n    /**\n     *  The extended key.\n     *\n     *  This key will begin with the prefix ``xpub`` and can be used to\n     *  reconstruct this neutered key to derive its children addresses.\n     */\n    get extendedKey(): string {\n        // We only support the mainnet values for now, but if anyone needs\n        // testnet values, let me know. I believe current sentiment is that\n        // we should always use mainnet, and use BIP-44 to derive the network\n        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n        //   - Testnet: public=0x043587CF, private=0x04358394\n\n        assert(this.depth < 256, \"Depth too deep\", \"UNSUPPORTED_OPERATION\", { operation: \"extendedKey\" });\n\n        return encodeBase58Check(concat([\n            \"0x0488B21E\",\n            zpad(this.depth, 1),\n            this.parentFingerprint,\n            zpad(this.index, 4),\n            this.chainCode,\n            this.publicKey,\n        ]));\n    }\n\n    /**\n     *  Returns true if this wallet has a path, providing a Type Guard\n     *  that the path is non-null.\n     */\n    hasPath(): this is { path: string } { return (this.path != null); }\n\n    /**\n     *  Return the child for %%index%%.\n     */\n    deriveChild(_index: Numeric): HDNodeVoidWallet {\n        const index = getNumber(_index, \"index\");\n        assertArgument(index <= 0xffffffff, \"invalid index\", \"index\", index);\n\n        // Base path\n        let path = this.path;\n        if (path) {\n            path += \"/\" + (index & ~HardenedBit);\n            if (index & HardenedBit) { path += \"'\"; }\n        }\n\n        const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, null);\n        const Ki = SigningKey.addPoints(IL, this.publicKey, true);\n\n        const address = computeAddress(Ki);\n\n        return new HDNodeVoidWallet(_guard, address, Ki, this.fingerprint, hexlify(IR),\n            path, index, this.depth + 1, this.provider);\n\n    }\n\n    /**\n     *  Return the signer for %%path%% from this node.\n     */\n    derivePath(path: string): HDNodeVoidWallet {\n        return derivePath<HDNodeVoidWallet>(this, path);\n    }\n}\n\n/*\nexport class HDNodeWalletManager {\n    #root: HDNodeWallet;\n\n    constructor(phrase: string, password?: null | string, path?: null | string, locale?: null | Wordlist) {\n        if (password == null) { password = \"\"; }\n        if (path == null) { path = \"m/44'/60'/0'/0\"; }\n        if (locale == null) { locale = LangEn.wordlist(); }\n        this.#root = HDNodeWallet.fromPhrase(phrase, password, path, locale);\n    }\n\n    getSigner(index?: number): HDNodeWallet {\n        return this.#root.deriveChild((index == null) ? 0: index);\n    }\n}\n*/\n\n/**\n *  Returns the [[link-bip-32]] path for the account at %%index%%.\n *\n *  This is the pattern used by wallets like Ledger.\n *\n *  There is also an [alternate pattern](getIndexedAccountPath) used by\n *  some software.\n */\nexport function getAccountPath(_index: Numeric): string {\n    const index = getNumber(_index, \"index\");\n    assertArgument(index >= 0 && index < HardenedBit, \"invalid account index\", \"index\", index);\n    return `m/44'/60'/${ index }'/0/0`;\n}\n\n/**\n *  Returns the path using an alternative pattern for deriving accounts,\n *  at %%index%%.\n *\n *  This derivation path uses the //index// component rather than the\n *  //account// component to derive sequential accounts.\n *\n *  This is the pattern used by wallets like MetaMask.\n */\nexport function getIndexedAccountPath(_index: Numeric): string {\n    const index = getNumber(_index, \"index\");\n    assertArgument(index >= 0 && index < HardenedBit, \"invalid account index\", \"index\", index);\n    return `m/44'/60'/0'/0/${ index}`;\n}\n\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1261, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/ethers/lib.esm/wallet/json-crowdsale.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/ethers/src.ts/wallet/json-crowdsale.ts"],"sourcesContent":["/**\n *  @_subsection: api/wallet:JSON Wallets  [json-wallets]\n */\n\nimport { CBC, pkcs7Strip } from \"aes-js\";\n\nimport { getAddress } from \"../address/index.js\";\nimport { pbkdf2 } from \"../crypto/index.js\";\nimport { id } from \"../hash/index.js\";\nimport { getBytes, assertArgument } from \"../utils/index.js\";\n\nimport { getPassword, looseArrayify, spelunk } from \"./utils.js\";\n\n\n/**\n *  The data stored within a JSON Crowdsale wallet is fairly\n *  minimal.\n */\nexport type CrowdsaleAccount = {\n    privateKey: string;\n    address: string;\n}\n\n/**\n *  Returns true if %%json%% is a valid JSON Crowdsale wallet.\n */\nexport function isCrowdsaleJson(json: string): boolean {\n    try {\n        const data = JSON.parse(json);\n        if (data.encseed) { return true; }\n    } catch (error) { }\n    return false;\n}\n\n// See: https://github.com/ethereum/pyethsaletool\n\n/**\n *  Before Ethereum launched, it was necessary to create a wallet\n *  format for backers to use, which would be used to receive ether\n *  as a reward for contributing to the project.\n *\n *  The [[link-crowdsale]] format is now obsolete, but it is still\n *  useful to support and the additional code is fairly trivial as\n *  all the primitives required are used through core portions of\n *  the library.\n */\nexport function decryptCrowdsaleJson(json: string, _password: string | Uint8Array): CrowdsaleAccount {\n    const data = JSON.parse(json);\n    const password = getPassword(_password);\n\n    // Ethereum Address\n    const address = getAddress(spelunk(data, \"ethaddr:string!\"));\n\n    // Encrypted Seed\n    const encseed = looseArrayify(spelunk(data, \"encseed:string!\"));\n    assertArgument(encseed && (encseed.length % 16) === 0, \"invalid encseed\", \"json\", json);\n\n    const key = getBytes(pbkdf2(password, password, 2000, 32, \"sha256\")).slice(0, 16);\n\n    const iv = encseed.slice(0, 16);\n    const encryptedSeed = encseed.slice(16);\n\n    // Decrypt the seed\n    const aesCbc = new CBC(key, iv);\n    const seed = pkcs7Strip(getBytes(aesCbc.decrypt(encryptedSeed)));\n\n    // This wallet format is weird... Convert the binary encoded hex to a string.\n    let seedHex = \"\";\n    for (let i = 0; i < seed.length; i++) {\n        seedHex += String.fromCharCode(seed[i]);\n    }\n\n    return { address, privateKey: id(seedHex) };\n}\n"],"names":[],"mappings":"AAAA;;GAEG;;;;;;;;AAEH,OAAO,EAAE,GAAG,EAAE,UAAU,EAAE,MAAM,QAAQ,CAAC;AAEzC,OAAO,EAAE,UAAU,EAAE,MAAM,qBAAqB,CAAC;AACjD,OAAO,EAAE,MAAM,EAAE,MAAM,oBAAoB,CAAC;AAC5C,OAAO,EAAE,EAAE,EAAE,MAAM,kBAAkB,CAAC;;AACtC,OAAO,EAAE,QAAQ,EAAE,cAAc,EAAE,MAAM,mBAAmB,CAAC;AAE7D,OAAO,EAAE,WAAW,EAAE,aAAa,EAAE,OAAO,EAAE,MAAM,YAAY,CAAC;;;;;;;AAe3D,SAAU,eAAe,CAAC,IAAY;IACxC,IAAI;QACA,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAC9B,IAAI,IAAI,CAAC,OAAO,EAAE;YAAE,OAAO,IAAI,CAAC;SAAE;KACrC,CAAC,OAAO,KAAK,EAAE,CAAA,CAAG;IACnB,OAAO,KAAK,CAAC;AACjB,CAAC;AAcK,SAAU,oBAAoB,CAAC,IAAY,EAAE,SAA8B;IAC7E,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;IAC9B,MAAM,QAAQ,OAAG,wOAAW,EAAC,SAAS,CAAC,CAAC;IAExC,mBAAmB;IACnB,MAAM,OAAO,OAAG,0OAAU,MAAC,oOAAO,EAAC,IAAI,EAAE,iBAAiB,CAAC,CAAC,CAAC;IAE7D,iBAAiB;IACjB,MAAM,OAAO,OAAG,0OAAa,MAAC,oOAAO,EAAC,IAAI,EAAE,iBAAiB,CAAC,CAAC,CAAC;QAChE,2OAAc,EAAC,OAAO,IAAI,AAAC,OAAO,CAAC,MAAM,GAAG,EAAE,CAAC,IAAK,CAAC,EAAE,iBAAiB,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;IAExF,MAAM,GAAG,OAAG,mOAAQ,MAAC,oOAAM,EAAC,QAAQ,EAAE,QAAQ,EAAE,IAAI,EAAE,EAAE,EAAE,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;IAElF,MAAM,EAAE,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;IAChC,MAAM,aAAa,GAAG,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;IAExC,mBAAmB;IACnB,MAAM,MAAM,GAAG,IAAI,+NAAG,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;IAChC,MAAM,IAAI,OAAG,kOAAU,MAAC,mOAAQ,EAAC,MAAM,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC;IAEjE,6EAA6E;IAC7E,IAAI,OAAO,GAAG,EAAE,CAAC;IACjB,IAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,CAAE;QAClC,OAAO,IAAI,MAAM,CAAC,YAAY,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;KAC3C;IAED,OAAO;QAAE,OAAO;QAAE,UAAU,MAAE,0NAAE,EAAC,OAAO,CAAC;IAAA,CAAE,CAAC;AAChD,CAAC"}},
    {"offset": {"line": 1321, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/ethers/lib.esm/wallet/wallet.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/ethers/src.ts/wallet/wallet.ts"],"sourcesContent":["import { SigningKey } from \"../crypto/index.js\";\nimport { assertArgument } from \"../utils/index.js\";\n\nimport { BaseWallet } from \"./base-wallet.js\";\nimport { HDNodeWallet } from \"./hdwallet.js\";\nimport { decryptCrowdsaleJson, isCrowdsaleJson  } from \"./json-crowdsale.js\";\nimport {\n    decryptKeystoreJson, decryptKeystoreJsonSync,\n    encryptKeystoreJson, encryptKeystoreJsonSync,\n    isKeystoreJson\n} from \"./json-keystore.js\";\nimport { Mnemonic } from \"./mnemonic.js\";\n\nimport type { ProgressCallback } from \"../crypto/index.js\";\nimport type { Provider } from \"../providers/index.js\";\n\nimport type { CrowdsaleAccount } from \"./json-crowdsale.js\";\nimport type { KeystoreAccount } from \"./json-keystore.js\";\n\n\nfunction stall(duration: number): Promise<void> {\n    return new Promise((resolve) => { setTimeout(() => { resolve(); }, duration); });\n}\n\n/**\n *  A **Wallet** manages a single private key which is used to sign\n *  transactions, messages and other common payloads.\n *\n *  This class is generally the main entry point for developers\n *  that wish to use a private key directly, as it can create\n *  instances from a large variety of common sources, including\n *  raw private key, [[link-bip-39]] mnemonics and encrypte JSON\n *  wallets.\n */\nexport class Wallet extends BaseWallet {\n\n    /**\n     *  Create a new wallet for the private %%key%%, optionally connected\n     *  to %%provider%%.\n     */\n    constructor(key: string | SigningKey, provider?: null | Provider) {\n        if (typeof(key) === \"string\" && !key.startsWith(\"0x\")) {\n            key = \"0x\" + key;\n        }\n\n        let signingKey = (typeof(key) === \"string\") ? new SigningKey(key): key;\n        super(signingKey, provider);\n    }\n\n    connect(provider: null | Provider): Wallet {\n        return new Wallet(this.signingKey, provider);\n    }\n\n    /**\n     *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with\n     *  %%password%%.\n     *\n     *  If %%progressCallback%% is specified, it will receive periodic\n     *  updates as the encryption process progreses.\n     */\n    async encrypt(password: Uint8Array | string, progressCallback?: ProgressCallback): Promise<string> {\n        const account = { address: this.address, privateKey: this.privateKey };\n        return await encryptKeystoreJson(account, password, { progressCallback });\n    }\n\n    /**\n     *  Returns a [JSON Keystore Wallet](json-wallets) encryped with\n     *  %%password%%.\n     *\n     *  It is preferred to use the [async version](encrypt) instead,\n     *  which allows a [[ProgressCallback]] to keep the user informed.\n     *\n     *  This method will block the event loop (freezing all UI) until\n     *  it is complete, which may be a non-trivial duration.\n     */\n    encryptSync(password: Uint8Array | string): string {\n        const account = { address: this.address, privateKey: this.privateKey };\n        return encryptKeystoreJsonSync(account, password);\n    }\n\n    static #fromAccount(account: null | CrowdsaleAccount | KeystoreAccount): HDNodeWallet | Wallet {\n        assertArgument(account, \"invalid JSON wallet\", \"json\", \"[ REDACTED ]\");\n\n        if (\"mnemonic\" in account && account.mnemonic && account.mnemonic.locale === \"en\") {\n            const mnemonic = Mnemonic.fromEntropy(account.mnemonic.entropy);\n            const wallet = HDNodeWallet.fromMnemonic(mnemonic, account.mnemonic.path);\n            if (wallet.address === account.address && wallet.privateKey === account.privateKey) {\n                return wallet;\n            }\n            console.log(\"WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key\");\n        }\n\n        const wallet = new Wallet(account.privateKey);\n\n        assertArgument(wallet.address === account.address,\n            \"address/privateKey mismatch\", \"json\", \"[ REDACTED ]\");\n\n        return wallet;\n    }\n\n    /**\n     *  Creates (asynchronously) a **Wallet** by decrypting the %%json%%\n     *  with %%password%%.\n     *\n     *  If %%progress%% is provided, it is called periodically during\n     *  decryption so that any UI can be updated.\n     */\n    static async fromEncryptedJson(json: string, password: Uint8Array | string, progress?: ProgressCallback): Promise<HDNodeWallet | Wallet> {\n        let account: null | CrowdsaleAccount | KeystoreAccount = null;\n        if (isKeystoreJson(json)) {\n            account = await decryptKeystoreJson(json, password, progress);\n\n        } else if (isCrowdsaleJson(json)) {\n            if (progress) { progress(0); await stall(0); }\n            account = decryptCrowdsaleJson(json, password);\n            if (progress) { progress(1); await stall(0); }\n\n        }\n\n        return Wallet.#fromAccount(account);\n    }\n\n    /**\n     *  Creates a **Wallet** by decrypting the %%json%% with %%password%%.\n     *\n     *  The [[fromEncryptedJson]] method is preferred, as this method\n     *  will lock up and freeze the UI during decryption, which may take\n     *  some time.\n     */\n    static fromEncryptedJsonSync(json: string, password: Uint8Array | string): HDNodeWallet | Wallet {\n        let account: null | CrowdsaleAccount | KeystoreAccount = null;\n        if (isKeystoreJson(json)) {\n            account = decryptKeystoreJsonSync(json, password);\n        } else if (isCrowdsaleJson(json)) {\n            account = decryptCrowdsaleJson(json, password);\n        } else {\n            assertArgument(false, \"invalid JSON wallet\", \"json\", \"[ REDACTED ]\");\n        }\n\n        return Wallet.#fromAccount(account);\n    }\n\n    /**\n     *  Creates a new random [[HDNodeWallet]] using the available\n     *  [cryptographic random source](randomBytes).\n     *\n     *  If there is no crytographic random source, this will throw.\n     */\n    static createRandom(provider?: null | Provider): HDNodeWallet {\n        const wallet = HDNodeWallet.createRandom();\n        if (provider) { return wallet.connect(provider); }\n        return wallet;\n    }\n\n    /**\n     *  Creates a [[HDNodeWallet]] for %%phrase%%.\n     */\n    static fromPhrase(phrase: string, provider?: Provider): HDNodeWallet {\n        const wallet = HDNodeWallet.fromPhrase(phrase);\n        if (provider) { return wallet.connect(provider); }\n        return wallet;\n    }\n}\n"],"names":[],"mappings":"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"}}]
}