{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/carrier.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/carrier.ts"],"sourcesContent":["import type { AsyncContextStack } from './asyncContext/stackStrategy';\nimport type { AsyncContextStrategy } from './asyncContext/types';\nimport type { Client } from './client';\nimport type { Scope } from './scope';\nimport type { SerializedLog } from './types-hoist/log';\nimport type { SerializedMetric } from './types-hoist/metric';\nimport { SDK_VERSION } from './utils/version';\nimport { GLOBAL_OBJ } from './utils/worldwide';\n\n/**\n * An object that contains globally accessible properties and maintains a scope stack.\n * @hidden\n */\nexport interface Carrier {\n  __SENTRY__?: VersionedCarrier;\n}\n\ntype VersionedCarrier = {\n  version?: string;\n} & Record<Exclude<string, 'version'>, SentryCarrier>;\n\nexport interface SentryCarrier {\n  acs?: AsyncContextStrategy;\n  stack?: AsyncContextStack;\n\n  globalScope?: Scope;\n  defaultIsolationScope?: Scope;\n  defaultCurrentScope?: Scope;\n  loggerSettings?: { enabled: boolean };\n  /**\n   * A map of Sentry clients to their log buffers.\n   * This is used to store logs that are sent to Sentry.\n   */\n  clientToLogBufferMap?: WeakMap<Client, Array<SerializedLog>>;\n\n  /**\n   * A map of Sentry clients to their metric buffers.\n   * This is used to store metrics that are sent to Sentry.\n   */\n  clientToMetricBufferMap?: WeakMap<Client, Array<SerializedMetric>>;\n\n  /** Overwrites TextEncoder used in `@sentry/core`, need for `react-native@0.73` and older */\n  encodePolyfill?: (input: string) => Uint8Array;\n  /** Overwrites TextDecoder used in `@sentry/core`, need for `react-native@0.73` and older */\n  decodePolyfill?: (input: Uint8Array) => string;\n}\n\n/**\n * Returns the global shim registry.\n *\n * FIXME: This function is problematic, because despite always returning a valid Carrier,\n * it has an optional `__SENTRY__` property, which then in turn requires us to always perform an unnecessary check\n * at the call-site. We always access the carrier through this function, so we can guarantee that `__SENTRY__` is there.\n **/\nexport function getMainCarrier(): Carrier {\n  // This ensures a Sentry carrier exists\n  getSentryCarrier(GLOBAL_OBJ);\n  return GLOBAL_OBJ;\n}\n\n/** Will either get the existing sentry carrier, or create a new one. */\nexport function getSentryCarrier(carrier: Carrier): SentryCarrier {\n  const __SENTRY__ = (carrier.__SENTRY__ = carrier.__SENTRY__ || {});\n\n  // For now: First SDK that sets the .version property wins\n  __SENTRY__.version = __SENTRY__.version || SDK_VERSION;\n\n  // Intentionally populating and returning the version of \"this\" SDK instance\n  // rather than what's set in .version so that \"this\" SDK always gets its carrier\n  return (__SENTRY__[SDK_VERSION] = __SENTRY__[SDK_VERSION] || {});\n}\n\n/**\n * Returns a global singleton contained in the global `__SENTRY__[]` object.\n *\n * If the singleton doesn't already exist in `__SENTRY__`, it will be created using the given factory\n * function and added to the `__SENTRY__` object.\n *\n * @param name name of the global singleton on __SENTRY__\n * @param creator creator Factory function to create the singleton if it doesn't already exist on `__SENTRY__`\n * @param obj (Optional) The global object on which to look for `__SENTRY__`, if not `GLOBAL_OBJ`'s return value\n * @returns the singleton\n */\nexport function getGlobalSingleton<Prop extends keyof SentryCarrier>(\n  name: Prop,\n  creator: () => NonNullable<SentryCarrier[Prop]>,\n  obj = GLOBAL_OBJ,\n): NonNullable<SentryCarrier[Prop]> {\n  const __SENTRY__ = (obj.__SENTRY__ = obj.__SENTRY__ || {});\n  const carrier = (__SENTRY__[SDK_VERSION] = __SENTRY__[SDK_VERSION] || {});\n  // Note: We do not want to set `carrier.version` here, as this may be called before any `init` is called, e.g. for the default scopes\n  return carrier[name] || (carrier[name] = creator());\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AASA;;;CAGA,GAmCA;;;;;;EAMA,GACO,SAAS,cAAc,GAAY;IAC1C,uCAAA;IACE,gBAAgB,CAAC,sPAAU,CAAC;IAC5B,OAAO,sPAAU;AACnB;AAEA,sEAAA,GACO,SAAS,gBAAgB,CAAC,OAAO,EAA0B;IAChE,MAAM,UAAA,GAAc,OAAO,CAAC,UAAA,GAAa,OAAO,CAAC,UAAA,IAAc,CAAA,CAAE,CAAC;IAEpE,0DAAA;IACE,UAAU,CAAC,OAAA,GAAU,UAAU,CAAC,OAAA,IAAW,qPAAW;IAExD,4EAAA;IACA,gFAAA;IACE,OAAQ,UAAU,CAAC,qPAAW,CAAA,GAAI,UAAU,CAAC,qPAAW,CAAA,IAAK,CAAA,CAAE;AACjE;AAEA;;;;;;;;;;CAUA,GACO,SAAS,kBAAkB,CAChC,IAAI,EACJ,OAAO,EACP,GAAA,GAAM,sPAAU;IAEhB,MAAM,UAAA,GAAc,GAAG,CAAC,UAAA,GAAa,GAAG,CAAC,UAAA,IAAc,CAAA,CAAE,CAAC;IAC1D,MAAM,OAAA,GAAW,UAAU,CAAC,qPAAW,CAAA,GAAI,UAAU,CAAC,qPAAW,CAAA,IAAK,CAAA,CAAE,CAAC;IAC3E,qIAAA;IACE,OAAO,OAAO,CAAC,IAAI,CAAA,IAAA,CAAM,OAAO,CAAC,IAAI,CAAA,GAAI,OAAO,EAAE,CAAC;AACrD"}},
    {"offset": {"line": 60, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/debug-build.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/debug-build.ts"],"sourcesContent":["declare const __DEBUG_BUILD__: boolean;\n\n/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nexport const DEBUG_BUILD = __DEBUG_BUILD__;\n"],"names":[],"mappings":"AAEA;;;;CAIA;;;;AACO,MAAM,WAAA,GAAc,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA"}},
    {"offset": {"line": 75, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/session.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/session.ts"],"sourcesContent":["import type { SerializedSession, Session, SessionContext, SessionStatus } from './types-hoist/session';\nimport { uuid4 } from './utils/misc';\nimport { timestampInSeconds } from './utils/time';\n\n/**\n * Creates a new `Session` object by setting certain default parameters. If optional @param context\n * is passed, the passed properties are applied to the session object.\n *\n * @param context (optional) additional properties to be applied to the returned session object\n *\n * @returns a new `Session` object\n */\nexport function makeSession(context?: Omit<SessionContext, 'started' | 'status'>): Session {\n  // Both timestamp and started are in seconds since the UNIX epoch.\n  const startingTime = timestampInSeconds();\n\n  const session: Session = {\n    sid: uuid4(),\n    init: true,\n    timestamp: startingTime,\n    started: startingTime,\n    duration: 0,\n    status: 'ok',\n    errors: 0,\n    ignoreDuration: false,\n    toJSON: () => sessionToJSON(session),\n  };\n\n  if (context) {\n    updateSession(session, context);\n  }\n\n  return session;\n}\n\n/**\n * Updates a session object with the properties passed in the context.\n *\n * Note that this function mutates the passed object and returns void.\n * (Had to do this instead of returning a new and updated session because closing and sending a session\n * makes an update to the session after it was passed to the sending logic.\n * @see Client.captureSession )\n *\n * @param session the `Session` to update\n * @param context the `SessionContext` holding the properties that should be updated in @param session\n */\n// eslint-disable-next-line complexity\nexport function updateSession(session: Session, context: SessionContext = {}): void {\n  if (context.user) {\n    if (!session.ipAddress && context.user.ip_address) {\n      session.ipAddress = context.user.ip_address;\n    }\n\n    if (!session.did && !context.did) {\n      session.did = context.user.id || context.user.email || context.user.username;\n    }\n  }\n\n  session.timestamp = context.timestamp || timestampInSeconds();\n\n  if (context.abnormal_mechanism) {\n    session.abnormal_mechanism = context.abnormal_mechanism;\n  }\n\n  if (context.ignoreDuration) {\n    session.ignoreDuration = context.ignoreDuration;\n  }\n  if (context.sid) {\n    // Good enough uuid validation. â€” Kamil\n    session.sid = context.sid.length === 32 ? context.sid : uuid4();\n  }\n  if (context.init !== undefined) {\n    session.init = context.init;\n  }\n  if (!session.did && context.did) {\n    session.did = `${context.did}`;\n  }\n  if (typeof context.started === 'number') {\n    session.started = context.started;\n  }\n  if (session.ignoreDuration) {\n    session.duration = undefined;\n  } else if (typeof context.duration === 'number') {\n    session.duration = context.duration;\n  } else {\n    const duration = session.timestamp - session.started;\n    session.duration = duration >= 0 ? duration : 0;\n  }\n  if (context.release) {\n    session.release = context.release;\n  }\n  if (context.environment) {\n    session.environment = context.environment;\n  }\n  if (!session.ipAddress && context.ipAddress) {\n    session.ipAddress = context.ipAddress;\n  }\n  if (!session.userAgent && context.userAgent) {\n    session.userAgent = context.userAgent;\n  }\n  if (typeof context.errors === 'number') {\n    session.errors = context.errors;\n  }\n  if (context.status) {\n    session.status = context.status;\n  }\n}\n\n/**\n * Closes a session by setting its status and updating the session object with it.\n * Internally calls `updateSession` to update the passed session object.\n *\n * Note that this function mutates the passed session (@see updateSession for explanation).\n *\n * @param session the `Session` object to be closed\n * @param status the `SessionStatus` with which the session was closed. If you don't pass a status,\n *               this function will keep the previously set status, unless it was `'ok'` in which case\n *               it is changed to `'exited'`.\n */\nexport function closeSession(session: Session, status?: Exclude<SessionStatus, 'ok'>): void {\n  let context = {};\n  if (status) {\n    context = { status };\n  } else if (session.status === 'ok') {\n    context = { status: 'exited' };\n  }\n\n  updateSession(session, context);\n}\n\n/**\n * Serializes a passed session object to a JSON object with a slightly different structure.\n * This is necessary because the Sentry backend requires a slightly different schema of a session\n * than the one the JS SDKs use internally.\n *\n * @param session the session to be converted\n *\n * @returns a JSON object of the passed session\n */\nfunction sessionToJSON(session: Session): SerializedSession {\n  return {\n    sid: `${session.sid}`,\n    init: session.init,\n    // Make sure that sec is converted to ms for date constructor\n    started: new Date(session.started * 1000).toISOString(),\n    timestamp: new Date(session.timestamp * 1000).toISOString(),\n    status: session.status,\n    errors: session.errors,\n    did: typeof session.did === 'number' || typeof session.did === 'string' ? `${session.did}` : undefined,\n    duration: session.duration,\n    abnormal_mechanism: session.abnormal_mechanism,\n    attrs: {\n      release: session.release,\n      environment: session.environment,\n      ip_address: session.ipAddress,\n      user_agent: session.userAgent,\n    },\n  };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 237, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/scope.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/scope.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport type { Client } from './client';\nimport { DEBUG_BUILD } from './debug-build';\nimport { updateSession } from './session';\nimport type { Attachment } from './types-hoist/attachment';\nimport type { Breadcrumb } from './types-hoist/breadcrumb';\nimport type { Context, Contexts } from './types-hoist/context';\nimport type { DynamicSamplingContext } from './types-hoist/envelope';\nimport type { Event, EventHint } from './types-hoist/event';\nimport type { EventProcessor } from './types-hoist/eventprocessor';\nimport type { Extra, Extras } from './types-hoist/extra';\nimport type { Primitive } from './types-hoist/misc';\nimport type { RequestEventData } from './types-hoist/request';\nimport type { Session } from './types-hoist/session';\nimport type { SeverityLevel } from './types-hoist/severity';\nimport type { Span } from './types-hoist/span';\nimport type { PropagationContext } from './types-hoist/tracing';\nimport type { User } from './types-hoist/user';\nimport { debug } from './utils/debug-logger';\nimport { isPlainObject } from './utils/is';\nimport { merge } from './utils/merge';\nimport { uuid4 } from './utils/misc';\nimport { generateTraceId } from './utils/propagationContext';\nimport { _getSpanForScope, _setSpanForScope } from './utils/spanOnScope';\nimport { truncate } from './utils/string';\nimport { dateTimestampInSeconds } from './utils/time';\n\n/**\n * Default value for maximum number of breadcrumbs added to an event.\n */\nconst DEFAULT_MAX_BREADCRUMBS = 100;\n\n/**\n * A context to be used for capturing an event.\n * This can either be a Scope, or a partial ScopeContext,\n * or a callback that receives the current scope and returns a new scope to use.\n */\nexport type CaptureContext = Scope | Partial<ScopeContext> | ((scope: Scope) => Scope);\n\n/**\n * Data that can be converted to a Scope.\n */\nexport interface ScopeContext {\n  user: User;\n  level: SeverityLevel;\n  extra: Extras;\n  contexts: Contexts;\n  tags: { [key: string]: Primitive };\n  fingerprint: string[];\n  propagationContext: PropagationContext;\n}\n\nexport interface SdkProcessingMetadata {\n  [key: string]: unknown;\n  requestSession?: {\n    status: 'ok' | 'errored' | 'crashed';\n  };\n  normalizedRequest?: RequestEventData;\n  dynamicSamplingContext?: Partial<DynamicSamplingContext>;\n  capturedSpanScope?: Scope;\n  capturedSpanIsolationScope?: Scope;\n  spanCountBeforeProcessing?: number;\n  ipAddress?: string;\n}\n\n/**\n * Normalized data of the Scope, ready to be used.\n */\nexport interface ScopeData {\n  eventProcessors: EventProcessor[];\n  breadcrumbs: Breadcrumb[];\n  user: User;\n  tags: { [key: string]: Primitive };\n  extra: Extras;\n  contexts: Contexts;\n  attachments: Attachment[];\n  propagationContext: PropagationContext;\n  sdkProcessingMetadata: SdkProcessingMetadata;\n  fingerprint: string[];\n  level?: SeverityLevel;\n  transactionName?: string;\n  span?: Span;\n}\n\n/**\n * Holds additional event information.\n */\nexport class Scope {\n  /** Flag if notifying is happening. */\n  protected _notifyingListeners: boolean;\n\n  /** Callback for client to receive scope changes. */\n  protected _scopeListeners: Array<(scope: Scope) => void>;\n\n  /** Callback list that will be called during event processing. */\n  protected _eventProcessors: EventProcessor[];\n\n  /** Array of breadcrumbs. */\n  protected _breadcrumbs: Breadcrumb[];\n\n  /** User */\n  protected _user: User;\n\n  /** Tags */\n  protected _tags: { [key: string]: Primitive };\n\n  /** Extra */\n  protected _extra: Extras;\n\n  /** Contexts */\n  protected _contexts: Contexts;\n\n  /** Attachments */\n  protected _attachments: Attachment[];\n\n  /** Propagation Context for distributed tracing */\n  protected _propagationContext: PropagationContext;\n\n  /**\n   * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get\n   * sent to Sentry\n   */\n  protected _sdkProcessingMetadata: SdkProcessingMetadata;\n\n  /** Fingerprint */\n  protected _fingerprint?: string[];\n\n  /** Severity */\n  protected _level?: SeverityLevel;\n\n  /**\n   * Transaction Name\n   *\n   * IMPORTANT: The transaction name on the scope has nothing to do with root spans/transaction objects.\n   * It's purpose is to assign a transaction to the scope that's added to non-transaction events.\n   */\n  protected _transactionName?: string;\n\n  /** Session */\n  protected _session?: Session;\n\n  /** The client on this scope */\n  protected _client?: Client;\n\n  /** Contains the last event id of a captured event.  */\n  protected _lastEventId?: string;\n\n  // NOTE: Any field which gets added here should get added not only to the constructor but also to the `clone` method.\n\n  public constructor() {\n    this._notifyingListeners = false;\n    this._scopeListeners = [];\n    this._eventProcessors = [];\n    this._breadcrumbs = [];\n    this._attachments = [];\n    this._user = {};\n    this._tags = {};\n    this._extra = {};\n    this._contexts = {};\n    this._sdkProcessingMetadata = {};\n    this._propagationContext = {\n      traceId: generateTraceId(),\n      sampleRand: Math.random(),\n    };\n  }\n\n  /**\n   * Clone all data from this scope into a new scope.\n   */\n  public clone(): Scope {\n    const newScope = new Scope();\n    newScope._breadcrumbs = [...this._breadcrumbs];\n    newScope._tags = { ...this._tags };\n    newScope._extra = { ...this._extra };\n    newScope._contexts = { ...this._contexts };\n    if (this._contexts.flags) {\n      // We need to copy the `values` array so insertions on a cloned scope\n      // won't affect the original array.\n      newScope._contexts.flags = {\n        values: [...this._contexts.flags.values],\n      };\n    }\n\n    newScope._user = this._user;\n    newScope._level = this._level;\n    newScope._session = this._session;\n    newScope._transactionName = this._transactionName;\n    newScope._fingerprint = this._fingerprint;\n    newScope._eventProcessors = [...this._eventProcessors];\n    newScope._attachments = [...this._attachments];\n    newScope._sdkProcessingMetadata = { ...this._sdkProcessingMetadata };\n    newScope._propagationContext = { ...this._propagationContext };\n    newScope._client = this._client;\n    newScope._lastEventId = this._lastEventId;\n\n    _setSpanForScope(newScope, _getSpanForScope(this));\n\n    return newScope;\n  }\n\n  /**\n   * Update the client assigned to this scope.\n   * Note that not every scope will have a client assigned - isolation scopes & the global scope will generally not have a client,\n   * as well as manually created scopes.\n   */\n  public setClient(client: Client | undefined): void {\n    this._client = client;\n  }\n\n  /**\n   * Set the ID of the last captured error event.\n   * This is generally only captured on the isolation scope.\n   */\n  public setLastEventId(lastEventId: string | undefined): void {\n    this._lastEventId = lastEventId;\n  }\n\n  /**\n   * Get the client assigned to this scope.\n   */\n  public getClient<C extends Client>(): C | undefined {\n    return this._client as C | undefined;\n  }\n\n  /**\n   * Get the ID of the last captured error event.\n   * This is generally only available on the isolation scope.\n   */\n  public lastEventId(): string | undefined {\n    return this._lastEventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public addScopeListener(callback: (scope: Scope) => void): void {\n    this._scopeListeners.push(callback);\n  }\n\n  /**\n   * Add an event processor that will be called before an event is sent.\n   */\n  public addEventProcessor(callback: EventProcessor): this {\n    this._eventProcessors.push(callback);\n    return this;\n  }\n\n  /**\n   * Set the user for this scope.\n   * Set to `null` to unset the user.\n   */\n  public setUser(user: User | null): this {\n    // If null is passed we want to unset everything, but still define keys,\n    // so that later down in the pipeline any existing values are cleared.\n    this._user = user || {\n      email: undefined,\n      id: undefined,\n      ip_address: undefined,\n      username: undefined,\n    };\n\n    if (this._session) {\n      updateSession(this._session, { user });\n    }\n\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Get the user from this scope.\n   */\n  public getUser(): User | undefined {\n    return this._user;\n  }\n\n  /**\n   * Set an object that will be merged into existing tags on the scope,\n   * and will be sent as tags data with the event.\n   */\n  public setTags(tags: { [key: string]: Primitive }): this {\n    this._tags = {\n      ...this._tags,\n      ...tags,\n    };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Set a single tag that will be sent as tags data with the event.\n   */\n  public setTag(key: string, value: Primitive): this {\n    return this.setTags({ [key]: value });\n  }\n\n  /**\n   * Set an object that will be merged into existing extra on the scope,\n   * and will be sent as extra data with the event.\n   */\n  public setExtras(extras: Extras): this {\n    this._extra = {\n      ...this._extra,\n      ...extras,\n    };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Set a single key:value extra entry that will be sent as extra data with the event.\n   */\n  public setExtra(key: string, extra: Extra): this {\n    this._extra = { ...this._extra, [key]: extra };\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Sets the fingerprint on the scope to send with the events.\n   * @param {string[]} fingerprint Fingerprint to group events in Sentry.\n   */\n  public setFingerprint(fingerprint: string[]): this {\n    this._fingerprint = fingerprint;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Sets the level on the scope for future events.\n   */\n  public setLevel(level: SeverityLevel): this {\n    this._level = level;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Sets the transaction name on the scope so that the name of e.g. taken server route or\n   * the page location is attached to future events.\n   *\n   * IMPORTANT: Calling this function does NOT change the name of the currently active\n   * root span. If you want to change the name of the active root span, use\n   * `Sentry.updateSpanName(rootSpan, 'new name')` instead.\n   *\n   * By default, the SDK updates the scope's transaction name automatically on sensible\n   * occasions, such as a page navigation or when handling a new request on the server.\n   */\n  public setTransactionName(name?: string): this {\n    this._transactionName = name;\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Sets context data with the given name.\n   * Data passed as context will be normalized. You can also pass `null` to unset the context.\n   * Note that context data will not be merged - calling `setContext` will overwrite an existing context with the same key.\n   */\n  public setContext(key: string, context: Context | null): this {\n    if (context === null) {\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this._contexts[key];\n    } else {\n      this._contexts[key] = context;\n    }\n\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Set the session for the scope.\n   */\n  public setSession(session?: Session): this {\n    if (!session) {\n      delete this._session;\n    } else {\n      this._session = session;\n    }\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Get the session from the scope.\n   */\n  public getSession(): Session | undefined {\n    return this._session;\n  }\n\n  /**\n   * Updates the scope with provided data. Can work in three variations:\n   * - plain object containing updatable attributes\n   * - Scope instance that'll extract the attributes from\n   * - callback function that'll receive the current scope as an argument and allow for modifications\n   */\n  public update(captureContext?: CaptureContext): this {\n    if (!captureContext) {\n      return this;\n    }\n\n    const scopeToMerge = typeof captureContext === 'function' ? captureContext(this) : captureContext;\n\n    const scopeInstance =\n      scopeToMerge instanceof Scope\n        ? scopeToMerge.getScopeData()\n        : isPlainObject(scopeToMerge)\n          ? (captureContext as ScopeContext)\n          : undefined;\n\n    const { tags, extra, user, contexts, level, fingerprint = [], propagationContext } = scopeInstance || {};\n\n    this._tags = { ...this._tags, ...tags };\n    this._extra = { ...this._extra, ...extra };\n    this._contexts = { ...this._contexts, ...contexts };\n\n    if (user && Object.keys(user).length) {\n      this._user = user;\n    }\n\n    if (level) {\n      this._level = level;\n    }\n\n    if (fingerprint.length) {\n      this._fingerprint = fingerprint;\n    }\n\n    if (propagationContext) {\n      this._propagationContext = propagationContext;\n    }\n\n    return this;\n  }\n\n  /**\n   * Clears the current scope and resets its properties.\n   * Note: The client will not be cleared.\n   */\n  public clear(): this {\n    // client is not cleared here on purpose!\n    this._breadcrumbs = [];\n    this._tags = {};\n    this._extra = {};\n    this._user = {};\n    this._contexts = {};\n    this._level = undefined;\n    this._transactionName = undefined;\n    this._fingerprint = undefined;\n    this._session = undefined;\n    _setSpanForScope(this, undefined);\n    this._attachments = [];\n    this.setPropagationContext({ traceId: generateTraceId(), sampleRand: Math.random() });\n\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Adds a breadcrumb to the scope.\n   * By default, the last 100 breadcrumbs are kept.\n   */\n  public addBreadcrumb(breadcrumb: Breadcrumb, maxBreadcrumbs?: number): this {\n    const maxCrumbs = typeof maxBreadcrumbs === 'number' ? maxBreadcrumbs : DEFAULT_MAX_BREADCRUMBS;\n\n    // No data has been changed, so don't notify scope listeners\n    if (maxCrumbs <= 0) {\n      return this;\n    }\n\n    const mergedBreadcrumb: Breadcrumb = {\n      timestamp: dateTimestampInSeconds(),\n      ...breadcrumb,\n      // Breadcrumb messages can theoretically be infinitely large and they're held in memory so we truncate them not to leak (too much) memory\n      message: breadcrumb.message ? truncate(breadcrumb.message, 2048) : breadcrumb.message,\n    };\n\n    this._breadcrumbs.push(mergedBreadcrumb);\n    if (this._breadcrumbs.length > maxCrumbs) {\n      this._breadcrumbs = this._breadcrumbs.slice(-maxCrumbs);\n      this._client?.recordDroppedEvent('buffer_overflow', 'log_item');\n    }\n\n    this._notifyScopeListeners();\n\n    return this;\n  }\n\n  /**\n   * Get the last breadcrumb of the scope.\n   */\n  public getLastBreadcrumb(): Breadcrumb | undefined {\n    return this._breadcrumbs[this._breadcrumbs.length - 1];\n  }\n\n  /**\n   * Clear all breadcrumbs from the scope.\n   */\n  public clearBreadcrumbs(): this {\n    this._breadcrumbs = [];\n    this._notifyScopeListeners();\n    return this;\n  }\n\n  /**\n   * Add an attachment to the scope.\n   */\n  public addAttachment(attachment: Attachment): this {\n    this._attachments.push(attachment);\n    return this;\n  }\n\n  /**\n   * Clear all attachments from the scope.\n   */\n  public clearAttachments(): this {\n    this._attachments = [];\n    return this;\n  }\n\n  /**\n   * Get the data of this scope, which should be applied to an event during processing.\n   */\n  public getScopeData(): ScopeData {\n    return {\n      breadcrumbs: this._breadcrumbs,\n      attachments: this._attachments,\n      contexts: this._contexts,\n      tags: this._tags,\n      extra: this._extra,\n      user: this._user,\n      level: this._level,\n      fingerprint: this._fingerprint || [],\n      eventProcessors: this._eventProcessors,\n      propagationContext: this._propagationContext,\n      sdkProcessingMetadata: this._sdkProcessingMetadata,\n      transactionName: this._transactionName,\n      span: _getSpanForScope(this),\n    };\n  }\n\n  /**\n   * Add data which will be accessible during event processing but won't get sent to Sentry.\n   */\n  public setSDKProcessingMetadata(newData: SdkProcessingMetadata): this {\n    this._sdkProcessingMetadata = merge(this._sdkProcessingMetadata, newData, 2);\n    return this;\n  }\n\n  /**\n   * Add propagation context to the scope, used for distributed tracing\n   */\n  public setPropagationContext(context: PropagationContext): this {\n    this._propagationContext = context;\n    return this;\n  }\n\n  /**\n   * Get propagation context from the scope, used for distributed tracing\n   */\n  public getPropagationContext(): PropagationContext {\n    return this._propagationContext;\n  }\n\n  /**\n   * Capture an exception for this scope.\n   *\n   * @returns {string} The id of the captured Sentry event.\n   */\n  public captureException(exception: unknown, hint?: EventHint): string {\n    const eventId = hint?.event_id || uuid4();\n\n    if (!this._client) {\n      DEBUG_BUILD && debug.warn('No client configured on scope - will not capture exception!');\n      return eventId;\n    }\n\n    const syntheticException = new Error('Sentry syntheticException');\n\n    this._client.captureException(\n      exception,\n      {\n        originalException: exception,\n        syntheticException,\n        ...hint,\n        event_id: eventId,\n      },\n      this,\n    );\n\n    return eventId;\n  }\n\n  /**\n   * Capture a message for this scope.\n   *\n   * @returns {string} The id of the captured message.\n   */\n  public captureMessage(message: string, level?: SeverityLevel, hint?: EventHint): string {\n    const eventId = hint?.event_id || uuid4();\n\n    if (!this._client) {\n      DEBUG_BUILD && debug.warn('No client configured on scope - will not capture message!');\n      return eventId;\n    }\n\n    const syntheticException = hint?.syntheticException ?? new Error(message);\n\n    this._client.captureMessage(\n      message,\n      level,\n      {\n        originalException: message,\n        syntheticException,\n        ...hint,\n        event_id: eventId,\n      },\n      this,\n    );\n\n    return eventId;\n  }\n\n  /**\n   * Capture a Sentry event for this scope.\n   *\n   * @returns {string} The id of the captured event.\n   */\n  public captureEvent(event: Event, hint?: EventHint): string {\n    const eventId = hint?.event_id || uuid4();\n\n    if (!this._client) {\n      DEBUG_BUILD && debug.warn('No client configured on scope - will not capture event!');\n      return eventId;\n    }\n\n    this._client.captureEvent(event, { ...hint, event_id: eventId }, this);\n\n    return eventId;\n  }\n\n  /**\n   * This will be called on every set call.\n   */\n  protected _notifyScopeListeners(): void {\n    // We need this check for this._notifyingListeners to be able to work on scope during updates\n    // If this check is not here we'll produce endless recursion when something is done with the scope\n    // during the callback.\n    if (!this._notifyingListeners) {\n      this._notifyingListeners = true;\n      this._scopeListeners.forEach(callback => {\n        callback(this);\n      });\n      this._notifyingListeners = false;\n    }\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 721, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/defaultScopes.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/defaultScopes.ts"],"sourcesContent":["import { getGlobalSingleton } from './carrier';\nimport { Scope } from './scope';\n\n/** Get the default current scope. */\nexport function getDefaultCurrentScope(): Scope {\n  return getGlobalSingleton('defaultCurrentScope', () => new Scope());\n}\n\n/** Get the default isolation scope. */\nexport function getDefaultIsolationScope(): Scope {\n  return getGlobalSingleton('defaultIsolationScope', () => new Scope());\n}\n"],"names":[],"mappings":";;;;;;;;;;AAGA,mCAAA,GACO,SAAS,sBAAsB,GAAU;IAC9C,WAAO,mPAAkB,EAAC,qBAAqB,EAAE,IAAM,IAAI,oOAAK,EAAE,CAAC;AACrE;AAEA,qCAAA,GACO,SAAS,wBAAwB,GAAU;IAChD,WAAO,mPAAkB,EAAC,uBAAuB,EAAE,IAAM,IAAI,oOAAK,EAAE,CAAC;AACvE"}},
    {"offset": {"line": 743, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/asyncContext/stackStrategy.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/asyncContext/stackStrategy.ts"],"sourcesContent":["import type { Client } from '../client';\nimport { getDefaultCurrentScope, getDefaultIsolationScope } from '../defaultScopes';\nimport { Scope } from '../scope';\nimport { isThenable } from '../utils/is';\nimport { getMainCarrier, getSentryCarrier } from './../carrier';\nimport type { AsyncContextStrategy } from './types';\n\ninterface Layer {\n  client?: Client;\n  scope: Scope;\n}\n\n/**\n * This is an object that holds a stack of scopes.\n */\nexport class AsyncContextStack {\n  private readonly _stack: [Layer, ...Layer[]];\n  private _isolationScope: Scope;\n\n  public constructor(scope?: Scope, isolationScope?: Scope) {\n    let assignedScope;\n    if (!scope) {\n      assignedScope = new Scope();\n    } else {\n      assignedScope = scope;\n    }\n\n    let assignedIsolationScope;\n    if (!isolationScope) {\n      assignedIsolationScope = new Scope();\n    } else {\n      assignedIsolationScope = isolationScope;\n    }\n\n    // scope stack for domains or the process\n    this._stack = [{ scope: assignedScope }];\n    this._isolationScope = assignedIsolationScope;\n  }\n\n  /**\n   * Fork a scope for the stack.\n   */\n  public withScope<T>(callback: (scope: Scope) => T): T {\n    const scope = this._pushScope();\n\n    let maybePromiseResult: T;\n    try {\n      maybePromiseResult = callback(scope);\n    } catch (e) {\n      this._popScope();\n      throw e;\n    }\n\n    if (isThenable(maybePromiseResult)) {\n      // @ts-expect-error - isThenable returns the wrong type\n      return maybePromiseResult.then(\n        res => {\n          this._popScope();\n          return res;\n        },\n        e => {\n          this._popScope();\n          throw e;\n        },\n      );\n    }\n\n    this._popScope();\n    return maybePromiseResult;\n  }\n\n  /**\n   * Get the client of the stack.\n   */\n  public getClient<C extends Client>(): C | undefined {\n    return this.getStackTop().client as C;\n  }\n\n  /**\n   * Returns the scope of the top stack.\n   */\n  public getScope(): Scope {\n    return this.getStackTop().scope;\n  }\n\n  /**\n   * Get the isolation scope for the stack.\n   */\n  public getIsolationScope(): Scope {\n    return this._isolationScope;\n  }\n\n  /**\n   * Returns the topmost scope layer in the order domain > local > process.\n   */\n  public getStackTop(): Layer {\n    return this._stack[this._stack.length - 1] as Layer;\n  }\n\n  /**\n   * Push a scope to the stack.\n   */\n  private _pushScope(): Scope {\n    // We want to clone the content of prev scope\n    const scope = this.getScope().clone();\n    this._stack.push({\n      client: this.getClient(),\n      scope,\n    });\n    return scope;\n  }\n\n  /**\n   * Pop a scope from the stack.\n   */\n  private _popScope(): boolean {\n    if (this._stack.length <= 1) return false;\n    return !!this._stack.pop();\n  }\n}\n\n/**\n * Get the global async context stack.\n * This will be removed during the v8 cycle and is only here to make migration easier.\n */\nfunction getAsyncContextStack(): AsyncContextStack {\n  const registry = getMainCarrier();\n  const sentry = getSentryCarrier(registry);\n\n  return (sentry.stack = sentry.stack || new AsyncContextStack(getDefaultCurrentScope(), getDefaultIsolationScope()));\n}\n\nfunction withScope<T>(callback: (scope: Scope) => T): T {\n  return getAsyncContextStack().withScope(callback);\n}\n\nfunction withSetScope<T>(scope: Scope, callback: (scope: Scope) => T): T {\n  const stack = getAsyncContextStack();\n  return stack.withScope(() => {\n    stack.getStackTop().scope = scope;\n    return callback(scope);\n  });\n}\n\nfunction withIsolationScope<T>(callback: (isolationScope: Scope) => T): T {\n  return getAsyncContextStack().withScope(() => {\n    return callback(getAsyncContextStack().getIsolationScope());\n  });\n}\n\n/**\n * Get the stack-based async context strategy.\n */\nexport function getStackAsyncContextStrategy(): AsyncContextStrategy {\n  return {\n    withIsolationScope,\n    withScope,\n    withSetScope,\n    withSetIsolationScope: <T>(_isolationScope: Scope, callback: (isolationScope: Scope) => T) => {\n      return withIsolationScope(callback);\n    },\n    getCurrentScope: () => getAsyncContextStack().getScope(),\n    getIsolationScope: () => getAsyncContextStack().getIsolationScope(),\n  };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 886, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/asyncContext/index.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/asyncContext/index.ts"],"sourcesContent":["import type { Carrier } from './../carrier';\nimport { getMainCarrier, getSentryCarrier } from './../carrier';\nimport { getStackAsyncContextStrategy } from './stackStrategy';\nimport type { AsyncContextStrategy } from './types';\n\n/**\n * @private Private API with no semver guarantees!\n *\n * Sets the global async context strategy\n */\nexport function setAsyncContextStrategy(strategy: AsyncContextStrategy | undefined): void {\n  // Get main carrier (global for every environment)\n  const registry = getMainCarrier();\n  const sentry = getSentryCarrier(registry);\n  sentry.acs = strategy;\n}\n\n/**\n * Get the current async context strategy.\n * If none has been setup, the default will be used.\n */\nexport function getAsyncContextStrategy(carrier: Carrier): AsyncContextStrategy {\n  const sentry = getSentryCarrier(carrier);\n\n  if (sentry.acs) {\n    return sentry.acs;\n  }\n\n  // Otherwise, use the default one (stack)\n  return getStackAsyncContextStrategy();\n}\n"],"names":[],"mappings":";;;;;;;;;;AAKA;;;;CAIA,GACO,SAAS,uBAAuB,CAAC,QAAQ,EAA0C;IAC1F,kDAAA;IACE,MAAM,QAAA,OAAW,+OAAc,EAAE;IACjC,MAAM,MAAA,OAAS,iPAAgB,EAAC,QAAQ,CAAC;IACzC,MAAM,CAAC,GAAA,GAAM,QAAQ;AACvB;AAEA;;;CAGA,GACO,SAAS,uBAAuB,CAAC,OAAO,EAAiC;IAC9E,MAAM,MAAA,OAAS,iPAAgB,EAAC,OAAO,CAAC;IAExC,IAAI,MAAM,CAAC,GAAG,EAAE;QACd,OAAO,MAAM,CAAC,GAAG;IACnB;IAEF,yCAAA;IACE,WAAO,mRAA4B,EAAE;AACvC"}},
    {"offset": {"line": 923, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/currentScopes.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/currentScopes.ts"],"sourcesContent":["import { getAsyncContextStrategy } from './asyncContext';\nimport { getGlobalSingleton, getMainCarrier } from './carrier';\nimport type { Client } from './client';\nimport { Scope } from './scope';\nimport type { TraceContext } from './types-hoist/context';\nimport { generateSpanId } from './utils/propagationContext';\n\n/**\n * Get the currently active scope.\n */\nexport function getCurrentScope(): Scope {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n  return acs.getCurrentScope();\n}\n\n/**\n * Get the currently active isolation scope.\n * The isolation scope is active for the current execution context.\n */\nexport function getIsolationScope(): Scope {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n  return acs.getIsolationScope();\n}\n\n/**\n * Get the global scope.\n * This scope is applied to _all_ events.\n */\nexport function getGlobalScope(): Scope {\n  return getGlobalSingleton('globalScope', () => new Scope());\n}\n\n/**\n * Creates a new scope with and executes the given operation within.\n * The scope is automatically removed once the operation\n * finishes or throws.\n */\nexport function withScope<T>(callback: (scope: Scope) => T): T;\n/**\n * Set the given scope as the active scope in the callback.\n */\nexport function withScope<T>(scope: Scope | undefined, callback: (scope: Scope) => T): T;\n/**\n * Either creates a new active scope, or sets the given scope as active scope in the given callback.\n */\nexport function withScope<T>(\n  ...rest: [callback: (scope: Scope) => T] | [scope: Scope | undefined, callback: (scope: Scope) => T]\n): T {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n\n  // If a scope is defined, we want to make this the active scope instead of the default one\n  if (rest.length === 2) {\n    const [scope, callback] = rest;\n\n    if (!scope) {\n      return acs.withScope(callback);\n    }\n\n    return acs.withSetScope(scope, callback);\n  }\n\n  return acs.withScope(rest[0]);\n}\n\n/**\n * Attempts to fork the current isolation scope and the current scope based on the current async context strategy. If no\n * async context strategy is set, the isolation scope and the current scope will not be forked (this is currently the\n * case, for example, in the browser).\n *\n * Usage of this function in environments without async context strategy is discouraged and may lead to unexpected behaviour.\n *\n * This function is intended for Sentry SDK and SDK integration development. It is not recommended to be used in \"normal\"\n * applications directly because it comes with pitfalls. Use at your own risk!\n */\nexport function withIsolationScope<T>(callback: (isolationScope: Scope) => T): T;\n/**\n * Set the provided isolation scope as active in the given callback. If no\n * async context strategy is set, the isolation scope and the current scope will not be forked (this is currently the\n * case, for example, in the browser).\n *\n * Usage of this function in environments without async context strategy is discouraged and may lead to unexpected behaviour.\n *\n * This function is intended for Sentry SDK and SDK integration development. It is not recommended to be used in \"normal\"\n * applications directly because it comes with pitfalls. Use at your own risk!\n *\n * If you pass in `undefined` as a scope, it will fork a new isolation scope, the same as if no scope is passed.\n */\nexport function withIsolationScope<T>(isolationScope: Scope | undefined, callback: (isolationScope: Scope) => T): T;\n/**\n * Either creates a new active isolation scope, or sets the given isolation scope as active scope in the given callback.\n */\nexport function withIsolationScope<T>(\n  ...rest:\n    | [callback: (isolationScope: Scope) => T]\n    | [isolationScope: Scope | undefined, callback: (isolationScope: Scope) => T]\n): T {\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n\n  // If a scope is defined, we want to make this the active scope instead of the default one\n  if (rest.length === 2) {\n    const [isolationScope, callback] = rest;\n\n    if (!isolationScope) {\n      return acs.withIsolationScope(callback);\n    }\n\n    return acs.withSetIsolationScope(isolationScope, callback);\n  }\n\n  return acs.withIsolationScope(rest[0]);\n}\n\n/**\n * Get the currently active client.\n */\nexport function getClient<C extends Client>(): C | undefined {\n  return getCurrentScope().getClient<C>();\n}\n\n/**\n * Get a trace context for the given scope.\n */\nexport function getTraceContextFromScope(scope: Scope): TraceContext {\n  const propagationContext = scope.getPropagationContext();\n\n  const { traceId, parentSpanId, propagationSpanId } = propagationContext;\n\n  const traceContext: TraceContext = {\n    trace_id: traceId,\n    span_id: propagationSpanId || generateSpanId(),\n  };\n\n  if (parentSpanId) {\n    traceContext.parent_span_id = parentSpanId;\n  }\n\n  return traceContext;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAOA;;CAEA,GACO,SAAS,eAAe,GAAU;IACvC,MAAM,OAAA,OAAU,+OAAc,EAAE;IAChC,MAAM,GAAA,OAAM,sQAAuB,EAAC,OAAO,CAAC;IAC5C,OAAO,GAAG,CAAC,eAAe,EAAE;AAC9B;AAEA;;;CAGA,GACO,SAAS,iBAAiB,GAAU;IACzC,MAAM,OAAA,OAAU,+OAAc,EAAE;IAChC,MAAM,GAAA,OAAM,sQAAuB,EAAC,OAAO,CAAC;IAC5C,OAAO,GAAG,CAAC,iBAAiB,EAAE;AAChC;AAEA;;;CAGA,GACO,SAAS,cAAc,GAAU;IACtC,WAAO,mPAAkB,EAAC,aAAa,EAAE,IAAM,IAAI,oOAAK,EAAE,CAAC;AAC7D;AAEA;;;;CAIA,GAMA;;CAEA,GACO,SAAS,SAAS,CACvB,GAAG,IAAA;IAEH,MAAM,OAAA,OAAU,+OAAc,EAAE;IAChC,MAAM,GAAA,OAAM,sQAAuB,EAAC,OAAO,CAAC;IAE9C,0FAAA;IACE,IAAI,IAAI,CAAC,MAAA,KAAW,CAAC,EAAE;QACrB,MAAM,CAAC,KAAK,EAAE,QAAQ,CAAA,GAAI,IAAI;QAE9B,IAAI,CAAC,KAAK,EAAE;YACV,OAAO,GAAG,CAAC,SAAS,CAAC,QAAQ,CAAC;QAChC;QAEA,OAAO,GAAG,CAAC,YAAY,CAAC,KAAK,EAAE,QAAQ,CAAC;IAC1C;IAEA,OAAO,GAAG,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AAC/B;AAEA;;;;;;;;;CASA,GAeA;;CAEA,GACO,SAAS,kBAAkB,CAChC,GAAG,IAAA;IAIH,MAAM,OAAA,OAAU,+OAAc,EAAE;IAChC,MAAM,GAAA,OAAM,sQAAuB,EAAC,OAAO,CAAC;IAE9C,0FAAA;IACE,IAAI,IAAI,CAAC,MAAA,KAAW,CAAC,EAAE;QACrB,MAAM,CAAC,cAAc,EAAE,QAAQ,CAAA,GAAI,IAAI;QAEvC,IAAI,CAAC,cAAc,EAAE;YACnB,OAAO,GAAG,CAAC,kBAAkB,CAAC,QAAQ,CAAC;QACzC;QAEA,OAAO,GAAG,CAAC,qBAAqB,CAAC,cAAc,EAAE,QAAQ,CAAC;IAC5D;IAEA,OAAO,GAAG,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;AACxC;AAEA;;CAEA,GACO,SAAS,SAAS,GAAoC;IAC3D,OAAO,eAAe,EAAE,CAAC,SAAS,EAAK;AACzC;AAEA;;CAEA,GACO,SAAS,wBAAwB,CAAC,KAAK,EAAuB;IACnE,MAAM,kBAAA,GAAqB,KAAK,CAAC,qBAAqB,EAAE;IAExD,MAAM,EAAE,OAAO,EAAE,YAAY,EAAE,iBAAA,EAAkB,GAAI,kBAAkB;IAEvE,MAAM,YAAY,GAAiB;QACjC,QAAQ,EAAE,OAAO;QACjB,OAAO,EAAE,iBAAA,QAAqB,mQAAc,EAAE;IAClD,CAAG;IAED,IAAI,YAAY,EAAE;QAChB,YAAY,CAAC,cAAA,GAAiB,YAAY;IAC5C;IAEA,OAAO,YAAY;AACrB"}},
    {"offset": {"line": 1036, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/integration.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/integration.ts"],"sourcesContent":["import type { Client } from './client';\nimport { getClient } from './currentScopes';\nimport { DEBUG_BUILD } from './debug-build';\nimport type { Event, EventHint } from './types-hoist/event';\nimport type { Integration, IntegrationFn } from './types-hoist/integration';\nimport type { CoreOptions } from './types-hoist/options';\nimport { debug } from './utils/debug-logger';\n\nexport const installedIntegrations: string[] = [];\n\n/** Map of integrations assigned to a client */\nexport type IntegrationIndex = {\n  [key: string]: Integration;\n};\n\ntype IntegrationWithDefaultInstance = Integration & { isDefaultInstance?: true };\n\n/**\n * Remove duplicates from the given array, preferring the last instance of any duplicate. Not guaranteed to\n * preserve the order of integrations in the array.\n *\n * @private\n */\nfunction filterDuplicates(integrations: Integration[]): Integration[] {\n  const integrationsByName: { [key: string]: Integration } = {};\n\n  integrations.forEach((currentInstance: IntegrationWithDefaultInstance) => {\n    const { name } = currentInstance;\n\n    const existingInstance: IntegrationWithDefaultInstance | undefined = integrationsByName[name];\n\n    // We want integrations later in the array to overwrite earlier ones of the same type, except that we never want a\n    // default instance to overwrite an existing user instance\n    if (existingInstance && !existingInstance.isDefaultInstance && currentInstance.isDefaultInstance) {\n      return;\n    }\n\n    integrationsByName[name] = currentInstance;\n  });\n\n  return Object.values(integrationsByName);\n}\n\n/** Gets integrations to install */\nexport function getIntegrationsToSetup(\n  options: Pick<CoreOptions, 'defaultIntegrations' | 'integrations'>,\n): Integration[] {\n  const defaultIntegrations = options.defaultIntegrations || [];\n  const userIntegrations = options.integrations;\n\n  // We flag default instances, so that later we can tell them apart from any user-created instances of the same class\n  defaultIntegrations.forEach((integration: IntegrationWithDefaultInstance) => {\n    integration.isDefaultInstance = true;\n  });\n\n  let integrations: Integration[];\n\n  if (Array.isArray(userIntegrations)) {\n    integrations = [...defaultIntegrations, ...userIntegrations];\n  } else if (typeof userIntegrations === 'function') {\n    const resolvedUserIntegrations = userIntegrations(defaultIntegrations);\n    integrations = Array.isArray(resolvedUserIntegrations) ? resolvedUserIntegrations : [resolvedUserIntegrations];\n  } else {\n    integrations = defaultIntegrations;\n  }\n\n  return filterDuplicates(integrations);\n}\n\n/**\n * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default\n * integrations are added unless they were already provided before.\n * @param integrations array of integration instances\n * @param withDefault should enable default integrations\n */\nexport function setupIntegrations(client: Client, integrations: Integration[]): IntegrationIndex {\n  const integrationIndex: IntegrationIndex = {};\n\n  integrations.forEach((integration: Integration | undefined) => {\n    // guard against empty provided integrations\n    if (integration) {\n      setupIntegration(client, integration, integrationIndex);\n    }\n  });\n\n  return integrationIndex;\n}\n\n/**\n * Execute the `afterAllSetup` hooks of the given integrations.\n */\nexport function afterSetupIntegrations(client: Client, integrations: Integration[]): void {\n  for (const integration of integrations) {\n    // guard against empty provided integrations\n    if (integration?.afterAllSetup) {\n      integration.afterAllSetup(client);\n    }\n  }\n}\n\n/** Setup a single integration.  */\nexport function setupIntegration(client: Client, integration: Integration, integrationIndex: IntegrationIndex): void {\n  if (integrationIndex[integration.name]) {\n    DEBUG_BUILD && debug.log(`Integration skipped because it was already installed: ${integration.name}`);\n    return;\n  }\n  integrationIndex[integration.name] = integration;\n\n  // `setupOnce` is only called the first time\n  if (!installedIntegrations.includes(integration.name) && typeof integration.setupOnce === 'function') {\n    integration.setupOnce();\n    installedIntegrations.push(integration.name);\n  }\n\n  // `setup` is run for each client\n  if (integration.setup && typeof integration.setup === 'function') {\n    integration.setup(client);\n  }\n\n  if (typeof integration.preprocessEvent === 'function') {\n    const callback = integration.preprocessEvent.bind(integration) as typeof integration.preprocessEvent;\n    client.on('preprocessEvent', (event, hint) => callback(event, hint, client));\n  }\n\n  if (typeof integration.processEvent === 'function') {\n    const callback = integration.processEvent.bind(integration) as typeof integration.processEvent;\n\n    const processor = Object.assign((event: Event, hint: EventHint) => callback(event, hint, client), {\n      id: integration.name,\n    });\n\n    client.addEventProcessor(processor);\n  }\n\n  DEBUG_BUILD && debug.log(`Integration installed: ${integration.name}`);\n}\n\n/** Add an integration to the current scope's client. */\nexport function addIntegration(integration: Integration): void {\n  const client = getClient();\n\n  if (!client) {\n    DEBUG_BUILD && debug.warn(`Cannot add integration \"${integration.name}\" because no SDK Client is available.`);\n    return;\n  }\n\n  client.addIntegration(integration);\n}\n\n/**\n * Define an integration function that can be used to create an integration instance.\n * Note that this by design hides the implementation details of the integration, as they are considered internal.\n */\nexport function defineIntegration<Fn extends IntegrationFn>(fn: Fn): (...args: Parameters<Fn>) => Integration {\n  return fn;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAQO,MAAM,qBAAqB,GAAa,EAAA;AAE/C,6CAAA,GAOA;;;;;CAKA,GACA,SAAS,gBAAgB,CAAC,YAAY,EAAgC;IACpE,MAAM,kBAAkB,GAAmC,CAAA,CAAE;IAE7D,YAAY,CAAC,OAAO,CAAC,CAAC,eAAe,KAAqC;QACxE,MAAM,EAAE,IAAA,EAAK,GAAI,eAAe;QAEhC,MAAM,gBAAgB,GAA+C,kBAAkB,CAAC,IAAI,CAAC;QAEjG,kHAAA;QACA,0DAAA;QACI,IAAI,gBAAA,IAAoB,CAAC,gBAAgB,CAAC,iBAAA,IAAqB,eAAe,CAAC,iBAAiB,EAAE;YAChG;QACF;QAEA,kBAAkB,CAAC,IAAI,CAAA,GAAI,eAAe;IAC5C,CAAC,CAAC;IAEF,OAAO,MAAM,CAAC,MAAM,CAAC,kBAAkB,CAAC;AAC1C;AAEA,iCAAA,GACO,SAAS,sBAAsB,CACpC,OAAO;IAEP,MAAM,sBAAsB,OAAO,CAAC,mBAAA,IAAuB,EAAE;IAC7D,MAAM,gBAAA,GAAmB,OAAO,CAAC,YAAY;IAE/C,oHAAA;IACE,mBAAmB,CAAC,OAAO,CAAC,CAAC,WAAW,KAAqC;QAC3E,WAAW,CAAC,iBAAA,GAAoB,IAAI;IACtC,CAAC,CAAC;IAEF,IAAI,YAAY;IAEhB,IAAI,KAAK,CAAC,OAAO,CAAC,gBAAgB,CAAC,EAAE;QACnC,YAAA,GAAe,CAAC;eAAG,mBAAmB,EAAE;eAAG,gBAAgB;SAAC;IAC9D,CAAA,MAAO,IAAI,OAAO,gBAAA,KAAqB,UAAU,EAAE;QACjD,MAAM,wBAAA,GAA2B,gBAAgB,CAAC,mBAAmB,CAAC;QACtE,YAAA,GAAe,KAAK,CAAC,OAAO,CAAC,wBAAwB,CAAA,GAAI,wBAAA,GAA2B;YAAC,wBAAwB;SAAC;IAChH,OAAO;QACL,YAAA,GAAe,mBAAmB;IACpC;IAEA,OAAO,gBAAgB,CAAC,YAAY,CAAC;AACvC;AAEA;;;;;CAKA,GACO,SAAS,iBAAiB,CAAC,MAAM,EAAU,YAAY,EAAmC;IAC/F,MAAM,gBAAgB,GAAqB,CAAA,CAAE;IAE7C,YAAY,CAAC,OAAO,CAAC,CAAC,WAAW,KAA8B;QACjE,4CAAA;QACI,IAAI,WAAW,EAAE;YACf,gBAAgB,CAAC,MAAM,EAAE,WAAW,EAAE,gBAAgB,CAAC;QACzD;IACF,CAAC,CAAC;IAEF,OAAO,gBAAgB;AACzB;AAEA;;CAEA,GACO,SAAS,sBAAsB,CAAC,MAAM,EAAU,YAAY,EAAuB;IACxF,KAAK,MAAM,WAAA,IAAe,YAAY,CAAE;QAC1C,4CAAA;QACI,IAAI,WAAW,EAAE,aAAa,EAAE;YAC9B,WAAW,CAAC,aAAa,CAAC,MAAM,CAAC;QACnC;IACF;AACF;AAEA,iCAAA,GACO,SAAS,gBAAgB,CAAC,MAAM,EAAU,WAAW,EAAe,gBAAgB,EAA0B;IACnH,IAAI,gBAAgB,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE;QACtC,mPAAA,IAAe,uPAAK,CAAC,GAAG,CAAC,CAAC,sDAAsD,EAAE,WAAW,CAAC,IAAI,CAAC,CAAA,CAAA;QACA;IACA;IACA,gBAAA,CAAA,WAAA,CAAA,IAAA,CAAA,GAAA,WAAA;IAEA,4CAAA;IACA,IAAA,CAAA,qBAAA,CAAA,QAAA,CAAA,WAAA,CAAA,IAAA,CAAA,IAAA,OAAA,WAAA,CAAA,SAAA,KAAA,UAAA,EAAA;QACA,WAAA,CAAA,SAAA,EAAA;QACA,qBAAA,CAAA,IAAA,CAAA,WAAA,CAAA,IAAA,CAAA;IACA;IAEA,iCAAA;IACA,IAAA,WAAA,CAAA,KAAA,IAAA,OAAA,WAAA,CAAA,KAAA,KAAA,UAAA,EAAA;QACA,WAAA,CAAA,KAAA,CAAA,MAAA,CAAA;IACA;IAEA,IAAA,OAAA,WAAA,CAAA,eAAA,KAAA,UAAA,EAAA;QACA,MAAA,QAAA,GAAA,WAAA,CAAA,eAAA,CAAA,IAAA,CAAA,WAAA,CAAA;QACA,MAAA,CAAA,EAAA,CAAA,iBAAA,EAAA,CAAA,KAAA,EAAA,IAAA,GAAA,QAAA,CAAA,KAAA,EAAA,IAAA,EAAA,MAAA,CAAA,CAAA;IACA;IAEA,IAAA,OAAA,WAAA,CAAA,YAAA,KAAA,UAAA,EAAA;QACA,MAAA,QAAA,GAAA,WAAA,CAAA,YAAA,CAAA,IAAA,CAAA,WAAA,CAAA;QAEA,MAAA,SAAA,GAAA,MAAA,CAAA,MAAA,CAAA,CAAA,KAAA,EAAA,IAAA,GAAA,QAAA,CAAA,KAAA,EAAA,IAAA,EAAA,MAAA,CAAA,EAAA;YACA,EAAA,EAAA,WAAA,CAAA,IAAA;QACA,CAAA,CAAA;QAEA,MAAA,CAAA,iBAAA,CAAA,SAAA,CAAA;IACA;IAEA,mPAAA,IAAA,uPAAA,CAAA,GAAA,CAAA,CAAA,uBAAA,EAAA,WAAA,CAAA,IAAA,CAAA,CAAA,CAAA;AACA;AAEA,sDAAA,GACA,SAAA,cAAA,CAAA,WAAA,EAAA;IACA,MAAA,MAAA,OAAA,gPAAA,EAAA;IAEA,IAAA,CAAA,MAAA,EAAA;QACA,mPAAA,IAAA,uPAAA,CAAA,IAAA,CAAA,CAAA,wBAAA,EAAA,WAAA,CAAA,IAAA,CAAA,qCAAA,CAAA,CAAA;QACA;IACA;IAEA,MAAA,CAAA,cAAA,CAAA,WAAA,CAAA;AACA;AAEA;;;CAGA,GACA,SAAA,iBAAA,CAAA,EAAA,EAAA;IACA,OAAA,EAAA;AACA"}},
    {"offset": {"line": 1174, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/breadcrumbs.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/breadcrumbs.ts"],"sourcesContent":["import { getClient, getIsolationScope } from './currentScopes';\nimport type { Breadcrumb, BreadcrumbHint } from './types-hoist/breadcrumb';\nimport { consoleSandbox } from './utils/debug-logger';\nimport { dateTimestampInSeconds } from './utils/time';\n\n/**\n * Default maximum number of breadcrumbs added to an event. Can be overwritten\n * with {@link Options.maxBreadcrumbs}.\n */\nconst DEFAULT_BREADCRUMBS = 100;\n\n/**\n * Records a new breadcrumb which will be attached to future events.\n *\n * Breadcrumbs will be added to subsequent events to provide more context on\n * user's actions prior to an error or crash.\n */\nexport function addBreadcrumb(breadcrumb: Breadcrumb, hint?: BreadcrumbHint): void {\n  const client = getClient();\n  const isolationScope = getIsolationScope();\n\n  if (!client) return;\n\n  const { beforeBreadcrumb = null, maxBreadcrumbs = DEFAULT_BREADCRUMBS } = client.getOptions();\n\n  if (maxBreadcrumbs <= 0) return;\n\n  const timestamp = dateTimestampInSeconds();\n  const mergedBreadcrumb = { timestamp, ...breadcrumb };\n  const finalBreadcrumb = beforeBreadcrumb\n    ? consoleSandbox(() => beforeBreadcrumb(mergedBreadcrumb, hint))\n    : mergedBreadcrumb;\n\n  if (finalBreadcrumb === null) return;\n\n  if (client.emit) {\n    client.emit('beforeAddBreadcrumb', finalBreadcrumb, hint);\n  }\n\n  isolationScope.addBreadcrumb(finalBreadcrumb, maxBreadcrumbs);\n}\n"],"names":[],"mappings":";;;;;;;;;;AAKA;;;CAGA,GACA,MAAM,mBAAA,GAAsB,GAAG;AAE/B;;;;;CAKA,GACO,SAAS,aAAa,CAAC,UAAU,EAAc,IAAI,EAAyB;IACjF,MAAM,MAAA,OAAS,gPAAS,EAAE;IAC1B,MAAM,cAAA,OAAiB,wPAAiB,EAAE;IAE1C,IAAI,CAAC,MAAM,EAAE;IAEb,MAAM,EAAE,gBAAA,GAAmB,IAAI,EAAE,cAAA,GAAiB,mBAAA,EAAA,GAAwB,MAAM,CAAC,UAAU,EAAE;IAE7F,IAAI,cAAA,IAAkB,CAAC,EAAE;IAEzB,MAAM,SAAA,OAAY,6PAAsB,EAAE;IAC1C,MAAM,mBAAmB;QAAE,SAAS;QAAE,GAAG,UAAA;IAAA,CAAY;IACrD,MAAM,kBAAkB,uBACpB,gQAAc,EAAC,IAAM,gBAAgB,CAAC,gBAAgB,EAAE,IAAI,CAAC,IAC7D,gBAAgB;IAEpB,IAAI,eAAA,KAAoB,IAAI,EAAE;IAE9B,IAAI,MAAM,CAAC,IAAI,EAAE;QACf,MAAM,CAAC,IAAI,CAAC,qBAAqB,EAAE,eAAe,EAAE,IAAI,CAAC;IAC3D;IAEA,cAAc,CAAC,aAAa,CAAC,eAAe,EAAE,cAAc,CAAC;AAC/D"}},
    {"offset": {"line": 1217, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/constants.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/constants.ts"],"sourcesContent":["export const DEFAULT_ENVIRONMENT = 'production';\n"],"names":[],"mappings":";;;;AAAO,MAAM,mBAAA,GAAsB"}},
    {"offset": {"line": 1228, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/eventProcessors.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/eventProcessors.ts"],"sourcesContent":["import { DEBUG_BUILD } from './debug-build';\nimport type { Event, EventHint } from './types-hoist/event';\nimport type { EventProcessor } from './types-hoist/eventprocessor';\nimport { debug } from './utils/debug-logger';\nimport { isThenable } from './utils/is';\nimport { rejectedSyncPromise, resolvedSyncPromise } from './utils/syncpromise';\n\n/**\n * Process an array of event processors, returning the processed event (or `null` if the event was dropped).\n */\nexport function notifyEventProcessors(\n  processors: EventProcessor[],\n  event: Event | null,\n  hint: EventHint,\n  index: number = 0,\n): PromiseLike<Event | null> {\n  try {\n    const result = _notifyEventProcessors(event, hint, processors, index);\n    return isThenable(result) ? result : resolvedSyncPromise(result);\n  } catch (error) {\n    return rejectedSyncPromise(error);\n  }\n}\n\nfunction _notifyEventProcessors(\n  event: Event | null,\n  hint: EventHint,\n  processors: EventProcessor[],\n  index: number,\n): Event | null | PromiseLike<Event | null> {\n  const processor = processors[index];\n\n  if (!event || !processor) {\n    return event;\n  }\n\n  const result = processor({ ...event }, hint);\n\n  DEBUG_BUILD && result === null && debug.log(`Event processor \"${processor.id || '?'}\" dropped event`);\n\n  if (isThenable(result)) {\n    return result.then(final => _notifyEventProcessors(final, hint, processors, index + 1));\n  }\n\n  return _notifyEventProcessors(result, hint, processors, index + 1);\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAOA;;CAEA,GACO,SAAS,qBAAqB,CACnC,UAAU,EACV,KAAK,EACL,IAAI,EACJ,KAAK,GAAW,CAAC;IAEjB,IAAI;QACF,MAAM,MAAA,GAAS,sBAAsB,CAAC,KAAK,EAAE,IAAI,EAAE,UAAU,EAAE,KAAK,CAAC;QACrE,WAAO,+OAAU,EAAC,MAAM,CAAA,GAAI,MAAA,OAAS,iQAAmB,EAAC,MAAM,CAAC;IAClE,CAAA,CAAE,OAAO,KAAK,EAAE;QACd,WAAO,iQAAmB,EAAC,KAAK,CAAC;IACnC;AACF;AAEA,SAAS,sBAAsB,CAC7B,KAAK,EACL,IAAI,EACJ,UAAU,EACV,KAAK;IAEL,MAAM,SAAA,GAAY,UAAU,CAAC,KAAK,CAAC;IAEnC,IAAI,CAAC,SAAS,CAAC,SAAS,EAAE;QACxB,OAAO,KAAK;IACd;IAEA,MAAM,MAAA,GAAS,SAAS,CAAC;QAAE,GAAG,KAAA;IAAA,CAAO,EAAE,IAAI,CAAC;IAE5C,mPAAA,IAAe,MAAA,KAAW,QAAQ,uPAAK,CAAC,GAAG,CAAC,CAAC,iBAAiB,EAAE,SAAS,CAAC,EAAA,IAAM,GAAG,CAAC,eAAe,CAAC,CAAC;IAErG,QAAI,+OAAU,EAAC,MAAM,CAAC,EAAE;QACtB,OAAO,MAAM,CAAC,IAAI,EAAC,KAAA,GAAS,sBAAsB,CAAC,KAAK,EAAE,IAAI,EAAE,UAAU,EAAE,QAAQ,CAAC,CAAC,CAAC;IACzF;IAEA,OAAO,sBAAsB,CAAC,MAAM,EAAE,IAAI,EAAE,UAAU,EAAE,KAAA,GAAQ,CAAC,CAAC;AACpE"}},
    {"offset": {"line": 1270, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/semanticAttributes.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/semanticAttributes.ts"],"sourcesContent":["/**\n * Use this attribute to represent the source of a span.\n * Should be one of: custom, url, route, view, component, task, unknown\n *\n */\nexport const SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = 'sentry.source';\n\n/**\n * Attributes that holds the sample rate that was locally applied to a span.\n * If this attribute is not defined, it means that the span inherited a sampling decision.\n *\n * NOTE: Is only defined on root spans.\n */\nexport const SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = 'sentry.sample_rate';\n\n/**\n * Attribute holding the sample rate of the previous trace.\n * This is used to sample consistently across subsequent traces in the browser SDK.\n *\n * Note: Only defined on root spans, if opted into consistent sampling\n */\nexport const SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE = 'sentry.previous_trace_sample_rate';\n\n/**\n * Use this attribute to represent the operation of a span.\n */\nexport const SEMANTIC_ATTRIBUTE_SENTRY_OP = 'sentry.op';\n\n/**\n * Use this attribute to represent the origin of a span.\n */\nexport const SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = 'sentry.origin';\n\n/** The reason why an idle span finished. */\nexport const SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON = 'sentry.idle_span_finish_reason';\n\n/** The unit of a measurement, which may be stored as a TimedEvent. */\nexport const SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_UNIT = 'sentry.measurement_unit';\n\n/** The value of a measurement, which may be stored as a TimedEvent. */\nexport const SEMANTIC_ATTRIBUTE_SENTRY_MEASUREMENT_VALUE = 'sentry.measurement_value';\n\n/**\n * A custom span name set by users guaranteed to be taken over any automatically\n * inferred name. This attribute is removed before the span is sent.\n *\n * @internal only meant for internal SDK usage\n * @hidden\n */\nexport const SEMANTIC_ATTRIBUTE_SENTRY_CUSTOM_SPAN_NAME = 'sentry.custom_span_name';\n\n/**\n * The id of the profile that this span occurred in.\n */\nexport const SEMANTIC_ATTRIBUTE_PROFILE_ID = 'sentry.profile_id';\n\nexport const SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME = 'sentry.exclusive_time';\n\nexport const SEMANTIC_ATTRIBUTE_CACHE_HIT = 'cache.hit';\n\nexport const SEMANTIC_ATTRIBUTE_CACHE_KEY = 'cache.key';\n\nexport const SEMANTIC_ATTRIBUTE_CACHE_ITEM_SIZE = 'cache.item_size';\n\n/** TODO: Remove these once we update to latest semantic conventions */\nexport const SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD = 'http.request.method';\nexport const SEMANTIC_ATTRIBUTE_URL_FULL = 'url.full';\n\n/**\n * A span link attribute to mark the link as a special span link.\n *\n * Known values:\n * - `previous_trace`: The span links to the frontend root span of the previous trace.\n * - `next_trace`: The span links to the frontend root span of the next trace. (Not set by the SDK)\n *\n * Other values may be set as appropriate.\n * @see https://develop.sentry.dev/sdk/telemetry/traces/span-links/#link-types\n */\nexport const SEMANTIC_LINK_ATTRIBUTE_LINK_TYPE = 'sentry.link.type';\n"],"names":[],"mappings":"AAAA;;;;CAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACO,MAAM,gCAAA,GAAmC;AAEhD;;;;;CAKA,GACO,MAAM,qCAAA,GAAwC;AAErD;;;;;CAKA,GACO,MAAM,oDAAA,GAAuD;AAEpE;;CAEA,GACO,MAAM,4BAAA,GAA+B;AAE5C;;CAEA,GACO,MAAM,gCAAA,GAAmC;AAEhD,0CAAA,GACO,MAAM,iDAAA,GAAoD;AAEjE,oEAAA,GACO,MAAM,0CAAA,GAA6C;AAE1D,qEAAA,GACO,MAAM,2CAAA,GAA8C;AAE3D;;;;;;CAMA,GACO,MAAM,0CAAA,GAA6C;AAE1D;;CAEA,GACO,MAAM,6BAAA,GAAgC;AAEtC,MAAM,iCAAA,GAAoC;AAE1C,MAAM,4BAAA,GAA+B;AAErC,MAAM,4BAAA,GAA+B;AAErC,MAAM,kCAAA,GAAqC;AAElD,qEAAA,GACO,MAAM,sCAAA,GAAyC;AAC/C,MAAM,2BAAA,GAA8B;AAE3C;;;;;;;;;CASA,GACO,MAAM,iCAAA,GAAoC"}},
    {"offset": {"line": 1364, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/exports.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/exports.ts"],"sourcesContent":["import { getClient, getCurrentScope, getIsolationScope, withIsolationScope } from './currentScopes';\nimport { DEBUG_BUILD } from './debug-build';\nimport type { CaptureContext } from './scope';\nimport { closeSession, makeSession, updateSession } from './session';\nimport type { CheckIn, FinishedCheckIn, MonitorConfig } from './types-hoist/checkin';\nimport type { Event, EventHint } from './types-hoist/event';\nimport type { EventProcessor } from './types-hoist/eventprocessor';\nimport type { Extra, Extras } from './types-hoist/extra';\nimport type { Primitive } from './types-hoist/misc';\nimport type { Session, SessionContext } from './types-hoist/session';\nimport type { SeverityLevel } from './types-hoist/severity';\nimport type { User } from './types-hoist/user';\nimport { debug } from './utils/debug-logger';\nimport { isThenable } from './utils/is';\nimport { uuid4 } from './utils/misc';\nimport type { ExclusiveEventHintOrCaptureContext } from './utils/prepareEvent';\nimport { parseEventHintOrCaptureContext } from './utils/prepareEvent';\nimport { timestampInSeconds } from './utils/time';\nimport { GLOBAL_OBJ } from './utils/worldwide';\n\n/**\n * Captures an exception event and sends it to Sentry.\n *\n * @param exception The exception to capture.\n * @param hint Optional additional data to attach to the Sentry event.\n * @returns the id of the captured Sentry event.\n */\nexport function captureException(exception: unknown, hint?: ExclusiveEventHintOrCaptureContext): string {\n  return getCurrentScope().captureException(exception, parseEventHintOrCaptureContext(hint));\n}\n\n/**\n * Captures a message event and sends it to Sentry.\n *\n * @param message The message to send to Sentry.\n * @param captureContext Define the level of the message or pass in additional data to attach to the message.\n * @returns the id of the captured message.\n */\nexport function captureMessage(message: string, captureContext?: CaptureContext | SeverityLevel): string {\n  // This is necessary to provide explicit scopes upgrade, without changing the original\n  // arity of the `captureMessage(message, level)` method.\n  const level = typeof captureContext === 'string' ? captureContext : undefined;\n  const hint = typeof captureContext !== 'string' ? { captureContext } : undefined;\n  return getCurrentScope().captureMessage(message, level, hint);\n}\n\n/**\n * Captures a manually created event and sends it to Sentry.\n *\n * @param event The event to send to Sentry.\n * @param hint Optional additional data to attach to the Sentry event.\n * @returns the id of the captured event.\n */\nexport function captureEvent(event: Event, hint?: EventHint): string {\n  return getCurrentScope().captureEvent(event, hint);\n}\n\n/**\n * Sets context data with the given name.\n * @param name of the context\n * @param context Any kind of data. This data will be normalized.\n */\nexport function setContext(name: string, context: { [key: string]: unknown } | null): void {\n  getIsolationScope().setContext(name, context);\n}\n\n/**\n * Set an object that will be merged sent as extra data with the event.\n * @param extras Extras object to merge into current context.\n */\nexport function setExtras(extras: Extras): void {\n  getIsolationScope().setExtras(extras);\n}\n\n/**\n * Set key:value that will be sent as extra data with the event.\n * @param key String of extra\n * @param extra Any kind of data. This data will be normalized.\n */\nexport function setExtra(key: string, extra: Extra): void {\n  getIsolationScope().setExtra(key, extra);\n}\n\n/**\n * Set an object that will be merged sent as tags data with the event.\n * @param tags Tags context object to merge into current context.\n */\nexport function setTags(tags: { [key: string]: Primitive }): void {\n  getIsolationScope().setTags(tags);\n}\n\n/**\n * Set key:value that will be sent as tags data with the event.\n *\n * Can also be used to unset a tag, by passing `undefined`.\n *\n * @param key String key of tag\n * @param value Value of tag\n */\nexport function setTag(key: string, value: Primitive): void {\n  getIsolationScope().setTag(key, value);\n}\n\n/**\n * Updates user context information for future events.\n *\n * @param user User context object to be set in the current context. Pass `null` to unset the user.\n */\nexport function setUser(user: User | null): void {\n  getIsolationScope().setUser(user);\n}\n\n/**\n * The last error event id of the isolation scope.\n *\n * Warning: This function really returns the last recorded error event id on the current\n * isolation scope. If you call this function after handling a certain error and another error\n * is captured in between, the last one is returned instead of the one you might expect.\n * Also, ids of events that were never sent to Sentry (for example because\n * they were dropped in `beforeSend`) could be returned.\n *\n * @returns The last event id of the isolation scope.\n */\nexport function lastEventId(): string | undefined {\n  return getIsolationScope().lastEventId();\n}\n\n/**\n * Create a cron monitor check in and send it to Sentry.\n *\n * @param checkIn An object that describes a check in.\n * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n * to create a monitor automatically when sending a check in.\n */\nexport function captureCheckIn(checkIn: CheckIn, upsertMonitorConfig?: MonitorConfig): string {\n  const scope = getCurrentScope();\n  const client = getClient();\n  if (!client) {\n    DEBUG_BUILD && debug.warn('Cannot capture check-in. No client defined.');\n  } else if (!client.captureCheckIn) {\n    DEBUG_BUILD && debug.warn('Cannot capture check-in. Client does not support sending check-ins.');\n  } else {\n    return client.captureCheckIn(checkIn, upsertMonitorConfig, scope);\n  }\n\n  return uuid4();\n}\n\n/**\n * Wraps a callback with a cron monitor check in. The check in will be sent to Sentry when the callback finishes.\n *\n * @param monitorSlug The distinct slug of the monitor.\n * @param callback Callback to be monitored\n * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n * to create a monitor automatically when sending a check in.\n */\nexport function withMonitor<T>(\n  monitorSlug: CheckIn['monitorSlug'],\n  callback: () => T,\n  upsertMonitorConfig?: MonitorConfig,\n): T {\n  const checkInId = captureCheckIn({ monitorSlug, status: 'in_progress' }, upsertMonitorConfig);\n  const now = timestampInSeconds();\n\n  function finishCheckIn(status: FinishedCheckIn['status']): void {\n    captureCheckIn({ monitorSlug, status, checkInId, duration: timestampInSeconds() - now });\n  }\n\n  return withIsolationScope(() => {\n    let maybePromiseResult: T;\n    try {\n      maybePromiseResult = callback();\n    } catch (e) {\n      finishCheckIn('error');\n      throw e;\n    }\n\n    if (isThenable(maybePromiseResult)) {\n      return maybePromiseResult.then(\n        r => {\n          finishCheckIn('ok');\n          return r;\n        },\n        e => {\n          finishCheckIn('error');\n          throw e;\n        },\n      ) as T;\n    }\n    finishCheckIn('ok');\n\n    return maybePromiseResult;\n  });\n}\n\n/**\n * Call `flush()` on the current client, if there is one. See {@link Client.flush}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue. Omitting this parameter will cause\n * the client to wait until all events are sent before resolving the promise.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nexport async function flush(timeout?: number): Promise<boolean> {\n  const client = getClient();\n  if (client) {\n    return client.flush(timeout);\n  }\n  DEBUG_BUILD && debug.warn('Cannot flush events. No client defined.');\n  return Promise.resolve(false);\n}\n\n/**\n * Call `close()` on the current client, if there is one. See {@link Client.close}.\n *\n * @param timeout Maximum time in ms the client should wait to flush its event queue before shutting down. Omitting this\n * parameter will cause the client to wait until all events are sent before disabling itself.\n * @returns A promise which resolves to `true` if the queue successfully drains before the timeout, or `false` if it\n * doesn't (or if there's no client defined).\n */\nexport async function close(timeout?: number): Promise<boolean> {\n  const client = getClient();\n  if (client) {\n    return client.close(timeout);\n  }\n  DEBUG_BUILD && debug.warn('Cannot flush events and disable SDK. No client defined.');\n  return Promise.resolve(false);\n}\n\n/**\n * Returns true if Sentry has been properly initialized.\n */\nexport function isInitialized(): boolean {\n  return !!getClient();\n}\n\n/** If the SDK is initialized & enabled. */\nexport function isEnabled(): boolean {\n  const client = getClient();\n  return client?.getOptions().enabled !== false && !!client?.getTransport();\n}\n\n/**\n * Add an event processor.\n * This will be added to the current isolation scope, ensuring any event that is processed in the current execution\n * context will have the processor applied.\n */\nexport function addEventProcessor(callback: EventProcessor): void {\n  getIsolationScope().addEventProcessor(callback);\n}\n\n/**\n * Start a session on the current isolation scope.\n *\n * @param context (optional) additional properties to be applied to the returned session object\n *\n * @returns the new active session\n */\nexport function startSession(context?: SessionContext): Session {\n  const isolationScope = getIsolationScope();\n  const currentScope = getCurrentScope();\n\n  // Will fetch userAgent if called from browser sdk\n  const { userAgent } = GLOBAL_OBJ.navigator || {};\n\n  const session = makeSession({\n    user: currentScope.getUser() || isolationScope.getUser(),\n    ...(userAgent && { userAgent }),\n    ...context,\n  });\n\n  // End existing session if there's one\n  const currentSession = isolationScope.getSession();\n  if (currentSession?.status === 'ok') {\n    updateSession(currentSession, { status: 'exited' });\n  }\n\n  endSession();\n\n  // Afterwards we set the new session on the scope\n  isolationScope.setSession(session);\n\n  return session;\n}\n\n/**\n * End the session on the current isolation scope.\n */\nexport function endSession(): void {\n  const isolationScope = getIsolationScope();\n  const currentScope = getCurrentScope();\n\n  const session = currentScope.getSession() || isolationScope.getSession();\n  if (session) {\n    closeSession(session);\n  }\n  _sendSessionUpdate();\n\n  // the session is over; take it off of the scope\n  isolationScope.setSession();\n}\n\n/**\n * Sends the current Session on the scope\n */\nfunction _sendSessionUpdate(): void {\n  const isolationScope = getIsolationScope();\n  const client = getClient();\n  const session = isolationScope.getSession();\n  if (session && client) {\n    client.captureSession(session);\n  }\n}\n\n/**\n * Sends the current session on the scope to Sentry\n *\n * @param end If set the session will be marked as exited and removed from the scope.\n *            Defaults to `false`.\n */\nexport function captureSession(end: boolean = false): void {\n  // both send the update and pull the session from the scope\n  if (end) {\n    endSession();\n    return;\n  }\n\n  // only send the update\n  _sendSessionUpdate();\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1692, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/envelope.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/envelope.ts"],"sourcesContent":["import type { Client } from './client';\nimport { getDynamicSamplingContextFromSpan } from './tracing/dynamicSamplingContext';\nimport type { SentrySpan } from './tracing/sentrySpan';\nimport type { LegacyCSPReport } from './types-hoist/csp';\nimport type { DsnComponents } from './types-hoist/dsn';\nimport type {\n  DynamicSamplingContext,\n  EventEnvelope,\n  EventItem,\n  RawSecurityEnvelope,\n  RawSecurityItem,\n  SessionEnvelope,\n  SessionItem,\n  SpanEnvelope,\n  SpanItem,\n} from './types-hoist/envelope';\nimport type { Event } from './types-hoist/event';\nimport type { SdkInfo } from './types-hoist/sdkinfo';\nimport type { SdkMetadata } from './types-hoist/sdkmetadata';\nimport type { Session, SessionAggregates } from './types-hoist/session';\nimport { dsnToString } from './utils/dsn';\nimport {\n  createEnvelope,\n  createEventEnvelopeHeaders,\n  createSpanEnvelopeItem,\n  getSdkMetadataForEnvelopeHeader,\n} from './utils/envelope';\nimport { uuid4 } from './utils/misc';\nimport { shouldIgnoreSpan } from './utils/should-ignore-span';\nimport { showSpanDropWarning, spanToJSON } from './utils/spanUtils';\n\n/**\n * Apply SdkInfo (name, version, packages, integrations) to the corresponding event key.\n * Merge with existing data if any.\n *\n * @internal, exported only for testing\n **/\nexport function _enhanceEventWithSdkInfo(event: Event, newSdkInfo?: SdkInfo): Event {\n  if (!newSdkInfo) {\n    return event;\n  }\n\n  const eventSdkInfo = event.sdk || {};\n\n  event.sdk = {\n    ...eventSdkInfo,\n    name: eventSdkInfo.name || newSdkInfo.name,\n    version: eventSdkInfo.version || newSdkInfo.version,\n    integrations: [...(event.sdk?.integrations || []), ...(newSdkInfo.integrations || [])],\n    packages: [...(event.sdk?.packages || []), ...(newSdkInfo.packages || [])],\n    settings:\n      event.sdk?.settings || newSdkInfo.settings\n        ? {\n            ...event.sdk?.settings,\n            ...newSdkInfo.settings,\n          }\n        : undefined,\n  };\n\n  return event;\n}\n\n/** Creates an envelope from a Session */\nexport function createSessionEnvelope(\n  session: Session | SessionAggregates,\n  dsn?: DsnComponents,\n  metadata?: SdkMetadata,\n  tunnel?: string,\n): SessionEnvelope {\n  const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);\n  const envelopeHeaders = {\n    sent_at: new Date().toISOString(),\n    ...(sdkInfo && { sdk: sdkInfo }),\n    ...(!!tunnel && dsn && { dsn: dsnToString(dsn) }),\n  };\n\n  const envelopeItem: SessionItem =\n    'aggregates' in session ? [{ type: 'sessions' }, session] : [{ type: 'session' }, session.toJSON()];\n\n  return createEnvelope<SessionEnvelope>(envelopeHeaders, [envelopeItem]);\n}\n\n/**\n * Create an Envelope from an event.\n */\nexport function createEventEnvelope(\n  event: Event,\n  dsn?: DsnComponents,\n  metadata?: SdkMetadata,\n  tunnel?: string,\n): EventEnvelope {\n  const sdkInfo = getSdkMetadataForEnvelopeHeader(metadata);\n\n  /*\n    Note: Due to TS, event.type may be `replay_event`, theoretically.\n    In practice, we never call `createEventEnvelope` with `replay_event` type,\n    and we'd have to adjust a looot of types to make this work properly.\n    We want to avoid casting this around, as that could lead to bugs (e.g. when we add another type)\n    So the safe choice is to really guard against the replay_event type here.\n  */\n  const eventType = event.type && event.type !== 'replay_event' ? event.type : 'event';\n\n  _enhanceEventWithSdkInfo(event, metadata?.sdk);\n\n  const envelopeHeaders = createEventEnvelopeHeaders(event, sdkInfo, tunnel, dsn);\n\n  // Prevent this data (which, if it exists, was used in earlier steps in the processing pipeline) from being sent to\n  // sentry. (Note: Our use of this property comes and goes with whatever we might be debugging, whatever hacks we may\n  // have temporarily added, etc. Even if we don't happen to be using it at some point in the future, let's not get rid\n  // of this `delete`, lest we miss putting it back in the next time the property is in use.)\n  delete event.sdkProcessingMetadata;\n\n  const eventItem: EventItem = [{ type: eventType }, event];\n  return createEnvelope<EventEnvelope>(envelopeHeaders, [eventItem]);\n}\n\n/**\n * Create envelope from Span item.\n *\n * Takes an optional client and runs spans through `beforeSendSpan` if available.\n */\nexport function createSpanEnvelope(spans: [SentrySpan, ...SentrySpan[]], client?: Client): SpanEnvelope {\n  function dscHasRequiredProps(dsc: Partial<DynamicSamplingContext>): dsc is DynamicSamplingContext {\n    return !!dsc.trace_id && !!dsc.public_key;\n  }\n\n  // For the moment we'll obtain the DSC from the first span in the array\n  // This might need to be changed if we permit sending multiple spans from\n  // different segments in one envelope\n  const dsc = getDynamicSamplingContextFromSpan(spans[0]);\n\n  const dsn = client?.getDsn();\n  const tunnel = client?.getOptions().tunnel;\n\n  const headers: SpanEnvelope[0] = {\n    sent_at: new Date().toISOString(),\n    ...(dscHasRequiredProps(dsc) && { trace: dsc }),\n    ...(!!tunnel && dsn && { dsn: dsnToString(dsn) }),\n  };\n\n  const { beforeSendSpan, ignoreSpans } = client?.getOptions() || {};\n\n  const filteredSpans = ignoreSpans?.length\n    ? spans.filter(span => !shouldIgnoreSpan(spanToJSON(span), ignoreSpans))\n    : spans;\n  const droppedSpans = spans.length - filteredSpans.length;\n\n  if (droppedSpans) {\n    client?.recordDroppedEvent('before_send', 'span', droppedSpans);\n  }\n\n  const convertToSpanJSON = beforeSendSpan\n    ? (span: SentrySpan) => {\n        const spanJson = spanToJSON(span);\n        const processedSpan = beforeSendSpan(spanJson);\n\n        if (!processedSpan) {\n          showSpanDropWarning();\n          return spanJson;\n        }\n\n        return processedSpan;\n      }\n    : spanToJSON;\n\n  const items: SpanItem[] = [];\n  for (const span of filteredSpans) {\n    const spanJson = convertToSpanJSON(span);\n    if (spanJson) {\n      items.push(createSpanEnvelopeItem(spanJson));\n    }\n  }\n\n  return createEnvelope<SpanEnvelope>(headers, items);\n}\n\n/**\n * Create an Envelope from a CSP report.\n */\nexport function createRawSecurityEnvelope(\n  report: LegacyCSPReport,\n  dsn: DsnComponents,\n  tunnel?: string,\n  release?: string,\n  environment?: string,\n): RawSecurityEnvelope {\n  const envelopeHeaders = {\n    event_id: uuid4(),\n    ...(!!tunnel && dsn && { dsn: dsnToString(dsn) }),\n  };\n\n  const eventItem: RawSecurityItem = [\n    { type: 'raw_security', sentry_release: release, sentry_environment: environment },\n    report,\n  ];\n\n  return createEnvelope<RawSecurityEnvelope>(envelopeHeaders, [eventItem]);\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AA+BA;;;;;EAKA,GACO,SAAS,wBAAwB,CAAC,KAAK,EAAS,UAAU,EAAmB;IAClF,IAAI,CAAC,UAAU,EAAE;QACf,OAAO,KAAK;IACd;IAEA,MAAM,eAAe,KAAK,CAAC,GAAA,IAAO,CAAA,CAAE;IAEpC,KAAK,CAAC,GAAA,GAAM;QACV,GAAG,YAAY;QACf,IAAI,EAAE,YAAY,CAAC,IAAA,IAAQ,UAAU,CAAC,IAAI;QAC1C,OAAO,EAAE,YAAY,CAAC,OAAA,IAAW,UAAU,CAAC,OAAO;QACnD,YAAY,EAAE,CAAC;eAAI,KAAK,CAAC,GAAG,EAAE,YAAA,IAAgB,EAAE,CAAC,EAAE;eAAI,UAAU,CAAC,YAAA,IAAgB,EAAE,CAAC;SAAC;QACtF,QAAQ,EAAE,CAAC;eAAI,KAAK,CAAC,GAAG,EAAE,QAAA,IAAY,EAAE,CAAC,EAAE;eAAI,UAAU,CAAC,QAAA,IAAY,EAAE,CAAC;SAAC;QAC1E,QAAQ,EACN,KAAK,CAAC,GAAG,EAAE,QAAA,IAAY,UAAU,CAAC,QAAA,GAC9B;YACE,GAAG,KAAK,CAAC,GAAG,EAAE,QAAQ;YACtB,GAAG,UAAU,CAAC,QAAQ;QAClC,IACU,SAAS;IACnB,CAAG;IAED,OAAO,KAAK;AACd;AAEA,uCAAA,GACO,SAAS,qBAAqB,CACnC,OAAO,EACP,GAAG,EACH,QAAQ,EACR,MAAM;IAEN,MAAM,OAAA,OAAU,0QAA+B,EAAC,QAAQ,CAAC;IACzD,MAAM,kBAAkB;QACtB,OAAO,EAAE,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE;QACjC,GAAI,OAAA,IAAW;YAAE,GAAG,EAAE,OAAA;QAAA,CAAS,CAAC;QAChC,GAAI,CAAC,CAAC,MAAA,IAAU,GAAA,IAAO;YAAE,GAAG,MAAE,iPAAW,EAAC,GAAG,CAAA;QAAA,CAAG,CAAC;IACrD,CAAG;IAED,MAAM,YAAY,GAChB,YAAA,IAAgB,OAAA,GAAU;QAAC;YAAE,IAAI,EAAE,UAAA;QAAA,CAAY;QAAE,OAAO;KAAA,GAAI;QAAC;YAAE,IAAI,EAAE,SAAA;QAAA,CAAW;QAAE,OAAO,CAAC,MAAM,EAAE;KAAC;IAErG,WAAO,yPAAc,EAAkB,eAAe,EAAE;QAAC,YAAY;KAAC,CAAC;AACzE;AAEA;;CAEA,GACO,SAAS,mBAAmB,CACjC,KAAK,EACL,GAAG,EACH,QAAQ,EACR,MAAM;IAEN,MAAM,OAAA,OAAU,0QAA+B,EAAC,QAAQ,CAAC;IAE3D;;;;;;EAMA,GACE,MAAM,SAAA,GAAY,KAAK,CAAC,IAAA,IAAQ,KAAK,CAAC,IAAA,KAAS,cAAA,GAAiB,KAAK,CAAC,IAAA,GAAO,OAAO;IAEpF,wBAAwB,CAAC,KAAK,EAAE,QAAQ,EAAE,GAAG,CAAC;IAE9C,MAAM,eAAA,OAAkB,qQAA0B,EAAC,KAAK,EAAE,OAAO,EAAE,MAAM,EAAE,GAAG,CAAC;IAEjF,mHAAA;IACA,oHAAA;IACA,qHAAA;IACA,2FAAA;IACE,OAAO,KAAK,CAAC,qBAAqB;IAElC,MAAM,SAAS,GAAc;QAAC;YAAE,IAAI,EAAE,SAAA;QAAA,CAAW;QAAE,KAAK;KAAC;IACzD,WAAO,yPAAc,EAAgB,eAAe,EAAE;QAAC,SAAS;KAAC,CAAC;AACpE;AAEA;;;;CAIA,GACO,SAAS,kBAAkB,CAAC,KAAK,EAAiC,MAAM,EAAyB;IACtG,SAAS,mBAAmB,CAAC,GAAG,EAAkE;QAChG,OAAO,CAAC,CAAC,GAAG,CAAC,QAAA,IAAY,CAAC,CAAC,GAAG,CAAC,UAAU;IAC3C;IAEF,uEAAA;IACA,yEAAA;IACA,qCAAA;IACE,MAAM,UAAM,4RAAiC,EAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IAEvD,MAAM,GAAA,GAAM,MAAM,EAAE,MAAM,EAAE;IAC5B,MAAM,SAAS,MAAM,EAAE,UAAU,EAAE,CAAC,MAAM;IAE1C,MAAM,OAAO,GAAoB;QAC/B,OAAO,EAAE,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE;QACjC,GAAI,mBAAmB,CAAC,GAAG,CAAA,IAAK;YAAE,KAAK,EAAE,GAAA;QAAA,CAAK,CAAC;QAC/C,GAAI,CAAC,CAAC,MAAA,IAAU,GAAA,IAAO;YAAE,GAAG,MAAE,iPAAW,EAAC,GAAG,CAAA;QAAA,CAAG,CAAC;IACrD,CAAG;IAED,MAAM,EAAE,cAAc,EAAE,WAAA,EAAY,GAAI,MAAM,EAAE,UAAU,EAAC,IAAK,CAAA,CAAE;IAElE,MAAM,aAAA,GAAgB,WAAW,EAAE,SAC/B,KAAK,CAAC,MAAM,EAAC,OAAQ,KAAC,2QAAgB,MAAC,sPAAU,EAAC,IAAI,CAAC,EAAE,WAAW,CAAC,IACrE,KAAK;IACT,MAAM,eAAe,KAAK,CAAC,MAAA,GAAS,aAAa,CAAC,MAAM;IAExD,IAAI,YAAY,EAAE;QAChB,MAAM,EAAE,kBAAkB,CAAC,aAAa,EAAE,MAAM,EAAE,YAAY,CAAC;IACjE;IAEA,MAAM,oBAAoB,iBACtB,CAAC,IAAI,KAAiB;QACpB,MAAM,QAAA,OAAW,sPAAU,EAAC,IAAI,CAAC;QACjC,MAAM,aAAA,GAAgB,cAAc,CAAC,QAAQ,CAAC;QAE9C,IAAI,CAAC,aAAa,EAAE;gBAClB,+PAAmB,EAAE;YACrB,OAAO,QAAQ;QACjB;QAEA,OAAO,aAAa;IACtB,IACA,sPAAU;IAEd,MAAM,KAAK,GAAe,EAAE;IAC5B,KAAK,MAAM,IAAA,IAAQ,aAAa,CAAE;QAChC,MAAM,QAAA,GAAW,iBAAiB,CAAC,IAAI,CAAC;QACxC,IAAI,QAAQ,EAAE;YACZ,KAAK,CAAC,IAAI,KAAC,iQAAsB,EAAC,QAAQ,CAAC,CAAC;QAC9C;IACF;IAEA,WAAO,yPAAc,EAAe,OAAO,EAAE,KAAK,CAAC;AACrD"}},
    {"offset": {"line": 1848, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/vendor/getIpAddress.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/vendor/getIpAddress.ts"],"sourcesContent":["// Vendored / modified from @sergiodxa/remix-utils\n\n// https://github.com/sergiodxa/remix-utils/blob/02af80e12829a53696bfa8f3c2363975cf59f55e/src/server/get-client-ip-address.ts\n// MIT License\n\n// Copyright (c) 2021 Sergio XalambrÃ­\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n// The headers to check, in priority order\nexport const ipHeaderNames = [\n  'X-Client-IP',\n  'X-Forwarded-For',\n  'Fly-Client-IP',\n  'CF-Connecting-IP',\n  'Fastly-Client-Ip',\n  'True-Client-Ip',\n  'X-Real-IP',\n  'X-Cluster-Client-IP',\n  'X-Forwarded',\n  'Forwarded-For',\n  'Forwarded',\n  'X-Vercel-Forwarded-For',\n];\n\n/**\n * Get the IP address of the client sending a request.\n *\n * It receives a Request headers object and use it to get the\n * IP address from one of the following headers in order.\n *\n * If the IP address is valid, it will be returned. Otherwise, null will be\n * returned.\n *\n * If the header values contains more than one IP address, the first valid one\n * will be returned.\n */\nexport function getClientIPAddress(headers: { [key: string]: string | string[] | undefined }): string | null {\n  // This will end up being Array<string | string[] | undefined | null> because of the various possible values a header\n  // can take\n  const headerValues = ipHeaderNames.map((headerName: string) => {\n    const rawValue = headers[headerName];\n    const value = Array.isArray(rawValue) ? rawValue.join(';') : rawValue;\n\n    if (headerName === 'Forwarded') {\n      return parseForwardedHeader(value);\n    }\n\n    return value?.split(',').map((v: string) => v.trim());\n  });\n\n  // Flatten the array and filter out any falsy entries\n  const flattenedHeaderValues = headerValues.reduce((acc: string[], val) => {\n    if (!val) {\n      return acc;\n    }\n\n    return acc.concat(val);\n  }, []);\n\n  // Find the first value which is a valid IP address, if any\n  const ipAddress = flattenedHeaderValues.find(ip => ip !== null && isIP(ip));\n\n  return ipAddress || null;\n}\n\nfunction parseForwardedHeader(value: string | null | undefined): string | null {\n  if (!value) {\n    return null;\n  }\n\n  for (const part of value.split(';')) {\n    if (part.startsWith('for=')) {\n      return part.slice(4);\n    }\n  }\n\n  return null;\n}\n\n//\n/**\n * Custom method instead of importing this from `net` package, as this only exists in node\n * Accepts:\n * 127.0.0.1\n * 192.168.1.1\n * 192.168.1.255\n * 255.255.255.255\n * 10.1.1.1\n * 0.0.0.0\n * 2b01:cb19:8350:ed00:d0dd:fa5b:de31:8be5\n *\n * Rejects:\n * 1.1.1.01\n * 30.168.1.255.1\n * 127.1\n * 192.168.1.256\n * -1.2.3.4\n * 1.1.1.1.\n * 3...3\n * 192.168.1.099\n */\nfunction isIP(str: string): boolean {\n  const regex =\n    /(?:^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$)|(?:^(?:(?:[a-fA-F\\d]{1,4}:){7}(?:[a-fA-F\\d]{1,4}|:)|(?:[a-fA-F\\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|:[a-fA-F\\d]{1,4}|:)|(?:[a-fA-F\\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,2}|:)|(?:[a-fA-F\\d]{1,4}:){4}(?:(?::[a-fA-F\\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,3}|:)|(?:[a-fA-F\\d]{1,4}:){3}(?:(?::[a-fA-F\\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,4}|:)|(?:[a-fA-F\\d]{1,4}:){2}(?:(?::[a-fA-F\\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,5}|:)|(?:[a-fA-F\\d]{1,4}:){1}(?:(?::[a-fA-F\\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,6}|:)|(?::(?:(?::[a-fA-F\\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,7}|:)))(?:%[0-9a-zA-Z]{1,})?$)/;\n  return regex.test(str);\n}\n"],"names":[],"mappings":"AAAA,kDAAA;AAEA,6HAAA;AACA,cAAA;AAEA,qCAAA;AAEA,+EAAA;AACA,gFAAA;AACA,+EAAA;AACA,4EAAA;AACA,wEAAA;AACA,2DAAA;AAEA,iFAAA;AACA,kDAAA;AAEA,6EAAA;AACA,2EAAA;AACA,8EAAA;AACA,yEAAA;AACA,gFAAA;AACA,gFAAA;AACA,YAAA;AAEA,0CAAA;;;;;;;AACO,MAAM,gBAAgB;IAC3B,aAAa;IACb,iBAAiB;IACjB,eAAe;IACf,kBAAkB;IAClB,kBAAkB;IAClB,gBAAgB;IAChB,WAAW;IACX,qBAAqB;IACrB,aAAa;IACb,eAAe;IACf,WAAW;IACX,wBAAwB;CAC1B;AAEA;;;;;;;;;;;CAWA,GACO,SAAS,kBAAkB,CAAC,OAAO,EAAmE;IAC7G,qHAAA;IACA,WAAA;IACE,MAAM,YAAA,GAAe,aAAa,CAAC,GAAG,CAAC,CAAC,UAAU,KAAa;QAC7D,MAAM,QAAA,GAAW,OAAO,CAAC,UAAU,CAAC;QACpC,MAAM,KAAA,GAAQ,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAA,GAAI,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAA,GAAI,QAAQ;QAErE,IAAI,UAAA,KAAe,WAAW,EAAE;YAC9B,OAAO,oBAAoB,CAAC,KAAK,CAAC;QACpC;QAEA,OAAO,KAAK,EAAE,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,GAAa,CAAC,CAAC,IAAI,EAAE,CAAC;IACvD,CAAC,CAAC;IAEJ,qDAAA;IACE,MAAM,qBAAA,GAAwB,YAAY,CAAC,MAAM,CAAC,CAAC,GAAG,EAAY,GAAG,KAAK;QACxE,IAAI,CAAC,GAAG,EAAE;YACR,OAAO,GAAG;QACZ;QAEA,OAAO,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC;IACxB,CAAC,EAAE,EAAE,CAAC;IAER,2DAAA;IACE,MAAM,SAAA,GAAY,qBAAqB,CAAC,IAAI,EAAC,EAAA,GAAM,EAAA,KAAO,IAAA,IAAQ,IAAI,CAAC,EAAE,CAAC,CAAC;IAE3E,OAAO,SAAA,IAAa,IAAI;AAC1B;AAEA,SAAS,oBAAoB,CAAC,KAAK,EAA4C;IAC7E,IAAI,CAAC,KAAK,EAAE;QACV,OAAO,IAAI;IACb;IAEA,KAAK,MAAM,IAAA,IAAQ,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAE;QACnC,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,EAAE;YAC3B,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;QACtB;IACF;IAEA,OAAO,IAAI;AACb;AAEA,EAAA;AACA;;;;;;;;;;;;;;;;;;;;CAoBA,GACA,SAAS,IAAI,CAAC,GAAG,EAAmB;IAClC,MAAM,KAAA,GACJ,muCAAmuC;IACruC,OAAO,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC;AACxB"}},
    {"offset": {"line": 1963, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/instrument/handlers.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/instrument/handlers.ts"],"sourcesContent":["import { DEBUG_BUILD } from '../debug-build';\nimport { debug } from '../utils/debug-logger';\nimport { getFunctionName } from '../utils/stacktrace';\n\nexport type InstrumentHandlerType =\n  | 'console'\n  | 'dom'\n  | 'fetch'\n  | 'fetch-body-resolved'\n  | 'history'\n  | 'xhr'\n  | 'error'\n  | 'unhandledrejection';\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type InstrumentHandlerCallback = (data: any) => void;\n\n// We keep the handlers globally\nconst handlers: { [key in InstrumentHandlerType]?: InstrumentHandlerCallback[] } = {};\nconst instrumented: { [key in InstrumentHandlerType]?: boolean } = {};\n\n/** Add a handler function. */\nexport function addHandler(type: InstrumentHandlerType, handler: InstrumentHandlerCallback): void {\n  handlers[type] = handlers[type] || [];\n  handlers[type].push(handler);\n}\n\n/**\n * Reset all instrumentation handlers.\n * This can be used by tests to ensure we have a clean slate of instrumentation handlers.\n */\nexport function resetInstrumentationHandlers(): void {\n  Object.keys(handlers).forEach(key => {\n    handlers[key as InstrumentHandlerType] = undefined;\n  });\n}\n\n/** Maybe run an instrumentation function, unless it was already called. */\nexport function maybeInstrument(type: InstrumentHandlerType, instrumentFn: () => void): void {\n  if (!instrumented[type]) {\n    instrumented[type] = true;\n    try {\n      instrumentFn();\n    } catch (e) {\n      DEBUG_BUILD && debug.error(`Error while instrumenting ${type}`, e);\n    }\n  }\n}\n\n/** Trigger handlers for a given instrumentation type. */\nexport function triggerHandlers(type: InstrumentHandlerType, data: unknown): void {\n  const typeHandlers = type && handlers[type];\n  if (!typeHandlers) {\n    return;\n  }\n\n  for (const handler of typeHandlers) {\n    try {\n      handler(data);\n    } catch (e) {\n      DEBUG_BUILD &&\n        debug.error(\n          `Error while triggering instrumentation handler.\\nType: ${type}\\nName: ${getFunctionName(handler)}\\nError:`,\n          e,\n        );\n    }\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAgBA,gCAAA;AACA,MAAM,QAAQ,GAAqE,CAAA,CAAE;AACrF,MAAM,YAAY,GAAiD,CAAA,CAAE;AAErE,4BAAA,GACO,SAAS,UAAU,CAAC,IAAI,EAAyB,OAAO,EAAmC;IAChG,QAAQ,CAAC,IAAI,CAAA,GAAI,QAAQ,CAAC,IAAI,CAAA,IAAK,EAAE;IACrC,QAAQ,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC;AAC9B;AAEA;;;CAGA,GACO,SAAS,4BAA4B,GAAS;IACnD,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,OAAO,EAAC,GAAA,IAAO;QACnC,QAAQ,CAAC,GAAA,CAAI,GAA4B,SAAS;IACpD,CAAC,CAAC;AACJ;AAEA,yEAAA,GACO,SAAS,eAAe,CAAC,IAAI,EAAyB,YAAY,EAAoB;IAC3F,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,EAAE;QACvB,YAAY,CAAC,IAAI,CAAA,GAAI,IAAI;QACzB,IAAI;YACF,YAAY,EAAE;QAChB,CAAA,CAAE,OAAO,CAAC,EAAE;YACV,mPAAA,IAAe,uPAAK,CAAC,KAAK,CAAC,CAAC,0BAA0B,EAAE,IAAI,CAAC,CAAA,EAAA,CAAA,CAAA;QACA;IACA;AACA;AAEA,uDAAA,GACA,SAAA,eAAA,CAAA,IAAA,EAAA,IAAA,EAAA;IACA,MAAA,YAAA,GAAA,IAAA,IAAA,QAAA,CAAA,IAAA,CAAA;IACA,IAAA,CAAA,YAAA,EAAA;QACA;IACA;IAEA,KAAA,MAAA,OAAA,IAAA,YAAA,CAAA;QACA,IAAA;YACA,OAAA,CAAA,IAAA,CAAA;QACA,CAAA,CAAA,OAAA,CAAA,EAAA;YACA,mPAAA,IACA,uPAAA,CAAA,KAAA,CACA,CAAA,uDAAA,EAAA,IAAA,CAAA,QAAA,MAAA,4PAAA,EAAA,OAAA,CAAA,CAAA,QAAA,CAAA,EACA,CAAA;QAEA;IACA;AACA"}},
    {"offset": {"line": 2023, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/instrument/console.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/instrument/console.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/ban-types */\nimport type { ConsoleLevel, HandlerDataConsole } from '../types-hoist/instrument';\nimport { CONSOLE_LEVELS, originalConsoleMethods } from '../utils/debug-logger';\nimport { fill } from '../utils/object';\nimport { GLOBAL_OBJ } from '../utils/worldwide';\nimport { addHandler, maybeInstrument, triggerHandlers } from './handlers';\n\n/**\n * Add an instrumentation handler for when a console.xxx method is called.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nexport function addConsoleInstrumentationHandler(handler: (data: HandlerDataConsole) => void): void {\n  const type = 'console';\n  addHandler(type, handler);\n  maybeInstrument(type, instrumentConsole);\n}\n\nfunction instrumentConsole(): void {\n  if (!('console' in GLOBAL_OBJ)) {\n    return;\n  }\n\n  CONSOLE_LEVELS.forEach(function (level: ConsoleLevel): void {\n    if (!(level in GLOBAL_OBJ.console)) {\n      return;\n    }\n\n    fill(GLOBAL_OBJ.console, level, function (originalConsoleMethod: () => any): Function {\n      originalConsoleMethods[level] = originalConsoleMethod;\n\n      return function (...args: any[]): void {\n        const handlerData: HandlerDataConsole = { args, level };\n        triggerHandlers('console', handlerData);\n\n        const log = originalConsoleMethods[level];\n        log?.apply(GLOBAL_OBJ.console, args);\n      };\n    });\n  });\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAQA;;;;;CAKA,GACO,SAAS,gCAAgC,CAAC,OAAO,EAA4C;IAClG,MAAM,IAAA,GAAO,SAAS;QACtB,0PAAU,EAAC,IAAI,EAAE,OAAO,CAAC;QACzB,+PAAe,EAAC,IAAI,EAAE,iBAAiB,CAAC;AAC1C;AAEA,SAAS,iBAAiB,GAAS;IACjC,IAAI,CAAA,CAAE,aAAa,sPAAU,CAAC,EAAE;QAC9B;IACF;IAEA,gQAAc,CAAC,OAAO,CAAC,SAAU,KAAK,EAAsB;QAC1D,IAAI,CAAA,CAAE,KAAA,IAAS,sPAAU,CAAC,OAAO,CAAC,EAAE;YAClC;QACF;YAEA,6OAAI,EAAC,sPAAU,CAAC,OAAO,EAAE,KAAK,EAAE,SAAU,qBAAqB,EAAuB;YACpF,wQAAsB,CAAC,KAAK,CAAA,GAAI,qBAAqB;YAErD,OAAO,SAAU,GAAG,IAAI,EAAe;gBACrC,MAAM,WAAW,GAAuB;oBAAE,IAAI;oBAAE;gBAAA,CAAO;oBACvD,+PAAe,EAAC,SAAS,EAAE,WAAW,CAAC;gBAEvC,MAAM,GAAA,GAAM,wQAAsB,CAAC,KAAK,CAAC;gBACzC,GAAG,EAAE,KAAK,CAAC,sPAAU,CAAC,OAAO,EAAE,IAAI,CAAC;YACtC,CAAC;QACH,CAAC,CAAC;IACJ,CAAC,CAAC;AACJ"}},
    {"offset": {"line": 2073, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/instrument/globalError.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/instrument/globalError.ts"],"sourcesContent":["import type { HandlerDataError } from '../types-hoist/instrument';\nimport { GLOBAL_OBJ } from '../utils/worldwide';\nimport { addHandler, maybeInstrument, triggerHandlers } from './handlers';\n\nlet _oldOnErrorHandler: (typeof GLOBAL_OBJ)['onerror'] | null = null;\n\n/**\n * Add an instrumentation handler for when an error is captured by the global error handler.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nexport function addGlobalErrorInstrumentationHandler(handler: (data: HandlerDataError) => void): void {\n  const type = 'error';\n  addHandler(type, handler);\n  maybeInstrument(type, instrumentError);\n}\n\nfunction instrumentError(): void {\n  _oldOnErrorHandler = GLOBAL_OBJ.onerror;\n\n  // Note: The reason we are doing window.onerror instead of window.addEventListener('error')\n  // is that we are using this handler in the Loader Script, to handle buffered errors consistently\n  GLOBAL_OBJ.onerror = function (\n    msg: string | object,\n    url?: string,\n    line?: number,\n    column?: number,\n    error?: Error,\n  ): boolean {\n    const handlerData: HandlerDataError = {\n      column,\n      error,\n      line,\n      msg,\n      url,\n    };\n    triggerHandlers('error', handlerData);\n\n    if (_oldOnErrorHandler) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnErrorHandler.apply(this, arguments);\n    }\n\n    return false;\n  };\n\n  GLOBAL_OBJ.onerror.__SENTRY_INSTRUMENTED__ = true;\n}\n"],"names":[],"mappings":";;;;;;;;AAIA,IAAI,kBAAkB,GAA0C,IAAI;AAEpE;;;;;CAKA,GACO,SAAS,oCAAoC,CAAC,OAAO,EAA0C;IACpG,MAAM,IAAA,GAAO,OAAO;QACpB,0PAAU,EAAC,IAAI,EAAE,OAAO,CAAC;QACzB,+PAAe,EAAC,IAAI,EAAE,eAAe,CAAC;AACxC;AAEA,SAAS,eAAe,GAAS;IAC/B,kBAAA,GAAqB,sPAAU,CAAC,OAAO;IAEzC,2FAAA;IACA,iGAAA;IACE,sPAAU,CAAC,OAAA,GAAU,SACnB,GAAG,EACH,GAAG,EACH,IAAI,EACJ,MAAM,EACN,KAAK;QAEL,MAAM,WAAW,GAAqB;YACpC,MAAM;YACN,KAAK;YACL,IAAI;YACJ,GAAG;YACH,GAAG;QACT,CAAK;YACD,+PAAe,EAAC,OAAO,EAAE,WAAW,CAAC;QAErC,IAAI,kBAAkB,EAAE;YAC5B,8CAAA;YACM,OAAO,kBAAkB,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC;QAClD;QAEA,OAAO,KAAK;IACd,CAAC;IAED,sPAAU,CAAC,OAAO,CAAC,uBAAA,GAA0B,IAAI;AACnD"}},
    {"offset": {"line": 2119, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/instrument/globalUnhandledRejection.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/instrument/globalUnhandledRejection.ts"],"sourcesContent":["import type { HandlerDataUnhandledRejection } from '../types-hoist/instrument';\nimport { GLOBAL_OBJ } from '../utils/worldwide';\nimport { addHandler, maybeInstrument, triggerHandlers } from './handlers';\n\nlet _oldOnUnhandledRejectionHandler: (typeof GLOBAL_OBJ)['onunhandledrejection'] | null = null;\n\n/**\n * Add an instrumentation handler for when an unhandled promise rejection is captured.\n *\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nexport function addGlobalUnhandledRejectionInstrumentationHandler(\n  handler: (data: HandlerDataUnhandledRejection) => void,\n): void {\n  const type = 'unhandledrejection';\n  addHandler(type, handler);\n  maybeInstrument(type, instrumentUnhandledRejection);\n}\n\nfunction instrumentUnhandledRejection(): void {\n  _oldOnUnhandledRejectionHandler = GLOBAL_OBJ.onunhandledrejection;\n\n  // Note: The reason we are doing window.onunhandledrejection instead of window.addEventListener('unhandledrejection')\n  // is that we are using this handler in the Loader Script, to handle buffered rejections consistently\n  GLOBAL_OBJ.onunhandledrejection = function (e: unknown): boolean {\n    const handlerData: HandlerDataUnhandledRejection = e;\n    triggerHandlers('unhandledrejection', handlerData);\n\n    if (_oldOnUnhandledRejectionHandler) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnUnhandledRejectionHandler.apply(this, arguments);\n    }\n\n    return true;\n  };\n\n  GLOBAL_OBJ.onunhandledrejection.__SENTRY_INSTRUMENTED__ = true;\n}\n"],"names":[],"mappings":";;;;;;;;AAIA,IAAI,+BAA+B,GAAuD,IAAI;AAE9F;;;;;CAKA,GACO,SAAS,iDAAiD,CAC/D,OAAO;IAEP,MAAM,IAAA,GAAO,oBAAoB;QACjC,0PAAU,EAAC,IAAI,EAAE,OAAO,CAAC;QACzB,+PAAe,EAAC,IAAI,EAAE,4BAA4B,CAAC;AACrD;AAEA,SAAS,4BAA4B,GAAS;IAC5C,+BAAA,GAAkC,sPAAU,CAAC,oBAAoB;IAEnE,qHAAA;IACA,qGAAA;IACE,sPAAU,CAAC,oBAAA,GAAuB,SAAU,CAAC,EAAoB;QAC/D,MAAM,WAAW,GAAkC,CAAC;YACpD,+PAAe,EAAC,oBAAoB,EAAE,WAAW,CAAC;QAElD,IAAI,+BAA+B,EAAE;YACzC,8CAAA;YACM,OAAO,+BAA+B,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC;QAC/D;QAEA,OAAO,IAAI;IACb,CAAC;IAED,sPAAU,CAAC,oBAAoB,CAAC,uBAAA,GAA0B,IAAI;AAChE"}},
    {"offset": {"line": 2159, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/transports/base.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/transports/base.ts"],"sourcesContent":["import { DEBUG_BUILD } from '../debug-build';\nimport type { EventDropReason } from '../types-hoist/clientreport';\nimport type { Envelope, EnvelopeItem } from '../types-hoist/envelope';\nimport type {\n  InternalBaseTransportOptions,\n  Transport,\n  TransportMakeRequestResponse,\n  TransportRequestExecutor,\n} from '../types-hoist/transport';\nimport { debug } from '../utils/debug-logger';\nimport {\n  createEnvelope,\n  envelopeItemTypeToDataCategory,\n  forEachEnvelopeItem,\n  serializeEnvelope,\n} from '../utils/envelope';\nimport { type PromiseBuffer, makePromiseBuffer, SENTRY_BUFFER_FULL_ERROR } from '../utils/promisebuffer';\nimport { type RateLimits, isRateLimited, updateRateLimits } from '../utils/ratelimit';\n\nexport const DEFAULT_TRANSPORT_BUFFER_SIZE = 64;\n\n/**\n * Creates an instance of a Sentry `Transport`\n *\n * @param options\n * @param makeRequest\n */\nexport function createTransport(\n  options: InternalBaseTransportOptions,\n  makeRequest: TransportRequestExecutor,\n  buffer: PromiseBuffer<TransportMakeRequestResponse> = makePromiseBuffer(\n    options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE,\n  ),\n): Transport {\n  let rateLimits: RateLimits = {};\n  const flush = (timeout?: number): PromiseLike<boolean> => buffer.drain(timeout);\n\n  function send(envelope: Envelope): PromiseLike<TransportMakeRequestResponse> {\n    const filteredEnvelopeItems: EnvelopeItem[] = [];\n\n    // Drop rate limited items from envelope\n    forEachEnvelopeItem(envelope, (item, type) => {\n      const dataCategory = envelopeItemTypeToDataCategory(type);\n      if (isRateLimited(rateLimits, dataCategory)) {\n        options.recordDroppedEvent('ratelimit_backoff', dataCategory);\n      } else {\n        filteredEnvelopeItems.push(item);\n      }\n    });\n\n    // Skip sending if envelope is empty after filtering out rate limited events\n    if (filteredEnvelopeItems.length === 0) {\n      return Promise.resolve({});\n    }\n\n    const filteredEnvelope: Envelope = createEnvelope(envelope[0], filteredEnvelopeItems as (typeof envelope)[1]);\n\n    // Creates client report for each item in an envelope\n    const recordEnvelopeLoss = (reason: EventDropReason): void => {\n      forEachEnvelopeItem(filteredEnvelope, (item, type) => {\n        options.recordDroppedEvent(reason, envelopeItemTypeToDataCategory(type));\n      });\n    };\n\n    const requestTask = (): PromiseLike<TransportMakeRequestResponse> =>\n      makeRequest({ body: serializeEnvelope(filteredEnvelope) }).then(\n        response => {\n          // We don't want to throw on NOK responses, but we want to at least log them\n          if (response.statusCode !== undefined && (response.statusCode < 200 || response.statusCode >= 300)) {\n            DEBUG_BUILD && debug.warn(`Sentry responded with status code ${response.statusCode} to sent event.`);\n          }\n\n          rateLimits = updateRateLimits(rateLimits, response);\n          return response;\n        },\n        error => {\n          recordEnvelopeLoss('network_error');\n          DEBUG_BUILD && debug.error('Encountered error running transport request:', error);\n          throw error;\n        },\n      );\n\n    return buffer.add(requestTask).then(\n      result => result,\n      error => {\n        if (error === SENTRY_BUFFER_FULL_ERROR) {\n          DEBUG_BUILD && debug.error('Skipped sending event because buffer is full.');\n          recordEnvelopeLoss('queue_overflow');\n          return Promise.resolve({});\n        } else {\n          throw error;\n        }\n      },\n    );\n  }\n\n  return {\n    send,\n    flush,\n  };\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAmBO,MAAM,6BAAA,GAAgC;AAE7C;;;;;CAKA,GACO,SAAS,eAAe,CAC7B,OAAO,EACP,WAAW,EACX,MAAM,OAAgD,iQAAiB,EACrE,OAAO,CAAC,UAAA,IAAc,6BAA6B,CACpD;IAED,IAAI,UAAU,GAAe,CAAA,CAAE;IAC/B,MAAM,KAAA,GAAQ,CAAC,OAAO,GAAoC,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC;IAE/E,SAAS,IAAI,CAAC,QAAQ,EAAuD;QAC3E,MAAM,qBAAqB,GAAmB,EAAE;QAEpD,wCAAA;YACI,8PAAmB,EAAC,QAAQ,EAAE,CAAC,IAAI,EAAE,IAAI,KAAK;YAC5C,MAAM,YAAA,OAAe,yQAA8B,EAAC,IAAI,CAAC;YACzD,QAAI,yPAAa,EAAC,UAAU,EAAE,YAAY,CAAC,EAAE;gBAC3C,OAAO,CAAC,kBAAkB,CAAC,mBAAmB,EAAE,YAAY,CAAC;YAC/D,OAAO;gBACL,qBAAqB,CAAC,IAAI,CAAC,IAAI,CAAC;YAClC;QACF,CAAC,CAAC;QAEN,4EAAA;QACI,IAAI,qBAAqB,CAAC,MAAA,KAAW,CAAC,EAAE;YACtC,OAAO,OAAO,CAAC,OAAO,CAAC,CAAA,CAAE,CAAC;QAC5B;QAEA,MAAM,gBAAgB,OAAa,yPAAc,EAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,qBAAA,EAA8C;QAEjH,qDAAA;QACI,MAAM,kBAAA,GAAqB,CAAC,MAAM,KAA4B;gBAC5D,8PAAmB,EAAC,gBAAgB,EAAE,CAAC,IAAI,EAAE,IAAI,KAAK;gBACpD,OAAO,CAAC,kBAAkB,CAAC,MAAM,MAAE,yQAA8B,EAAC,IAAI,CAAC,CAAC;YAC1E,CAAC,CAAC;QACJ,CAAC;QAED,MAAM,WAAA,GAAc,IAClB,WAAW,CAAC;gBAAE,IAAI,MAAE,4PAAiB,EAAC,gBAAgB,CAAA;YAAA,CAAG,CAAC,CAAC,IAAI,EAC7D,YAAY;gBACpB,4EAAA;gBACU,IAAI,QAAQ,CAAC,UAAA,KAAe,SAAA,IAAA,CAAc,QAAQ,CAAC,UAAA,GAAa,OAAO,QAAQ,CAAC,UAAA,IAAc,GAAG,CAAC,EAAE;oBAClG,mPAAA,IAAe,uPAAK,CAAC,IAAI,CAAC,CAAC,kCAAkC,EAAE,QAAQ,CAAC,UAAU,CAAC,eAAe,CAAC,CAAC;gBACtG;gBAEA,iBAAa,4PAAgB,EAAC,UAAU,EAAE,QAAQ,CAAC;gBACnD,OAAO,QAAQ;YACjB,CAAC,GACD,SAAS;gBACP,kBAAkB,CAAC,eAAe,CAAC;gBACnC,mPAAA,IAAe,uPAAK,CAAC,KAAK,CAAC,8CAA8C,EAAE,KAAK,CAAC;gBACjF,MAAM,KAAK;YACb,CAAC;QAGL,OAAO,MAAM,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC,IAAI,EACjC,MAAA,GAAU,MAAM,GAChB,SAAS;YACP,IAAI,KAAA,KAAU,wQAAwB,EAAE;gBACtC,mPAAA,IAAe,uPAAK,CAAC,KAAK,CAAC,+CAA+C,CAAC;gBAC3E,kBAAkB,CAAC,gBAAgB,CAAC;gBACpC,OAAO,OAAO,CAAC,OAAO,CAAC,CAAA,CAAE,CAAC;YAC5B,OAAO;gBACL,MAAM,KAAK;YACb;QACF,CAAC;IAEL;IAEA,OAAO;QACL,IAAI;QACJ,KAAK;IACT,CAAG;AACH"}},
    {"offset": {"line": 2241, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/transports/userAgent.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/transports/userAgent.ts"],"sourcesContent":["import type { ClientOptions } from '../types-hoist/options';\n\n/**\n * Takes the SDK metadata and adds the user-agent header to the transport options.\n * This ensures that the SDK sends the user-agent header with SDK name and version to\n * all requests made by the transport.\n *\n * @see https://develop.sentry.dev/sdk/overview/#user-agent\n */\nexport function addUserAgentToTransportHeaders(options: ClientOptions): void {\n  const sdkMetadata = options._metadata?.sdk;\n  const sdkUserAgent =\n    sdkMetadata?.name && sdkMetadata?.version ? `${sdkMetadata?.name}/${sdkMetadata?.version}` : undefined;\n\n  options.transportOptions = {\n    ...options.transportOptions,\n    headers: {\n      ...(sdkUserAgent && { 'user-agent': sdkUserAgent }),\n      ...options.transportOptions?.headers,\n    },\n  };\n}\n"],"names":[],"mappings":"AAEA;;;;;;CAMA;;;;AACO,SAAS,8BAA8B,CAAC,OAAO,EAAuB;IAC3E,MAAM,WAAA,GAAc,OAAO,CAAC,SAAS,EAAE,GAAG;IAC1C,MAAM,YAAA,GACJ,WAAW,EAAE,IAAA,IAAQ,WAAW,EAAE,OAAA,GAAU,CAAC,EAAA,WAAA,EAAA,IAAA,CAAA,CAAA,EAAA,WAAA,EAAA,OAAA,CAAA,CAAA,GAAA,SAAA;IAEA,OAAA,CAAA,gBAAA,GAAA;QACA,GAAA,OAAA,CAAA,gBAAA;QACA,OAAA,EAAA;YACA,GAAA,YAAA,IAAA;gBAAA,YAAA,EAAA,YAAA;YAAA,CAAA,CAAA;YACA,GAAA,OAAA,CAAA,gBAAA,EAAA,OAAA;QACA,CAAA;IACA,CAAA;AACA"}},
    {"offset": {"line": 2270, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/checkin.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/checkin.ts"],"sourcesContent":["import type { SerializedCheckIn } from './types-hoist/checkin';\nimport type { DsnComponents } from './types-hoist/dsn';\nimport type { CheckInEnvelope, CheckInItem, DynamicSamplingContext } from './types-hoist/envelope';\nimport type { SdkMetadata } from './types-hoist/sdkmetadata';\nimport { dsnToString } from './utils/dsn';\nimport { createEnvelope } from './utils/envelope';\n\n/**\n * Create envelope from check in item.\n */\nexport function createCheckInEnvelope(\n  checkIn: SerializedCheckIn,\n  dynamicSamplingContext?: Partial<DynamicSamplingContext>,\n  metadata?: SdkMetadata,\n  tunnel?: string,\n  dsn?: DsnComponents,\n): CheckInEnvelope {\n  const headers: CheckInEnvelope[0] = {\n    sent_at: new Date().toISOString(),\n  };\n\n  if (metadata?.sdk) {\n    headers.sdk = {\n      name: metadata.sdk.name,\n      version: metadata.sdk.version,\n    };\n  }\n\n  if (!!tunnel && !!dsn) {\n    headers.dsn = dsnToString(dsn);\n  }\n\n  if (dynamicSamplingContext) {\n    headers.trace = dynamicSamplingContext as DynamicSamplingContext;\n  }\n\n  const item = createCheckInEnvelopeItem(checkIn);\n  return createEnvelope<CheckInEnvelope>(headers, [item]);\n}\n\nfunction createCheckInEnvelopeItem(checkIn: SerializedCheckIn): CheckInItem {\n  const checkInHeaders: CheckInItem[0] = {\n    type: 'check_in',\n  };\n  return [checkInHeaders, checkIn];\n}\n"],"names":[],"mappings":";;;;;;;;AAOA;;CAEA,GACO,SAAS,qBAAqB,CACnC,OAAO,EACP,sBAAsB,EACtB,QAAQ,EACR,MAAM,EACN,GAAG;IAEH,MAAM,OAAO,GAAuB;QAClC,OAAO,EAAE,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE;IACrC,CAAG;IAED,IAAI,QAAQ,EAAE,GAAG,EAAE;QACjB,OAAO,CAAC,GAAA,GAAM;YACZ,IAAI,EAAE,QAAQ,CAAC,GAAG,CAAC,IAAI;YACvB,OAAO,EAAE,QAAQ,CAAC,GAAG,CAAC,OAAO;QACnC,CAAK;IACH;IAEA,IAAI,CAAC,CAAC,UAAU,CAAC,CAAC,GAAG,EAAE;QACrB,OAAO,CAAC,GAAA,OAAM,iPAAW,EAAC,GAAG,CAAC;IAChC;IAEA,IAAI,sBAAsB,EAAE;QAC1B,OAAO,CAAC,KAAA,GAAQ,sBAAA;IAClB;IAEA,MAAM,IAAA,GAAO,yBAAyB,CAAC,OAAO,CAAC;IAC/C,WAAO,yPAAc,EAAkB,OAAO,EAAE;QAAC,IAAI;KAAC,CAAC;AACzD;AAEA,SAAS,yBAAyB,CAAC,OAAO,EAAkC;IAC1E,MAAM,cAAc,GAAmB;QACrC,IAAI,EAAE,UAAU;IACpB,CAAG;IACD,OAAO;QAAC,cAAc;QAAE,OAAO;KAAC;AAClC"}},
    {"offset": {"line": 2316, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/api.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/api.ts"],"sourcesContent":["import type { ReportDialogOptions } from './report-dialog';\nimport type { DsnComponents, DsnLike } from './types-hoist/dsn';\nimport type { SdkInfo } from './types-hoist/sdkinfo';\nimport { dsnToString, makeDsn } from './utils/dsn';\n\nconst SENTRY_API_VERSION = '7';\n\n/** Returns the prefix to construct Sentry ingestion API endpoints. */\nfunction getBaseApiEndpoint(dsn: DsnComponents): string {\n  const protocol = dsn.protocol ? `${dsn.protocol}:` : '';\n  const port = dsn.port ? `:${dsn.port}` : '';\n  return `${protocol}//${dsn.host}${port}${dsn.path ? `/${dsn.path}` : ''}/api/`;\n}\n\n/** Returns the ingest API endpoint for target. */\nfunction _getIngestEndpoint(dsn: DsnComponents): string {\n  return `${getBaseApiEndpoint(dsn)}${dsn.projectId}/envelope/`;\n}\n\n/** Returns a URL-encoded string with auth config suitable for a query string. */\nfunction _encodedAuth(dsn: DsnComponents, sdkInfo: SdkInfo | undefined): string {\n  const params: Record<string, string> = {\n    sentry_version: SENTRY_API_VERSION,\n  };\n\n  if (dsn.publicKey) {\n    // We send only the minimum set of required information. See\n    // https://github.com/getsentry/sentry-javascript/issues/2572.\n    params.sentry_key = dsn.publicKey;\n  }\n\n  if (sdkInfo) {\n    params.sentry_client = `${sdkInfo.name}/${sdkInfo.version}`;\n  }\n\n  return new URLSearchParams(params).toString();\n}\n\n/**\n * Returns the envelope endpoint URL with auth in the query string.\n *\n * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.\n */\nexport function getEnvelopeEndpointWithUrlEncodedAuth(dsn: DsnComponents, tunnel?: string, sdkInfo?: SdkInfo): string {\n  return tunnel ? tunnel : `${_getIngestEndpoint(dsn)}?${_encodedAuth(dsn, sdkInfo)}`;\n}\n\n/** Returns the url to the report dialog endpoint. */\nexport function getReportDialogEndpoint(dsnLike: DsnLike, dialogOptions: ReportDialogOptions): string {\n  const dsn = makeDsn(dsnLike);\n  if (!dsn) {\n    return '';\n  }\n\n  const endpoint = `${getBaseApiEndpoint(dsn)}embed/error-page/`;\n\n  let encodedOptions = `dsn=${dsnToString(dsn)}`;\n  for (const key in dialogOptions) {\n    if (key === 'dsn') {\n      continue;\n    }\n\n    if (key === 'onClose') {\n      continue;\n    }\n\n    if (key === 'user') {\n      const user = dialogOptions.user;\n      if (!user) {\n        continue;\n      }\n      if (user.name) {\n        encodedOptions += `&name=${encodeURIComponent(user.name)}`;\n      }\n      if (user.email) {\n        encodedOptions += `&email=${encodeURIComponent(user.email)}`;\n      }\n    } else {\n      encodedOptions += `&${encodeURIComponent(key)}=${encodeURIComponent(dialogOptions[key] as string)}`;\n    }\n  }\n\n  return `${endpoint}?${encodedOptions}`;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2391, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/logs/constants.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/logs/constants.ts"],"sourcesContent":["import type { LogSeverityLevel } from '../types-hoist/log';\n\n/**\n * Maps a log severity level to a log severity number.\n *\n * @see LogSeverityLevel\n */\nexport const SEVERITY_TEXT_TO_SEVERITY_NUMBER: Partial<Record<LogSeverityLevel, number>> = {\n  trace: 1,\n  debug: 5,\n  info: 9,\n  warn: 13,\n  error: 17,\n  fatal: 21,\n};\n"],"names":[],"mappings":"AAEA;;;;CAIA;;;;AACO,MAAM,gCAAgC,GAA8C;IACzF,KAAK,EAAE,CAAC;IACR,KAAK,EAAE,CAAC;IACR,IAAI,EAAE,CAAC;IACP,IAAI,EAAE,EAAE;IACR,KAAK,EAAE,EAAE;IACT,KAAK,EAAE,EAAE;AACX"}},
    {"offset": {"line": 2413, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/logs/envelope.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/logs/envelope.ts"],"sourcesContent":["import type { DsnComponents } from '../types-hoist/dsn';\nimport type { LogContainerItem, LogEnvelope } from '../types-hoist/envelope';\nimport type { SerializedLog } from '../types-hoist/log';\nimport type { SdkMetadata } from '../types-hoist/sdkmetadata';\nimport { dsnToString } from '../utils/dsn';\nimport { createEnvelope } from '../utils/envelope';\n\n/**\n * Creates a log container envelope item for a list of logs.\n *\n * @param items - The logs to include in the envelope.\n * @returns The created log container envelope item.\n */\nexport function createLogContainerEnvelopeItem(items: Array<SerializedLog>): LogContainerItem {\n  return [\n    {\n      type: 'log',\n      item_count: items.length,\n      content_type: 'application/vnd.sentry.items.log+json',\n    },\n    {\n      items,\n    },\n  ];\n}\n\n/**\n * Creates an envelope for a list of logs.\n *\n * Logs from multiple traces can be included in the same envelope.\n *\n * @param logs - The logs to include in the envelope.\n * @param metadata - The metadata to include in the envelope.\n * @param tunnel - The tunnel to include in the envelope.\n * @param dsn - The DSN to include in the envelope.\n * @returns The created envelope.\n */\nexport function createLogEnvelope(\n  logs: Array<SerializedLog>,\n  metadata?: SdkMetadata,\n  tunnel?: string,\n  dsn?: DsnComponents,\n): LogEnvelope {\n  const headers: LogEnvelope[0] = {};\n\n  if (metadata?.sdk) {\n    headers.sdk = {\n      name: metadata.sdk.name,\n      version: metadata.sdk.version,\n    };\n  }\n\n  if (!!tunnel && !!dsn) {\n    headers.dsn = dsnToString(dsn);\n  }\n\n  return createEnvelope<LogEnvelope>(headers, [createLogContainerEnvelopeItem(logs)]);\n}\n"],"names":[],"mappings":";;;;;;;;;;AAOA;;;;;CAKA,GACO,SAAS,8BAA8B,CAAC,KAAK,EAA0C;IAC5F,OAAO;QACL;YACE,IAAI,EAAE,KAAK;YACX,UAAU,EAAE,KAAK,CAAC,MAAM;YACxB,YAAY,EAAE,uCAAuC;QAC3D,CAAK;QACD;YACE,KAAK;QACX,CAAK;KACF;AACH;AAEA;;;;;;;;;;CAUA,GACO,SAAS,iBAAiB,CAC/B,IAAI,EACJ,QAAQ,EACR,MAAM,EACN,GAAG;IAEH,MAAM,OAAO,GAAmB,CAAA,CAAE;IAElC,IAAI,QAAQ,EAAE,GAAG,EAAE;QACjB,OAAO,CAAC,GAAA,GAAM;YACZ,IAAI,EAAE,QAAQ,CAAC,GAAG,CAAC,IAAI;YACvB,OAAO,EAAE,QAAQ,CAAC,GAAG,CAAC,OAAO;QACnC,CAAK;IACH;IAEA,IAAI,CAAC,CAAC,UAAU,CAAC,CAAC,GAAG,EAAE;QACrB,OAAO,CAAC,GAAA,OAAM,iPAAW,EAAC,GAAG,CAAC;IAChC;IAEA,WAAO,yPAAc,EAAc,OAAO,EAAE;QAAC,8BAA8B,CAAC,IAAI,CAAC;KAAC,CAAC;AACrF"}},
    {"offset": {"line": 2471, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/logs/internal.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/logs/internal.ts"],"sourcesContent":["import { getGlobalSingleton } from '../carrier';\nimport type { Client } from '../client';\nimport { getClient, getCurrentScope, getGlobalScope, getIsolationScope } from '../currentScopes';\nimport { DEBUG_BUILD } from '../debug-build';\nimport type { Scope, ScopeData } from '../scope';\nimport type { Integration } from '../types-hoist/integration';\nimport type { Log, SerializedLog, SerializedLogAttributeValue } from '../types-hoist/log';\nimport { mergeScopeData } from '../utils/applyScopeDataToEvent';\nimport { consoleSandbox, debug } from '../utils/debug-logger';\nimport { isParameterizedString } from '../utils/is';\nimport { _getSpanForScope } from '../utils/spanOnScope';\nimport { timestampInSeconds } from '../utils/time';\nimport { _getTraceInfoFromScope } from '../utils/trace-info';\nimport { SEVERITY_TEXT_TO_SEVERITY_NUMBER } from './constants';\nimport { createLogEnvelope } from './envelope';\n\nconst MAX_LOG_BUFFER_SIZE = 100;\n\n/**\n * Converts a log attribute to a serialized log attribute.\n *\n * @param key - The key of the log attribute.\n * @param value - The value of the log attribute.\n * @returns The serialized log attribute.\n */\nexport function logAttributeToSerializedLogAttribute(value: unknown): SerializedLogAttributeValue {\n  switch (typeof value) {\n    case 'number':\n      if (Number.isInteger(value)) {\n        return {\n          value,\n          type: 'integer',\n        };\n      }\n      return {\n        value,\n        type: 'double',\n      };\n    case 'boolean':\n      return {\n        value,\n        type: 'boolean',\n      };\n    case 'string':\n      return {\n        value,\n        type: 'string',\n      };\n    default: {\n      let stringValue = '';\n      try {\n        stringValue = JSON.stringify(value) ?? '';\n      } catch {\n        // Do nothing\n      }\n      return {\n        value: stringValue,\n        type: 'string',\n      };\n    }\n  }\n}\n\n/**\n * Sets a log attribute if the value exists and the attribute key is not already present.\n *\n * @param logAttributes - The log attributes object to modify.\n * @param key - The attribute key to set.\n * @param value - The value to set (only sets if truthy and key not present).\n * @param setEvenIfPresent - Whether to set the attribute if it is present. Defaults to true.\n */\nfunction setLogAttribute(\n  logAttributes: Record<string, unknown>,\n  key: string,\n  value: unknown,\n  setEvenIfPresent = true,\n): void {\n  if (value && (!logAttributes[key] || setEvenIfPresent)) {\n    logAttributes[key] = value;\n  }\n}\n\n/**\n * Captures a serialized log event and adds it to the log buffer for the given client.\n *\n * @param client - A client. Uses the current client if not provided.\n * @param serializedLog - The serialized log event to capture.\n *\n * @experimental This method will experience breaking changes. This is not yet part of\n * the stable Sentry SDK API and can be changed or removed without warning.\n */\nexport function _INTERNAL_captureSerializedLog(client: Client, serializedLog: SerializedLog): void {\n  const bufferMap = _getBufferMap();\n  const logBuffer = _INTERNAL_getLogBuffer(client);\n\n  if (logBuffer === undefined) {\n    bufferMap.set(client, [serializedLog]);\n  } else {\n    if (logBuffer.length >= MAX_LOG_BUFFER_SIZE) {\n      _INTERNAL_flushLogsBuffer(client, logBuffer);\n      bufferMap.set(client, [serializedLog]);\n    } else {\n      bufferMap.set(client, [...logBuffer, serializedLog]);\n    }\n  }\n}\n\n/**\n * Captures a log event and sends it to Sentry.\n *\n * @param log - The log event to capture.\n * @param scope - A scope. Uses the current scope if not provided.\n * @param client - A client. Uses the current client if not provided.\n * @param captureSerializedLog - A function to capture the serialized log.\n *\n * @experimental This method will experience breaking changes. This is not yet part of\n * the stable Sentry SDK API and can be changed or removed without warning.\n */\nexport function _INTERNAL_captureLog(\n  beforeLog: Log,\n  currentScope = getCurrentScope(),\n  captureSerializedLog: (client: Client, log: SerializedLog) => void = _INTERNAL_captureSerializedLog,\n): void {\n  const client = currentScope?.getClient() ?? getClient();\n  if (!client) {\n    DEBUG_BUILD && debug.warn('No client available to capture log.');\n    return;\n  }\n\n  const { release, environment, enableLogs = false, beforeSendLog } = client.getOptions();\n  if (!enableLogs) {\n    DEBUG_BUILD && debug.warn('logging option not enabled, log will not be captured.');\n    return;\n  }\n\n  const [, traceContext] = _getTraceInfoFromScope(client, currentScope);\n\n  const processedLogAttributes = {\n    ...beforeLog.attributes,\n  };\n\n  const {\n    user: { id, email, username },\n  } = getMergedScopeData(currentScope);\n  setLogAttribute(processedLogAttributes, 'user.id', id, false);\n  setLogAttribute(processedLogAttributes, 'user.email', email, false);\n  setLogAttribute(processedLogAttributes, 'user.name', username, false);\n\n  setLogAttribute(processedLogAttributes, 'sentry.release', release);\n  setLogAttribute(processedLogAttributes, 'sentry.environment', environment);\n\n  const { name, version } = client.getSdkMetadata()?.sdk ?? {};\n  setLogAttribute(processedLogAttributes, 'sentry.sdk.name', name);\n  setLogAttribute(processedLogAttributes, 'sentry.sdk.version', version);\n\n  const replay = client.getIntegrationByName<\n    Integration & {\n      getReplayId: (onlyIfSampled?: boolean) => string;\n      getRecordingMode: () => 'session' | 'buffer' | undefined;\n    }\n  >('Replay');\n\n  const replayId = replay?.getReplayId(true);\n  setLogAttribute(processedLogAttributes, 'sentry.replay_id', replayId);\n\n  if (replayId && replay?.getRecordingMode() === 'buffer') {\n    // We send this so we can identify cases where the replayId is attached but the replay itself might not have been sent to Sentry\n    setLogAttribute(processedLogAttributes, 'sentry._internal.replay_is_buffering', true);\n  }\n\n  const beforeLogMessage = beforeLog.message;\n  if (isParameterizedString(beforeLogMessage)) {\n    const { __sentry_template_string__, __sentry_template_values__ = [] } = beforeLogMessage;\n    if (__sentry_template_values__?.length) {\n      processedLogAttributes['sentry.message.template'] = __sentry_template_string__;\n    }\n    __sentry_template_values__.forEach((param, index) => {\n      processedLogAttributes[`sentry.message.parameter.${index}`] = param;\n    });\n  }\n\n  const span = _getSpanForScope(currentScope);\n  // Add the parent span ID to the log attributes for trace context\n  setLogAttribute(processedLogAttributes, 'sentry.trace.parent_span_id', span?.spanContext().spanId);\n\n  const processedLog = { ...beforeLog, attributes: processedLogAttributes };\n\n  client.emit('beforeCaptureLog', processedLog);\n\n  // We need to wrap this in `consoleSandbox` to avoid recursive calls to `beforeSendLog`\n  const log = beforeSendLog ? consoleSandbox(() => beforeSendLog(processedLog)) : processedLog;\n  if (!log) {\n    client.recordDroppedEvent('before_send', 'log_item', 1);\n    DEBUG_BUILD && debug.warn('beforeSendLog returned null, log will not be captured.');\n    return;\n  }\n\n  const { level, message, attributes = {}, severityNumber } = log;\n\n  const serializedLog: SerializedLog = {\n    timestamp: timestampInSeconds(),\n    level,\n    body: message,\n    trace_id: traceContext?.trace_id,\n    severity_number: severityNumber ?? SEVERITY_TEXT_TO_SEVERITY_NUMBER[level],\n    attributes: Object.keys(attributes).reduce(\n      (acc, key) => {\n        acc[key] = logAttributeToSerializedLogAttribute(attributes[key]);\n        return acc;\n      },\n      {} as Record<string, SerializedLogAttributeValue>,\n    ),\n  };\n\n  captureSerializedLog(client, serializedLog);\n\n  client.emit('afterCaptureLog', log);\n}\n\n/**\n * Flushes the logs buffer to Sentry.\n *\n * @param client - A client.\n * @param maybeLogBuffer - A log buffer. Uses the log buffer for the given client if not provided.\n *\n * @experimental This method will experience breaking changes. This is not yet part of\n * the stable Sentry SDK API and can be changed or removed without warning.\n */\nexport function _INTERNAL_flushLogsBuffer(client: Client, maybeLogBuffer?: Array<SerializedLog>): void {\n  const logBuffer = maybeLogBuffer ?? _INTERNAL_getLogBuffer(client) ?? [];\n  if (logBuffer.length === 0) {\n    return;\n  }\n\n  const clientOptions = client.getOptions();\n  const envelope = createLogEnvelope(logBuffer, clientOptions._metadata, clientOptions.tunnel, client.getDsn());\n\n  // Clear the log buffer after envelopes have been constructed.\n  _getBufferMap().set(client, []);\n\n  client.emit('flushLogs');\n\n  // sendEnvelope should not throw\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  client.sendEnvelope(envelope);\n}\n\n/**\n * Returns the log buffer for a given client.\n *\n * Exported for testing purposes.\n *\n * @param client - The client to get the log buffer for.\n * @returns The log buffer for the given client.\n */\nexport function _INTERNAL_getLogBuffer(client: Client): Array<SerializedLog> | undefined {\n  return _getBufferMap().get(client);\n}\n\n/**\n * Get the scope data for the current scope after merging with the\n * global scope and isolation scope.\n *\n * @param currentScope - The current scope.\n * @returns The scope data.\n */\nfunction getMergedScopeData(currentScope: Scope): ScopeData {\n  const scopeData = getGlobalScope().getScopeData();\n  mergeScopeData(scopeData, getIsolationScope().getScopeData());\n  mergeScopeData(scopeData, currentScope.getScopeData());\n  return scopeData;\n}\n\nfunction _getBufferMap(): WeakMap<Client, Array<SerializedLog>> {\n  // The reference to the Client <> LogBuffer map is stored on the carrier to ensure it's always the same\n  return getGlobalSingleton('clientToLogBufferMap', () => new WeakMap<Client, Array<SerializedLog>>());\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2726, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/logs/utils.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/logs/utils.ts"],"sourcesContent":["import { isPrimitive } from '../utils/is';\nimport { normalize } from '../utils/normalize';\nimport { GLOBAL_OBJ } from '../utils/worldwide';\n\ntype GlobalObjectWithUtil = typeof GLOBAL_OBJ & {\n  util: {\n    format: (...args: unknown[]) => string;\n  };\n};\n\n/**\n * Formats the given values into a string.\n *\n * @param values - The values to format.\n * @param normalizeDepth - The depth to normalize the values.\n * @param normalizeMaxBreadth - The max breadth to normalize the values.\n * @returns The formatted string.\n */\nexport function formatConsoleArgs(values: unknown[], normalizeDepth: number, normalizeMaxBreadth: number): string {\n  return 'util' in GLOBAL_OBJ && typeof (GLOBAL_OBJ as GlobalObjectWithUtil).util.format === 'function'\n    ? (GLOBAL_OBJ as GlobalObjectWithUtil).util.format(...values)\n    : safeJoinConsoleArgs(values, normalizeDepth, normalizeMaxBreadth);\n}\n\n/**\n * Joins the given values into a string.\n *\n * @param values - The values to join.\n * @param normalizeDepth - The depth to normalize the values.\n * @param normalizeMaxBreadth - The max breadth to normalize the values.\n * @returns The joined string.\n */\nexport function safeJoinConsoleArgs(values: unknown[], normalizeDepth: number, normalizeMaxBreadth: number): string {\n  return values\n    .map(value =>\n      isPrimitive(value) ? String(value) : JSON.stringify(normalize(value, normalizeDepth, normalizeMaxBreadth)),\n    )\n    .join(' ');\n}\n\n/**\n * Checks if a string contains console substitution patterns like %s, %d, %i, %f, %o, %O, %c.\n *\n * @param str - The string to check\n * @returns true if the string contains console substitution patterns\n */\nexport function hasConsoleSubstitutions(str: string): boolean {\n  // Match console substitution patterns: %s, %d, %i, %f, %o, %O, %c\n  return /%[sdifocO]/.test(str);\n}\n\n/**\n * Creates template attributes for multiple console arguments.\n *\n * @param args - The console arguments\n * @returns An object with template and parameter attributes\n */\nexport function createConsoleTemplateAttributes(firstArg: unknown, followingArgs: unknown[]): Record<string, unknown> {\n  const attributes: Record<string, unknown> = {};\n\n  // Create template with placeholders for each argument\n  const template = new Array(followingArgs.length).fill('{}').join(' ');\n  attributes['sentry.message.template'] = `${firstArg} ${template}`;\n\n  // Add each argument as a parameter\n  followingArgs.forEach((arg, index) => {\n    attributes[`sentry.message.parameter.${index}`] = arg;\n  });\n\n  return attributes;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAUA;;;;;;;CAOA,GACO,SAAS,iBAAiB,CAAC,MAAM,EAAa,cAAc,EAAU,mBAAmB,EAAkB;IAChH,OAAO,MAAA,IAAU,sPAAA,IAAc,OAAO,AAAC,sPAAA,CAAoC,IAAI,CAAC,MAAA,KAAW,aACvF,AAAC,sPAAA,CAAoC,IAAI,CAAC,MAAM,CAAC,GAAG,MAAM,IAC1D,mBAAmB,CAAC,MAAM,EAAE,cAAc,EAAE,mBAAmB,CAAC;AACtE;AAEA;;;;;;;CAOA,GACO,SAAS,mBAAmB,CAAC,MAAM,EAAa,cAAc,EAAU,mBAAmB,EAAkB;IAClH,OAAO,OACJ,GAAG,EAAC,KAAA,OACH,gPAAW,EAAC,KAAK,CAAA,GAAI,MAAM,CAAC,KAAK,CAAA,GAAI,IAAI,CAAC,SAAS,KAAC,qPAAS,EAAC,KAAK,EAAE,cAAc,EAAE,mBAAmB,CAAC,CAAC,EAE3G,IAAI,CAAC,GAAG,CAAC;AACd;AAEA;;;;;CAKA,GACO,SAAS,uBAAuB,CAAC,GAAG,EAAmB;IAC9D,kEAAA;IACE,OAAO,YAAY,CAAC,IAAI,CAAC,GAAG,CAAC;AAC/B;AAEA;;;;;CAKA,GACO,SAAS,+BAA+B,CAAC,QAAQ,EAAW,aAAa,EAAsC;IACpH,MAAM,UAAU,GAA4B,CAAA,CAAE;IAEhD,sDAAA;IACE,MAAM,QAAA,GAAW,IAAI,KAAK,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC;IACrE,UAAU,CAAC,yBAAyB,CAAA,GAAI,CAAC,EAAA,QAAA,CAAA,CAAA,EAAA,QAAA,CAAA,CAAA;IAEA,mCAAA;IACA,aAAA,CAAA,OAAA,CAAA,CAAA,GAAA,EAAA,KAAA,KAAA;QACA,UAAA,CAAA,CAAA,yBAAA,EAAA,KAAA,CAAA,CAAA,CAAA,GAAA,GAAA;IACA,CAAA,CAAA;IAEA,OAAA,UAAA;AACA"}},
    {"offset": {"line": 2793, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/logs/console-integration.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/logs/console-integration.ts"],"sourcesContent":["import { getClient } from '../currentScopes';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { addConsoleInstrumentationHandler } from '../instrument/console';\nimport { defineIntegration } from '../integration';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN } from '../semanticAttributes';\nimport type { ConsoleLevel } from '../types-hoist/instrument';\nimport type { IntegrationFn } from '../types-hoist/integration';\nimport { CONSOLE_LEVELS, debug } from '../utils/debug-logger';\nimport { _INTERNAL_captureLog } from './internal';\nimport { createConsoleTemplateAttributes, formatConsoleArgs, hasConsoleSubstitutions } from './utils';\n\ninterface CaptureConsoleOptions {\n  levels: ConsoleLevel[];\n}\n\nconst INTEGRATION_NAME = 'ConsoleLogs';\n\nconst DEFAULT_ATTRIBUTES = {\n  [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.log.console',\n};\n\nconst _consoleLoggingIntegration = ((options: Partial<CaptureConsoleOptions> = {}) => {\n  const levels = options.levels || CONSOLE_LEVELS;\n\n  return {\n    name: INTEGRATION_NAME,\n    setup(client) {\n      const { enableLogs, normalizeDepth = 3, normalizeMaxBreadth = 1_000 } = client.getOptions();\n      if (!enableLogs) {\n        DEBUG_BUILD && debug.warn('`enableLogs` is not enabled, ConsoleLogs integration disabled');\n        return;\n      }\n\n      addConsoleInstrumentationHandler(({ args, level }) => {\n        if (getClient() !== client || !levels.includes(level)) {\n          return;\n        }\n\n        const firstArg = args[0];\n        const followingArgs = args.slice(1);\n\n        if (level === 'assert') {\n          if (!firstArg) {\n            const assertionMessage =\n              followingArgs.length > 0\n                ? `Assertion failed: ${formatConsoleArgs(followingArgs, normalizeDepth, normalizeMaxBreadth)}`\n                : 'Assertion failed';\n            _INTERNAL_captureLog({ level: 'error', message: assertionMessage, attributes: DEFAULT_ATTRIBUTES });\n          }\n          return;\n        }\n\n        const isLevelLog = level === 'log';\n\n        const shouldGenerateTemplate =\n          args.length > 1 && typeof args[0] === 'string' && !hasConsoleSubstitutions(args[0]);\n        const attributes = {\n          ...DEFAULT_ATTRIBUTES,\n          ...(shouldGenerateTemplate ? createConsoleTemplateAttributes(firstArg, followingArgs) : {}),\n        };\n\n        _INTERNAL_captureLog({\n          level: isLevelLog ? 'info' : level,\n          message: formatConsoleArgs(args, normalizeDepth, normalizeMaxBreadth),\n          severityNumber: isLevelLog ? 10 : undefined,\n          attributes,\n        });\n      });\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Captures calls to the `console` API as logs in Sentry. Requires the `enableLogs` option to be enabled.\n *\n * @experimental This feature is experimental and may be changed or removed in future versions.\n *\n * By default the integration instruments `console.debug`, `console.info`, `console.warn`, `console.error`,\n * `console.log`, `console.trace`, and `console.assert`. You can use the `levels` option to customize which\n * levels are captured.\n *\n * @example\n *\n * ```ts\n * import * as Sentry from '@sentry/browser';\n *\n * Sentry.init({\n *   enableLogs: true,\n *   integrations: [Sentry.consoleLoggingIntegration({ levels: ['error', 'warn'] })],\n * });\n * ```\n */\nexport const consoleLoggingIntegration = defineIntegration(_consoleLoggingIntegration);\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAeA,MAAM,gBAAA,GAAmB,aAAa;AAEtC,MAAM,qBAAqB;IACzB,CAAC,4QAAgC,CAAA,EAAG,kBAAkB;AACxD,CAAC;AAED,MAAM,0BAAA,GAA8B,CAAC,OAAO,GAAmC,CAAA,CAAE,KAAK;IACpF,MAAM,MAAA,GAAS,OAAO,CAAC,MAAA,IAAU,gQAAc;IAE/C,OAAO;QACL,IAAI,EAAE,gBAAgB;QACtB,KAAK,EAAC,MAAM,EAAE;YACZ,MAAM,EAAE,UAAU,EAAE,cAAA,GAAiB,CAAC,EAAE,mBAAA,GAAsB,IAAA,EAAM,GAAI,MAAM,CAAC,UAAU,EAAE;YAC3F,IAAI,CAAC,UAAU,EAAE;gBACf,mPAAA,IAAe,uPAAK,CAAC,IAAI,CAAC,+DAA+D,CAAC;gBAC1F;YACF;gBAEA,+QAAgC,EAAC,CAAC,EAAE,IAAI,EAAE,KAAA,EAAO,KAAK;gBACpD,QAAI,gPAAS,QAAO,MAAA,IAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE;oBACrD;gBACF;gBAEA,MAAM,QAAA,GAAW,IAAI,CAAC,CAAC,CAAC;gBACxB,MAAM,gBAAgB,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;gBAEnC,IAAI,KAAA,KAAU,QAAQ,EAAE;oBACtB,IAAI,CAAC,QAAQ,EAAE;wBACb,MAAM,gBAAA,GACJ,aAAa,CAAC,MAAA,GAAS,IACnB,CAAC,kBAAkB,MAAE,wPAAiB,EAAC,aAAa,EAAE,cAAc,EAAE,mBAAmB,CAAC,CAAC,CAAA,GAC7G,kBAAA;4BACA,8PAAA,EAAA;4BAAA,KAAA,EAAA,OAAA;4BAAA,OAAA,EAAA,gBAAA;4BAAA,UAAA,EAAA,kBAAA;wBAAA,CAAA,CAAA;oBACA;oBACA;gBACA;gBAEA,MAAA,UAAA,GAAA,KAAA,KAAA,KAAA;gBAEA,MAAA,sBAAA,GACA,IAAA,CAAA,MAAA,GAAA,CAAA,IAAA,OAAA,IAAA,CAAA,CAAA,CAAA,KAAA,QAAA,IAAA,KAAA,8PAAA,EAAA,IAAA,CAAA,CAAA,CAAA,CAAA;gBACA,MAAA,UAAA,GAAA;oBACA,GAAA,kBAAA;oBACA,GAAA,sBAAA,OAAA,sQAAA,EAAA,QAAA,EAAA,aAAA,CAAA,GAAA,CAAA,CAAA,CAAA;gBACA,CAAA;oBAEA,8PAAA,EAAA;oBACA,KAAA,EAAA,UAAA,GAAA,MAAA,GAAA,KAAA;oBACA,OAAA,MAAA,wPAAA,EAAA,IAAA,EAAA,cAAA,EAAA,mBAAA,CAAA;oBACA,cAAA,EAAA,UAAA,GAAA,EAAA,GAAA,SAAA;oBACA,UAAA;gBACA,CAAA,CAAA;YACA,CAAA,CAAA;QACA,CAAA;IACA,CAAA;AACA,CAAA,CAAA;AAEA;;;;;;;;;;;;;;;;;;;CAmBA,GACA,MAAA,yBAAA,OAAA,sPAAA,EAAA,0BAAA"}},
    {"offset": {"line": 2886, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/metrics/envelope.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/metrics/envelope.ts"],"sourcesContent":["import type { DsnComponents } from '../types-hoist/dsn';\nimport type { MetricContainerItem, MetricEnvelope } from '../types-hoist/envelope';\nimport type { SerializedMetric } from '../types-hoist/metric';\nimport type { SdkMetadata } from '../types-hoist/sdkmetadata';\nimport { dsnToString } from '../utils/dsn';\nimport { createEnvelope } from '../utils/envelope';\n\n/**\n * Creates a metric container envelope item for a list of metrics.\n *\n * @param items - The metrics to include in the envelope.\n * @returns The created metric container envelope item.\n */\nexport function createMetricContainerEnvelopeItem(items: Array<SerializedMetric>): MetricContainerItem {\n  return [\n    {\n      type: 'trace_metric',\n      item_count: items.length,\n      content_type: 'application/vnd.sentry.items.trace-metric+json',\n    } as MetricContainerItem[0],\n    {\n      items,\n    },\n  ];\n}\n\n/**\n * Creates an envelope for a list of metrics.\n *\n * Metrics from multiple traces can be included in the same envelope.\n *\n * @param metrics - The metrics to include in the envelope.\n * @param metadata - The metadata to include in the envelope.\n * @param tunnel - The tunnel to include in the envelope.\n * @param dsn - The DSN to include in the envelope.\n * @returns The created envelope.\n */\nexport function createMetricEnvelope(\n  metrics: Array<SerializedMetric>,\n  metadata?: SdkMetadata,\n  tunnel?: string,\n  dsn?: DsnComponents,\n): MetricEnvelope {\n  const headers: MetricEnvelope[0] = {};\n\n  if (metadata?.sdk) {\n    headers.sdk = {\n      name: metadata.sdk.name,\n      version: metadata.sdk.version,\n    };\n  }\n\n  if (!!tunnel && !!dsn) {\n    headers.dsn = dsnToString(dsn);\n  }\n\n  return createEnvelope<MetricEnvelope>(headers, [createMetricContainerEnvelopeItem(metrics)]);\n}\n"],"names":[],"mappings":";;;;;;;;;;AAOA;;;;;CAKA,GACO,SAAS,iCAAiC,CAAC,KAAK,EAAgD;IACrG,OAAO;QACL;YACE,IAAI,EAAE,cAAc;YACpB,UAAU,EAAE,KAAK,CAAC,MAAM;YACxB,YAAY,EAAE,gDAAgD;QACpE,CAAI;QACA;YACE,KAAK;QACX,CAAK;KACF;AACH;AAEA;;;;;;;;;;CAUA,GACO,SAAS,oBAAoB,CAClC,OAAO,EACP,QAAQ,EACR,MAAM,EACN,GAAG;IAEH,MAAM,OAAO,GAAsB,CAAA,CAAE;IAErC,IAAI,QAAQ,EAAE,GAAG,EAAE;QACjB,OAAO,CAAC,GAAA,GAAM;YACZ,IAAI,EAAE,QAAQ,CAAC,GAAG,CAAC,IAAI;YACvB,OAAO,EAAE,QAAQ,CAAC,GAAG,CAAC,OAAO;QACnC,CAAK;IACH;IAEA,IAAI,CAAC,CAAC,UAAU,CAAC,CAAC,GAAG,EAAE;QACrB,OAAO,CAAC,GAAA,OAAM,iPAAW,EAAC,GAAG,CAAC;IAChC;IAEA,WAAO,yPAAc,EAAiB,OAAO,EAAE;QAAC,iCAAiC,CAAC,OAAO,CAAC;KAAC,CAAC;AAC9F"}},
    {"offset": {"line": 2944, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/metrics/internal.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/metrics/internal.ts"],"sourcesContent":["import { getGlobalSingleton } from '../carrier';\nimport type { Client } from '../client';\nimport { getClient, getCurrentScope, getGlobalScope, getIsolationScope } from '../currentScopes';\nimport { DEBUG_BUILD } from '../debug-build';\nimport type { Scope, ScopeData } from '../scope';\nimport type { Integration } from '../types-hoist/integration';\nimport type { Metric, SerializedMetric, SerializedMetricAttributeValue } from '../types-hoist/metric';\nimport { mergeScopeData } from '../utils/applyScopeDataToEvent';\nimport { debug } from '../utils/debug-logger';\nimport { _getSpanForScope } from '../utils/spanOnScope';\nimport { timestampInSeconds } from '../utils/time';\nimport { _getTraceInfoFromScope } from '../utils/trace-info';\nimport { createMetricEnvelope } from './envelope';\n\nconst MAX_METRIC_BUFFER_SIZE = 1000;\n\n/**\n * Converts a metric attribute to a serialized metric attribute.\n *\n * @param value - The value of the metric attribute.\n * @returns The serialized metric attribute.\n */\nexport function metricAttributeToSerializedMetricAttribute(value: unknown): SerializedMetricAttributeValue {\n  switch (typeof value) {\n    case 'number':\n      if (Number.isInteger(value)) {\n        return {\n          value,\n          type: 'integer',\n        };\n      }\n      return {\n        value,\n        type: 'double',\n      };\n    case 'boolean':\n      return {\n        value,\n        type: 'boolean',\n      };\n    case 'string':\n      return {\n        value,\n        type: 'string',\n      };\n    default: {\n      let stringValue = '';\n      try {\n        stringValue = JSON.stringify(value) ?? '';\n      } catch {\n        // Do nothing\n      }\n      return {\n        value: stringValue,\n        type: 'string',\n      };\n    }\n  }\n}\n\n/**\n * Sets a metric attribute if the value exists and the attribute key is not already present.\n *\n * @param metricAttributes - The metric attributes object to modify.\n * @param key - The attribute key to set.\n * @param value - The value to set (only sets if truthy and key not present).\n * @param setEvenIfPresent - Whether to set the attribute if it is present. Defaults to true.\n */\nfunction setMetricAttribute(\n  metricAttributes: Record<string, unknown>,\n  key: string,\n  value: unknown,\n  setEvenIfPresent = true,\n): void {\n  if (value && (setEvenIfPresent || !(key in metricAttributes))) {\n    metricAttributes[key] = value;\n  }\n}\n\n/**\n * Captures a serialized metric event and adds it to the metric buffer for the given client.\n *\n * @param client - A client. Uses the current client if not provided.\n * @param serializedMetric - The serialized metric event to capture.\n *\n * @experimental This method will experience breaking changes. This is not yet part of\n * the stable Sentry SDK API and can be changed or removed without warning.\n */\nexport function _INTERNAL_captureSerializedMetric(client: Client, serializedMetric: SerializedMetric): void {\n  const bufferMap = _getBufferMap();\n  const metricBuffer = _INTERNAL_getMetricBuffer(client);\n\n  if (metricBuffer === undefined) {\n    bufferMap.set(client, [serializedMetric]);\n  } else {\n    if (metricBuffer.length >= MAX_METRIC_BUFFER_SIZE) {\n      _INTERNAL_flushMetricsBuffer(client, metricBuffer);\n      bufferMap.set(client, [serializedMetric]);\n    } else {\n      bufferMap.set(client, [...metricBuffer, serializedMetric]);\n    }\n  }\n}\n\n/**\n * Options for capturing a metric internally.\n */\nexport interface InternalCaptureMetricOptions {\n  /**\n   * The scope to capture the metric with.\n   */\n  scope?: Scope;\n\n  /**\n   * A function to capture the serialized metric.\n   */\n  captureSerializedMetric?: (client: Client, metric: SerializedMetric) => void;\n}\n\n/**\n * Enriches metric with all contextual attributes (user, SDK metadata, replay, etc.)\n */\nfunction _enrichMetricAttributes(beforeMetric: Metric, client: Client, currentScope: Scope): Metric {\n  const { release, environment } = client.getOptions();\n\n  const processedMetricAttributes = {\n    ...beforeMetric.attributes,\n  };\n\n  // Add user attributes\n  const {\n    user: { id, email, username },\n  } = getMergedScopeData(currentScope);\n  setMetricAttribute(processedMetricAttributes, 'user.id', id, false);\n  setMetricAttribute(processedMetricAttributes, 'user.email', email, false);\n  setMetricAttribute(processedMetricAttributes, 'user.name', username, false);\n\n  // Add Sentry metadata\n  setMetricAttribute(processedMetricAttributes, 'sentry.release', release);\n  setMetricAttribute(processedMetricAttributes, 'sentry.environment', environment);\n\n  // Add SDK metadata\n  const { name, version } = client.getSdkMetadata()?.sdk ?? {};\n  setMetricAttribute(processedMetricAttributes, 'sentry.sdk.name', name);\n  setMetricAttribute(processedMetricAttributes, 'sentry.sdk.version', version);\n\n  // Add replay metadata\n  const replay = client.getIntegrationByName<\n    Integration & {\n      getReplayId: (onlyIfSampled?: boolean) => string;\n      getRecordingMode: () => 'session' | 'buffer' | undefined;\n    }\n  >('Replay');\n\n  const replayId = replay?.getReplayId(true);\n  setMetricAttribute(processedMetricAttributes, 'sentry.replay_id', replayId);\n\n  if (replayId && replay?.getRecordingMode() === 'buffer') {\n    setMetricAttribute(processedMetricAttributes, 'sentry._internal.replay_is_buffering', true);\n  }\n\n  return {\n    ...beforeMetric,\n    attributes: processedMetricAttributes,\n  };\n}\n\n/**\n * Creates a serialized metric ready to be sent to Sentry.\n */\nfunction _buildSerializedMetric(metric: Metric, client: Client, currentScope: Scope): SerializedMetric {\n  // Serialize attributes\n  const serializedAttributes: Record<string, SerializedMetricAttributeValue> = {};\n  for (const key in metric.attributes) {\n    if (metric.attributes[key] !== undefined) {\n      serializedAttributes[key] = metricAttributeToSerializedMetricAttribute(metric.attributes[key]);\n    }\n  }\n\n  // Get trace context\n  const [, traceContext] = _getTraceInfoFromScope(client, currentScope);\n  const span = _getSpanForScope(currentScope);\n  const traceId = span ? span.spanContext().traceId : traceContext?.trace_id;\n  const spanId = span ? span.spanContext().spanId : undefined;\n\n  return {\n    timestamp: timestampInSeconds(),\n    trace_id: traceId ?? '',\n    span_id: spanId,\n    name: metric.name,\n    type: metric.type,\n    unit: metric.unit,\n    value: metric.value,\n    attributes: serializedAttributes,\n  };\n}\n\n/**\n * Captures a metric event and sends it to Sentry.\n *\n * @param metric - The metric event to capture.\n * @param options - Options for capturing the metric.\n *\n * @experimental This method will experience breaking changes. This is not yet part of\n * the stable Sentry SDK API and can be changed or removed without warning.\n */\nexport function _INTERNAL_captureMetric(beforeMetric: Metric, options?: InternalCaptureMetricOptions): void {\n  const currentScope = options?.scope ?? getCurrentScope();\n  const captureSerializedMetric = options?.captureSerializedMetric ?? _INTERNAL_captureSerializedMetric;\n  const client = currentScope?.getClient() ?? getClient();\n  if (!client) {\n    DEBUG_BUILD && debug.warn('No client available to capture metric.');\n    return;\n  }\n\n  const { _experiments, enableMetrics, beforeSendMetric } = client.getOptions();\n\n  // todo(v11): Remove the experimental flag\n  // eslint-disable-next-line deprecation/deprecation\n  const metricsEnabled = enableMetrics ?? _experiments?.enableMetrics ?? true;\n\n  if (!metricsEnabled) {\n    DEBUG_BUILD && debug.warn('metrics option not enabled, metric will not be captured.');\n    return;\n  }\n\n  // Enrich metric with contextual attributes\n  const enrichedMetric = _enrichMetricAttributes(beforeMetric, client, currentScope);\n\n  client.emit('processMetric', enrichedMetric);\n\n  // todo(v11): Remove the experimental `beforeSendMetric`\n  // eslint-disable-next-line deprecation/deprecation\n  const beforeSendCallback = beforeSendMetric || _experiments?.beforeSendMetric;\n  const processedMetric = beforeSendCallback ? beforeSendCallback(enrichedMetric) : enrichedMetric;\n\n  if (!processedMetric) {\n    DEBUG_BUILD && debug.log('`beforeSendMetric` returned `null`, will not send metric.');\n    return;\n  }\n\n  const serializedMetric = _buildSerializedMetric(processedMetric, client, currentScope);\n\n  DEBUG_BUILD && debug.log('[Metric]', serializedMetric);\n\n  captureSerializedMetric(client, serializedMetric);\n\n  client.emit('afterCaptureMetric', processedMetric);\n}\n\n/**\n * Flushes the metrics buffer to Sentry.\n *\n * @param client - A client.\n * @param maybeMetricBuffer - A metric buffer. Uses the metric buffer for the given client if not provided.\n *\n * @experimental This method will experience breaking changes. This is not yet part of\n * the stable Sentry SDK API and can be changed or removed without warning.\n */\nexport function _INTERNAL_flushMetricsBuffer(client: Client, maybeMetricBuffer?: Array<SerializedMetric>): void {\n  const metricBuffer = maybeMetricBuffer ?? _INTERNAL_getMetricBuffer(client) ?? [];\n  if (metricBuffer.length === 0) {\n    return;\n  }\n\n  const clientOptions = client.getOptions();\n  const envelope = createMetricEnvelope(metricBuffer, clientOptions._metadata, clientOptions.tunnel, client.getDsn());\n\n  // Clear the metric buffer after envelopes have been constructed.\n  _getBufferMap().set(client, []);\n\n  client.emit('flushMetrics');\n\n  // sendEnvelope should not throw\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  client.sendEnvelope(envelope);\n}\n\n/**\n * Returns the metric buffer for a given client.\n *\n * Exported for testing purposes.\n *\n * @param client - The client to get the metric buffer for.\n * @returns The metric buffer for the given client.\n */\nexport function _INTERNAL_getMetricBuffer(client: Client): Array<SerializedMetric> | undefined {\n  return _getBufferMap().get(client);\n}\n\n/**\n * Get the scope data for the current scope after merging with the\n * global scope and isolation scope.\n *\n * @param currentScope - The current scope.\n * @returns The scope data.\n */\nfunction getMergedScopeData(currentScope: Scope): ScopeData {\n  const scopeData = getGlobalScope().getScopeData();\n  mergeScopeData(scopeData, getIsolationScope().getScopeData());\n  mergeScopeData(scopeData, currentScope.getScopeData());\n  return scopeData;\n}\n\nfunction _getBufferMap(): WeakMap<Client, Array<SerializedMetric>> {\n  // The reference to the Client <> MetricBuffer map is stored on the carrier to ensure it's always the same\n  return getGlobalSingleton('clientToMetricBufferMap', () => new WeakMap<Client, Array<SerializedMetric>>());\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3212, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/metrics/public-api.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/metrics/public-api.ts"],"sourcesContent":["import type { Scope } from '../scope';\nimport type { Metric, MetricType } from '../types-hoist/metric';\nimport { _INTERNAL_captureMetric } from './internal';\n\n/**\n * Options for capturing a metric.\n */\nexport interface MetricOptions {\n  /**\n   * The unit of the metric value.\n   */\n  unit?: string;\n\n  /**\n   * Arbitrary structured data that stores information about the metric.\n   */\n  attributes?: Metric['attributes'];\n\n  /**\n   * The scope to capture the metric with.\n   */\n  scope?: Scope;\n}\n\n/**\n * Capture a metric with the given type, name, and value.\n *\n * @param type - The type of the metric.\n * @param name - The name of the metric.\n * @param value - The value of the metric.\n * @param options - Options for capturing the metric.\n */\nfunction captureMetric(type: MetricType, name: string, value: number, options?: MetricOptions): void {\n  _INTERNAL_captureMetric(\n    { type, name, value, unit: options?.unit, attributes: options?.attributes },\n    { scope: options?.scope },\n  );\n}\n\n/**\n * @summary Increment a counter metric. Requires the `_experiments.enableMetrics` option to be enabled.\n *\n * @param name - The name of the counter metric.\n * @param value - The value to increment by (defaults to 1).\n * @param options - Options for capturing the metric.\n *\n * @example\n *\n * ```\n * Sentry.metrics.count('api.requests', 1, {\n *   attributes: {\n *     endpoint: '/api/users',\n *     method: 'GET',\n *     status: 200\n *   }\n * });\n * ```\n *\n * @example With custom value\n *\n * ```\n * Sentry.metrics.count('items.processed', 5, {\n *   attributes: {\n *     processor: 'batch-processor',\n *     queue: 'high-priority'\n *   }\n * });\n * ```\n */\nexport function count(name: string, value: number = 1, options?: MetricOptions): void {\n  captureMetric('counter', name, value, options);\n}\n\n/**\n * @summary Set a gauge metric to a specific value. Requires the `_experiments.enableMetrics` option to be enabled.\n *\n * @param name - The name of the gauge metric.\n * @param value - The current value of the gauge.\n * @param options - Options for capturing the metric.\n *\n * @example\n *\n * ```\n * Sentry.metrics.gauge('memory.usage', 1024, {\n *   unit: 'megabyte',\n *   attributes: {\n *     process: 'web-server',\n *     region: 'us-east-1'\n *   }\n * });\n * ```\n *\n * @example Without unit\n *\n * ```\n * Sentry.metrics.gauge('active.connections', 42, {\n *   attributes: {\n *     server: 'api-1',\n *     protocol: 'websocket'\n *   }\n * });\n * ```\n */\nexport function gauge(name: string, value: number, options?: MetricOptions): void {\n  captureMetric('gauge', name, value, options);\n}\n\n/**\n * @summary Record a value in a distribution metric. Requires the `_experiments.enableMetrics` option to be enabled.\n *\n * @param name - The name of the distribution metric.\n * @param value - The value to record in the distribution.\n * @param options - Options for capturing the metric.\n *\n * @example\n *\n * ```\n * Sentry.metrics.distribution('task.duration', 500, {\n *   unit: 'millisecond',\n *   attributes: {\n *     task: 'data-processing',\n *     priority: 'high'\n *   }\n * });\n * ```\n *\n * @example Without unit\n *\n * ```\n * Sentry.metrics.distribution('batch.size', 100, {\n *   attributes: {\n *     processor: 'batch-1',\n *     type: 'async'\n *   }\n * });\n * ```\n */\nexport function distribution(name: string, value: number, options?: MetricOptions): void {\n  captureMetric('distribution', name, value, options);\n}\n"],"names":[],"mappings":";;;;;;;;;;AAIA;;CAEA,GAkBA;;;;;;;CAOA,GACA,SAAS,aAAa,CAAC,IAAI,EAAc,IAAI,EAAU,KAAK,EAAU,OAAO,EAAwB;QACnG,oQAAuB,EACrB;QAAE,IAAI;QAAE,IAAI;QAAE,KAAK;QAAE,IAAI,EAAE,OAAO,EAAE,IAAI;QAAE,UAAU,EAAE,OAAO,EAAE;IAAA,CAAY,EAC3E;QAAE,KAAK,EAAE,OAAO,EAAE;IAAA,CAAO;AAE7B;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6BA,GACO,SAAS,KAAK,CAAC,IAAI,EAAU,KAAK,GAAW,CAAC,EAAE,OAAO,EAAwB;IACpF,aAAa,CAAC,SAAS,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,CAAC;AAChD;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6BA,GACO,SAAS,KAAK,CAAC,IAAI,EAAU,KAAK,EAAU,OAAO,EAAwB;IAChF,aAAa,CAAC,OAAO,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,CAAC;AAC9C;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6BA,GACO,SAAS,YAAY,CAAC,IAAI,EAAU,KAAK,EAAU,OAAO,EAAwB;IACvF,aAAa,CAAC,cAAc,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,CAAC;AACrD"}},
    {"offset": {"line": 3353, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/client.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/client.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport { getEnvelopeEndpointWithUrlEncodedAuth } from './api';\nimport { DEFAULT_ENVIRONMENT } from './constants';\nimport { getCurrentScope, getIsolationScope, getTraceContextFromScope } from './currentScopes';\nimport { DEBUG_BUILD } from './debug-build';\nimport { createEventEnvelope, createSessionEnvelope } from './envelope';\nimport type { IntegrationIndex } from './integration';\nimport { afterSetupIntegrations, setupIntegration, setupIntegrations } from './integration';\nimport { _INTERNAL_flushLogsBuffer } from './logs/internal';\nimport { _INTERNAL_flushMetricsBuffer } from './metrics/internal';\nimport type { Scope } from './scope';\nimport { updateSession } from './session';\nimport { getDynamicSamplingContextFromScope } from './tracing/dynamicSamplingContext';\nimport type { Breadcrumb, BreadcrumbHint, FetchBreadcrumbHint, XhrBreadcrumbHint } from './types-hoist/breadcrumb';\nimport type { CheckIn, MonitorConfig } from './types-hoist/checkin';\nimport type { EventDropReason, Outcome } from './types-hoist/clientreport';\nimport type { DataCategory } from './types-hoist/datacategory';\nimport type { DsnComponents } from './types-hoist/dsn';\nimport type { DynamicSamplingContext, Envelope } from './types-hoist/envelope';\nimport type { ErrorEvent, Event, EventHint, TransactionEvent } from './types-hoist/event';\nimport type { EventProcessor } from './types-hoist/eventprocessor';\nimport type { FeedbackEvent } from './types-hoist/feedback';\nimport type { Integration } from './types-hoist/integration';\nimport type { Log } from './types-hoist/log';\nimport type { Metric } from './types-hoist/metric';\nimport type { Primitive } from './types-hoist/misc';\nimport type { ClientOptions } from './types-hoist/options';\nimport type { ParameterizedString } from './types-hoist/parameterize';\nimport type { RequestEventData } from './types-hoist/request';\nimport type { SdkMetadata } from './types-hoist/sdkmetadata';\nimport type { Session, SessionAggregates } from './types-hoist/session';\nimport type { SeverityLevel } from './types-hoist/severity';\nimport type { Span, SpanAttributes, SpanContextData, SpanJSON } from './types-hoist/span';\nimport type { StartSpanOptions } from './types-hoist/startSpanOptions';\nimport type { Transport, TransportMakeRequestResponse } from './types-hoist/transport';\nimport { createClientReportEnvelope } from './utils/clientreport';\nimport { debug } from './utils/debug-logger';\nimport { dsnToString, makeDsn } from './utils/dsn';\nimport { addItemToEnvelope, createAttachmentEnvelopeItem } from './utils/envelope';\nimport { getPossibleEventMessages } from './utils/eventUtils';\nimport { isParameterizedString, isPlainObject, isPrimitive, isThenable } from './utils/is';\nimport { merge } from './utils/merge';\nimport { checkOrSetAlreadyCaught, uuid4 } from './utils/misc';\nimport { parseSampleRate } from './utils/parseSampleRate';\nimport { prepareEvent } from './utils/prepareEvent';\nimport { reparentChildSpans, shouldIgnoreSpan } from './utils/should-ignore-span';\nimport { showSpanDropWarning } from './utils/spanUtils';\nimport { rejectedSyncPromise } from './utils/syncpromise';\nimport { convertSpanJsonToTransactionEvent, convertTransactionEventToSpanJson } from './utils/transactionEvent';\n\nconst ALREADY_SEEN_ERROR = \"Not capturing exception because it's already been captured.\";\nconst MISSING_RELEASE_FOR_SESSION_ERROR = 'Discarded session because of missing or non-string release';\n\nconst INTERNAL_ERROR_SYMBOL = Symbol.for('SentryInternalError');\nconst DO_NOT_SEND_EVENT_SYMBOL = Symbol.for('SentryDoNotSendEventError');\n\n// Default interval for flushing logs and metrics (5 seconds)\nconst DEFAULT_FLUSH_INTERVAL = 5000;\n\ninterface InternalError {\n  message: string;\n  [INTERNAL_ERROR_SYMBOL]: true;\n}\n\ninterface DoNotSendEventError {\n  message: string;\n  [DO_NOT_SEND_EVENT_SYMBOL]: true;\n}\n\nfunction _makeInternalError(message: string): InternalError {\n  return {\n    message,\n    [INTERNAL_ERROR_SYMBOL]: true,\n  };\n}\n\nfunction _makeDoNotSendEventError(message: string): DoNotSendEventError {\n  return {\n    message,\n    [DO_NOT_SEND_EVENT_SYMBOL]: true,\n  };\n}\n\nfunction _isInternalError(error: unknown): error is InternalError {\n  return !!error && typeof error === 'object' && INTERNAL_ERROR_SYMBOL in error;\n}\n\nfunction _isDoNotSendEventError(error: unknown): error is DoNotSendEventError {\n  return !!error && typeof error === 'object' && DO_NOT_SEND_EVENT_SYMBOL in error;\n}\n\n/**\n * Sets up weight-based flushing for logs or metrics.\n * This helper function encapsulates the common pattern of:\n * 1. Tracking accumulated weight of items\n * 2. Flushing when weight exceeds threshold (800KB)\n * 3. Flushing after timeout period from the first item\n *\n * Uses closure variables to track weight and timeout state.\n */\nfunction setupWeightBasedFlushing<\n  T,\n  AfterCaptureHook extends 'afterCaptureLog' | 'afterCaptureMetric',\n  FlushHook extends 'flushLogs' | 'flushMetrics',\n>(\n  client: Client,\n  afterCaptureHook: AfterCaptureHook,\n  flushHook: FlushHook,\n  estimateSizeFn: (item: T) => number,\n  flushFn: (client: Client) => void,\n): void {\n  // Track weight and timeout in closure variables\n  let weight = 0;\n  let flushTimeout: ReturnType<typeof setTimeout> | undefined;\n  let isTimerActive = false;\n\n  // @ts-expect-error - TypeScript can't narrow generic hook types to match specific overloads, but we know this is type-safe\n  client.on(flushHook, () => {\n    weight = 0;\n    clearTimeout(flushTimeout);\n    isTimerActive = false;\n  });\n\n  // @ts-expect-error - TypeScript can't narrow generic hook types to match specific overloads, but we know this is type-safe\n  client.on(afterCaptureHook, (item: T) => {\n    weight += estimateSizeFn(item);\n\n    // We flush the buffer if it exceeds 0.8 MB\n    // The weight is a rough estimate, so we flush way before the payload gets too big.\n    if (weight >= 800_000) {\n      flushFn(client);\n    } else if (!isTimerActive) {\n      // Only start timer if one isn't already running.\n      // This prevents flushing being delayed by items that arrive close to the timeout limit\n      // and thus resetting the flushing timeout and delaying items being flushed.\n      isTimerActive = true;\n      flushTimeout = setTimeout(() => {\n        flushFn(client);\n        // Note: isTimerActive is reset by the flushHook handler above, not here,\n        // to avoid race conditions when new items arrive during the flush.\n      }, DEFAULT_FLUSH_INTERVAL);\n    }\n  });\n\n  client.on('flush', () => {\n    flushFn(client);\n  });\n}\n\n/**\n * Base implementation for all JavaScript SDK clients.\n *\n * Call the constructor with the corresponding options\n * specific to the client subclass. To access these options later, use\n * {@link Client.getOptions}.\n *\n * If a Dsn is specified in the options, it will be parsed and stored. Use\n * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is\n * invalid, the constructor will throw a {@link SentryException}. Note that\n * without a valid Dsn, the SDK will not send any events to Sentry.\n *\n * Before sending an event, it is passed through\n * {@link Client._prepareEvent} to add SDK information and scope data\n * (breadcrumbs and context). To add more custom information, override this\n * method and extend the resulting prepared event.\n *\n * To issue automatically created events (e.g. via instrumentation), use\n * {@link Client.captureEvent}. It will prepare the event and pass it through\n * the callback lifecycle. To issue auto-breadcrumbs, use\n * {@link Client.addBreadcrumb}.\n *\n * @example\n * class NodeClient extends Client<NodeOptions> {\n *   public constructor(options: NodeOptions) {\n *     super(options);\n *   }\n *\n *   // ...\n * }\n */\nexport abstract class Client<O extends ClientOptions = ClientOptions> {\n  /** Options passed to the SDK. */\n  protected readonly _options: O;\n\n  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */\n  protected readonly _dsn?: DsnComponents;\n\n  protected readonly _transport?: Transport;\n\n  /** Array of set up integrations. */\n  protected _integrations: IntegrationIndex;\n\n  /** Number of calls being processed */\n  protected _numProcessing: number;\n\n  protected _eventProcessors: EventProcessor[];\n\n  /** Holds flushable  */\n  private _outcomes: { [key: string]: number };\n\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  private _hooks: Record<string, Set<Function>>;\n\n  /**\n   * Initializes this client instance.\n   *\n   * @param options Options for the client.\n   */\n  protected constructor(options: O) {\n    this._options = options;\n    this._integrations = {};\n    this._numProcessing = 0;\n    this._outcomes = {};\n    this._hooks = {};\n    this._eventProcessors = [];\n\n    if (options.dsn) {\n      this._dsn = makeDsn(options.dsn);\n    } else {\n      DEBUG_BUILD && debug.warn('No DSN provided, client will not send events.');\n    }\n\n    if (this._dsn) {\n      const url = getEnvelopeEndpointWithUrlEncodedAuth(\n        this._dsn,\n        options.tunnel,\n        options._metadata ? options._metadata.sdk : undefined,\n      );\n      this._transport = options.transport({\n        tunnel: this._options.tunnel,\n        recordDroppedEvent: this.recordDroppedEvent.bind(this),\n        ...options.transportOptions,\n        url,\n      });\n    }\n\n    // Setup log flushing with weight and timeout tracking\n    if (this._options.enableLogs) {\n      setupWeightBasedFlushing(this, 'afterCaptureLog', 'flushLogs', estimateLogSizeInBytes, _INTERNAL_flushLogsBuffer);\n    }\n\n    // todo(v11): Remove the experimental flag\n    // eslint-disable-next-line deprecation/deprecation\n    const enableMetrics = this._options.enableMetrics ?? this._options._experiments?.enableMetrics ?? true;\n\n    // Setup metric flushing with weight and timeout tracking\n    if (enableMetrics) {\n      setupWeightBasedFlushing(\n        this,\n        'afterCaptureMetric',\n        'flushMetrics',\n        estimateMetricSizeInBytes,\n        _INTERNAL_flushMetricsBuffer,\n      );\n    }\n  }\n\n  /**\n   * Captures an exception event and sends it to Sentry.\n   *\n   * Unlike `captureException` exported from every SDK, this method requires that you pass it the current scope.\n   */\n  public captureException(exception: unknown, hint?: EventHint, scope?: Scope): string {\n    const eventId = uuid4();\n\n    // ensure we haven't captured this very object before\n    if (checkOrSetAlreadyCaught(exception)) {\n      DEBUG_BUILD && debug.log(ALREADY_SEEN_ERROR);\n      return eventId;\n    }\n\n    const hintWithEventId = {\n      event_id: eventId,\n      ...hint,\n    };\n\n    this._process(\n      this.eventFromException(exception, hintWithEventId).then(event =>\n        this._captureEvent(event, hintWithEventId, scope),\n      ),\n    );\n\n    return hintWithEventId.event_id;\n  }\n\n  /**\n   * Captures a message event and sends it to Sentry.\n   *\n   * Unlike `captureMessage` exported from every SDK, this method requires that you pass it the current scope.\n   */\n  public captureMessage(\n    message: ParameterizedString,\n    level?: SeverityLevel,\n    hint?: EventHint,\n    currentScope?: Scope,\n  ): string {\n    const hintWithEventId = {\n      event_id: uuid4(),\n      ...hint,\n    };\n\n    const eventMessage = isParameterizedString(message) ? message : String(message);\n\n    const promisedEvent = isPrimitive(message)\n      ? this.eventFromMessage(eventMessage, level, hintWithEventId)\n      : this.eventFromException(message, hintWithEventId);\n\n    this._process(promisedEvent.then(event => this._captureEvent(event, hintWithEventId, currentScope)));\n\n    return hintWithEventId.event_id;\n  }\n\n  /**\n   * Captures a manually created event and sends it to Sentry.\n   *\n   * Unlike `captureEvent` exported from every SDK, this method requires that you pass it the current scope.\n   */\n  public captureEvent(event: Event, hint?: EventHint, currentScope?: Scope): string {\n    const eventId = uuid4();\n\n    // ensure we haven't captured this very object before\n    if (hint?.originalException && checkOrSetAlreadyCaught(hint.originalException)) {\n      DEBUG_BUILD && debug.log(ALREADY_SEEN_ERROR);\n      return eventId;\n    }\n\n    const hintWithEventId = {\n      event_id: eventId,\n      ...hint,\n    };\n\n    const sdkProcessingMetadata = event.sdkProcessingMetadata || {};\n    const capturedSpanScope: Scope | undefined = sdkProcessingMetadata.capturedSpanScope;\n    const capturedSpanIsolationScope: Scope | undefined = sdkProcessingMetadata.capturedSpanIsolationScope;\n\n    this._process(\n      this._captureEvent(event, hintWithEventId, capturedSpanScope || currentScope, capturedSpanIsolationScope),\n    );\n\n    return hintWithEventId.event_id;\n  }\n\n  /**\n   * Captures a session.\n   */\n  public captureSession(session: Session): void {\n    this.sendSession(session);\n    // After sending, we set init false to indicate it's not the first occurrence\n    updateSession(session, { init: false });\n  }\n\n  /**\n   * Create a cron monitor check in and send it to Sentry. This method is not available on all clients.\n   *\n   * @param checkIn An object that describes a check in.\n   * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n   * to create a monitor automatically when sending a check in.\n   * @param scope An optional scope containing event metadata.\n   * @returns A string representing the id of the check in.\n   */\n  public captureCheckIn?(checkIn: CheckIn, monitorConfig?: MonitorConfig, scope?: Scope): string;\n\n  /**\n   * Get the current Dsn.\n   */\n  public getDsn(): DsnComponents | undefined {\n    return this._dsn;\n  }\n\n  /**\n   * Get the current options.\n   */\n  public getOptions(): O {\n    return this._options;\n  }\n\n  /**\n   * Get the SDK metadata.\n   * @see SdkMetadata\n   */\n  public getSdkMetadata(): SdkMetadata | undefined {\n    return this._options._metadata;\n  }\n\n  /**\n   * Returns the transport that is used by the client.\n   * Please note that the transport gets lazy initialized so it will only be there once the first event has been sent.\n   */\n  public getTransport(): Transport | undefined {\n    return this._transport;\n  }\n\n  /**\n   * Wait for all events to be sent or the timeout to expire, whichever comes first.\n   *\n   * @param timeout Maximum time in ms the client should wait for events to be flushed. Omitting this parameter will\n   *   cause the client to wait until all events are sent before resolving the promise.\n   * @returns A promise that will resolve with `true` if all events are sent before the timeout, or `false` if there are\n   * still events in the queue when the timeout is reached.\n   */\n  // @ts-expect-error - PromiseLike is a subset of Promise\n  public async flush(timeout?: number): PromiseLike<boolean> {\n    const transport = this._transport;\n    if (!transport) {\n      return true;\n    }\n\n    this.emit('flush');\n\n    const clientFinished = await this._isClientDoneProcessing(timeout);\n    const transportFlushed = await transport.flush(timeout);\n\n    return clientFinished && transportFlushed;\n  }\n\n  /**\n   * Flush the event queue and set the client to `enabled = false`. See {@link Client.flush}.\n   *\n   * @param {number} timeout Maximum time in ms the client should wait before shutting down. Omitting this parameter will cause\n   *   the client to wait until all events are sent before disabling itself.\n   * @returns {Promise<boolean>} A promise which resolves to `true` if the flush completes successfully before the timeout, or `false` if\n   * it doesn't.\n   */\n  // @ts-expect-error - PromiseLike is a subset of Promise\n  public async close(timeout?: number): PromiseLike<boolean> {\n    const result = await this.flush(timeout);\n    this.getOptions().enabled = false;\n    this.emit('close');\n    return result;\n  }\n\n  /**\n   * Get all installed event processors.\n   */\n  public getEventProcessors(): EventProcessor[] {\n    return this._eventProcessors;\n  }\n\n  /**\n   * Adds an event processor that applies to any event processed by this client.\n   */\n  public addEventProcessor(eventProcessor: EventProcessor): void {\n    this._eventProcessors.push(eventProcessor);\n  }\n\n  /**\n   * Initialize this client.\n   * Call this after the client was set on a scope.\n   */\n  public init(): void {\n    if (\n      this._isEnabled() ||\n      // Force integrations to be setup even if no DSN was set when we have\n      // Spotlight enabled. This is particularly important for browser as we\n      // don't support the `spotlight` option there and rely on the users\n      // adding the `spotlightBrowserIntegration()` to their integrations which\n      // wouldn't get initialized with the check below when there's no DSN set.\n      this._options.integrations.some(({ name }) => name.startsWith('Spotlight'))\n    ) {\n      this._setupIntegrations();\n    }\n  }\n\n  /**\n   * Gets an installed integration by its name.\n   *\n   * @returns {Integration|undefined} The installed integration or `undefined` if no integration with that `name` was installed.\n   */\n  public getIntegrationByName<T extends Integration = Integration>(integrationName: string): T | undefined {\n    return this._integrations[integrationName] as T | undefined;\n  }\n\n  /**\n   * Add an integration to the client.\n   * This can be used to e.g. lazy load integrations.\n   * In most cases, this should not be necessary,\n   * and you're better off just passing the integrations via `integrations: []` at initialization time.\n   * However, if you find the need to conditionally load & add an integration, you can use `addIntegration` to do so.\n   */\n  public addIntegration(integration: Integration): void {\n    const isAlreadyInstalled = this._integrations[integration.name];\n\n    // This hook takes care of only installing if not already installed\n    setupIntegration(this, integration, this._integrations);\n    // Here we need to check manually to make sure to not run this multiple times\n    if (!isAlreadyInstalled) {\n      afterSetupIntegrations(this, [integration]);\n    }\n  }\n\n  /**\n   * Send a fully prepared event to Sentry.\n   */\n  public sendEvent(event: Event, hint: EventHint = {}): void {\n    this.emit('beforeSendEvent', event, hint);\n\n    let env = createEventEnvelope(event, this._dsn, this._options._metadata, this._options.tunnel);\n\n    for (const attachment of hint.attachments || []) {\n      env = addItemToEnvelope(env, createAttachmentEnvelopeItem(attachment));\n    }\n\n    // sendEnvelope should not throw\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.sendEnvelope(env).then(sendResponse => this.emit('afterSendEvent', event, sendResponse));\n  }\n\n  /**\n   * Send a session or session aggregrates to Sentry.\n   */\n  public sendSession(session: Session | SessionAggregates): void {\n    // Backfill release and environment on session\n    const { release: clientReleaseOption, environment: clientEnvironmentOption = DEFAULT_ENVIRONMENT } = this._options;\n    if ('aggregates' in session) {\n      const sessionAttrs = session.attrs || {};\n      if (!sessionAttrs.release && !clientReleaseOption) {\n        DEBUG_BUILD && debug.warn(MISSING_RELEASE_FOR_SESSION_ERROR);\n        return;\n      }\n      sessionAttrs.release = sessionAttrs.release || clientReleaseOption;\n      sessionAttrs.environment = sessionAttrs.environment || clientEnvironmentOption;\n      session.attrs = sessionAttrs;\n    } else {\n      if (!session.release && !clientReleaseOption) {\n        DEBUG_BUILD && debug.warn(MISSING_RELEASE_FOR_SESSION_ERROR);\n        return;\n      }\n      session.release = session.release || clientReleaseOption;\n      session.environment = session.environment || clientEnvironmentOption;\n    }\n\n    this.emit('beforeSendSession', session);\n\n    const env = createSessionEnvelope(session, this._dsn, this._options._metadata, this._options.tunnel);\n\n    // sendEnvelope should not throw\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.sendEnvelope(env);\n  }\n\n  /**\n   * Record on the client that an event got dropped (ie, an event that will not be sent to Sentry).\n   */\n  public recordDroppedEvent(reason: EventDropReason, category: DataCategory, count: number = 1): void {\n    if (this._options.sendClientReports) {\n      // We want to track each category (error, transaction, session, replay_event) separately\n      // but still keep the distinction between different type of outcomes.\n      // We could use nested maps, but it's much easier to read and type this way.\n      // A correct type for map-based implementation if we want to go that route\n      // would be `Partial<Record<SentryRequestType, Partial<Record<Outcome, number>>>>`\n      // With typescript 4.1 we could even use template literal types\n      const key = `${reason}:${category}`;\n      DEBUG_BUILD && debug.log(`Recording outcome: \"${key}\"${count > 1 ? ` (${count} times)` : ''}`);\n      this._outcomes[key] = (this._outcomes[key] || 0) + count;\n    }\n  }\n\n  /* eslint-disable @typescript-eslint/unified-signatures */\n  /**\n   * Register a callback for whenever a span is started.\n   * Receives the span as argument.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'spanStart', callback: (span: Span) => void): () => void;\n\n  /**\n   * Register a callback before span sampling runs. Receives a `samplingDecision` object argument with a `decision`\n   * property that can be used to make a sampling decision that will be enforced, before any span sampling runs.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(\n    hook: 'beforeSampling',\n    callback: (\n      samplingData: {\n        spanAttributes: SpanAttributes;\n        spanName: string;\n        parentSampled?: boolean;\n        parentSampleRate?: number;\n        parentContext?: SpanContextData;\n      },\n      samplingDecision: { decision: boolean },\n    ) => void,\n  ): void;\n\n  /**\n   * Register a callback for after a span is ended.\n   * NOTE: The span cannot be mutated anymore in this callback.\n   * Receives the span as argument.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'spanEnd', callback: (span: Span) => void): () => void;\n\n  /**\n   * Register a callback for when an idle span is allowed to auto-finish.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'idleSpanEnableAutoFinish', callback: (span: Span) => void): () => void;\n\n  /**\n   * Register a callback for transaction start and finish.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'beforeEnvelope', callback: (envelope: Envelope) => void): () => void;\n\n  /**\n   * Register a callback that runs when stack frame metadata should be applied to an event.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'applyFrameMetadata', callback: (event: Event) => void): () => void;\n\n  /**\n   * Register a callback for before sending an event.\n   * This is called right before an event is sent and should not be used to mutate the event.\n   * Receives an Event & EventHint as arguments.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'beforeSendEvent', callback: (event: Event, hint?: EventHint | undefined) => void): () => void;\n\n  /**\n   * Register a callback for before sending a session or session aggregrates..\n   * Receives the session/aggregate as second argument.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'beforeSendSession', callback: (session: Session | SessionAggregates) => void): () => void;\n\n  /**\n   * Register a callback for preprocessing an event,\n   * before it is passed to (global) event processors.\n   * Receives an Event & EventHint as arguments.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'preprocessEvent', callback: (event: Event, hint?: EventHint | undefined) => void): () => void;\n\n  /**\n   * Register a callback for postprocessing an event,\n   * after it was passed to (global) event processors, before it is being sent.\n   * Receives an Event & EventHint as arguments.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'postprocessEvent', callback: (event: Event, hint?: EventHint | undefined) => void): () => void;\n\n  /**\n   * Register a callback for when an event has been sent.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(\n    hook: 'afterSendEvent',\n    callback: (event: Event, sendResponse: TransportMakeRequestResponse) => void,\n  ): () => void;\n\n  /**\n   * Register a callback before a breadcrumb is added.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'beforeAddBreadcrumb', callback: (breadcrumb: Breadcrumb, hint?: BreadcrumbHint) => void): () => void;\n\n  /**\n   * Register a callback when a DSC (Dynamic Sampling Context) is created.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'createDsc', callback: (dsc: DynamicSamplingContext, rootSpan?: Span) => void): () => void;\n\n  /**\n   * Register a callback when a Feedback event has been prepared.\n   * This should be used to mutate the event. The options argument can hint\n   * about what kind of mutation it expects.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(\n    hook: 'beforeSendFeedback',\n    callback: (feedback: FeedbackEvent, options?: { includeReplay?: boolean }) => void,\n  ): () => void;\n\n  /**\n   * Register a callback when the feedback widget is opened in a user's browser\n   */\n  public on(hook: 'openFeedbackWidget', callback: () => void): () => void;\n\n  /**\n   * A hook for the browser tracing integrations to trigger a span start for a page load.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(\n    hook: 'startPageLoadSpan',\n    callback: (\n      options: StartSpanOptions,\n      traceOptions?: { sentryTrace?: string | undefined; baggage?: string | undefined },\n    ) => void,\n  ): () => void;\n\n  /**\n   * A hook for the browser tracing integrations to trigger the end of a page load span.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'endPageloadSpan', callback: () => void): () => void;\n\n  /**\n   * A hook for the browser tracing integrations to trigger after the pageload span was started.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'afterStartPageLoadSpan', callback: (span: Span) => void): () => void;\n\n  /**\n   * A hook for triggering right before a navigation span is started.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(\n    hook: 'beforeStartNavigationSpan',\n    callback: (options: StartSpanOptions, navigationOptions?: { isRedirect?: boolean }) => void,\n  ): () => void;\n\n  /**\n   * A hook for browser tracing integrations to trigger a span for a navigation.\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(\n    hook: 'startNavigationSpan',\n    callback: (options: StartSpanOptions, navigationOptions?: { isRedirect?: boolean }) => void,\n  ): () => void;\n\n  /**\n   * A hook for GraphQL client integration to enhance a span with request data.\n   * @returns A function that, when executed, removes the registered callback.\n   */\n  public on(\n    hook: 'beforeOutgoingRequestSpan',\n    callback: (span: Span, hint: XhrBreadcrumbHint | FetchBreadcrumbHint) => void,\n  ): () => void;\n\n  /**\n   * A hook for GraphQL client integration to enhance a breadcrumb with request data.\n   * @returns A function that, when executed, removes the registered callback.\n   */\n  public on(\n    hook: 'beforeOutgoingRequestBreadcrumb',\n    callback: (breadcrumb: Breadcrumb, hint: XhrBreadcrumbHint | FetchBreadcrumbHint) => void,\n  ): () => void;\n\n  /**\n   * A hook that is called when the client is flushing\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'flush', callback: () => void): () => void;\n\n  /**\n   * A hook that is called when the client is closing\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'close', callback: () => void): () => void;\n\n  /**\n   * A hook that is called before a log is captured. This hooks runs before `beforeSendLog` is fired.\n   *\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'beforeCaptureLog', callback: (log: Log) => void): () => void;\n\n  /**\n   * A hook that is called after a log is captured\n   *\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'afterCaptureLog', callback: (log: Log) => void): () => void;\n\n  /**\n   * A hook that is called when the client is flushing logs\n   *\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'flushLogs', callback: () => void): () => void;\n\n  /**\n   * A hook that is called after capturing a metric. This hooks runs after `beforeSendMetric` is fired.\n   *\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'afterCaptureMetric', callback: (metric: Metric) => void): () => void;\n\n  /**\n   * A hook that is called when the client is flushing metrics\n   *\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'flushMetrics', callback: () => void): () => void;\n\n  /**\n   * A hook that is called when a metric is processed before it is captured and before the `beforeSendMetric` callback is fired.\n   *\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(hook: 'processMetric', callback: (metric: Metric) => void): () => void;\n\n  /**\n   * A hook that is called when a http server request is started.\n   * This hook is called after request isolation, but before the request is processed.\n   *\n   * @returns {() => void} A function that, when executed, removes the registered callback.\n   */\n  public on(\n    hook: 'httpServerRequest',\n    callback: (request: unknown, response: unknown, normalizedRequest: RequestEventData) => void,\n  ): () => void;\n\n  /**\n   * Register a hook on this client.\n   */\n  public on(hook: string, callback: unknown): () => void {\n    const hookCallbacks = (this._hooks[hook] = this._hooks[hook] || new Set());\n\n    // Wrap the callback in a function so that registering the same callback instance multiple\n    // times results in the callback being called multiple times.\n    // @ts-expect-error - The `callback` type is correct and must be a function due to the\n    // individual, specific overloads of this function.\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    const uniqueCallback: Function = (...args: unknown[]) => callback(...args);\n\n    hookCallbacks.add(uniqueCallback);\n\n    // This function returns a callback execution handler that, when invoked,\n    // deregisters a callback. This is crucial for managing instances where callbacks\n    // need to be unregistered to prevent self-referencing in callback closures,\n    // ensuring proper garbage collection.\n    return () => {\n      hookCallbacks.delete(uniqueCallback);\n    };\n  }\n\n  /** Fire a hook whenever a span starts. */\n  public emit(hook: 'spanStart', span: Span): void;\n\n  /** A hook that is called every time before a span is sampled. */\n  public emit(\n    hook: 'beforeSampling',\n    samplingData: {\n      spanAttributes: SpanAttributes;\n      spanName: string;\n      parentSampled?: boolean;\n      parentSampleRate?: number;\n      parentContext?: SpanContextData;\n    },\n    samplingDecision: { decision: boolean },\n  ): void;\n\n  /** Fire a hook whenever a span ends. */\n  public emit(hook: 'spanEnd', span: Span): void;\n\n  /**\n   * Fire a hook indicating that an idle span is allowed to auto finish.\n   */\n  public emit(hook: 'idleSpanEnableAutoFinish', span: Span): void;\n\n  /*\n   * Fire a hook event for envelope creation and sending. Expects to be given an envelope as the\n   * second argument.\n   */\n  public emit(hook: 'beforeEnvelope', envelope: Envelope): void;\n\n  /*\n   * Fire a hook indicating that stack frame metadata should be applied to the event passed to the hook.\n   */\n  public emit(hook: 'applyFrameMetadata', event: Event): void;\n\n  /**\n   * Fire a hook event before sending an event.\n   * This is called right before an event is sent and should not be used to mutate the event.\n   * Expects to be given an Event & EventHint as the second/third argument.\n   */\n  public emit(hook: 'beforeSendEvent', event: Event, hint?: EventHint): void;\n\n  /**\n   * Fire a hook event before sending a session/aggregates.\n   * Expects to be given the prepared session/aggregates as second argument.\n   */\n  public emit(hook: 'beforeSendSession', session: Session | SessionAggregates): void;\n\n  /**\n   * Fire a hook event to process events before they are passed to (global) event processors.\n   * Expects to be given an Event & EventHint as the second/third argument.\n   */\n  public emit(hook: 'preprocessEvent', event: Event, hint?: EventHint): void;\n\n  /**\n   * Fire a hook event to process a user on an event before it is sent to Sentry, after all other processors have run.\n   * Expects to be given an Event & EventHint as the second/third argument.\n   */\n  public emit(hook: 'postprocessEvent', event: Event, hint?: EventHint): void;\n\n  /*\n   * Fire a hook event after sending an event. Expects to be given an Event as the\n   * second argument.\n   */\n  public emit(hook: 'afterSendEvent', event: Event, sendResponse: TransportMakeRequestResponse): void;\n\n  /**\n   * Fire a hook for when a breadcrumb is added. Expects the breadcrumb as second argument.\n   */\n  public emit(hook: 'beforeAddBreadcrumb', breadcrumb: Breadcrumb, hint?: BreadcrumbHint): void;\n\n  /**\n   * Fire a hook for when a DSC (Dynamic Sampling Context) is created. Expects the DSC as second argument.\n   */\n  public emit(hook: 'createDsc', dsc: DynamicSamplingContext, rootSpan?: Span): void;\n\n  /**\n   * Fire a hook event for after preparing a feedback event. Events to be given\n   * a feedback event as the second argument, and an optional options object as\n   * third argument.\n   */\n  public emit(hook: 'beforeSendFeedback', feedback: FeedbackEvent, options?: { includeReplay?: boolean }): void;\n\n  /**\n   * Fire a hook event for when the feedback widget is opened in a user's browser\n   */\n  public emit(hook: 'openFeedbackWidget'): void;\n\n  /**\n   * Emit a hook event for browser tracing integrations to trigger a span start for a page load.\n   */\n  public emit(\n    hook: 'startPageLoadSpan',\n    options: StartSpanOptions,\n    traceOptions?: { sentryTrace?: string | undefined; baggage?: string | undefined },\n  ): void;\n\n  /**\n   * Emit a hook event for browser tracing integrations to trigger the end of a page load span.\n   */\n  public emit(hook: 'endPageloadSpan'): void;\n\n  /**\n   * Emit a hook event for browser tracing integrations to trigger aafter the pageload span was started.\n   */\n  public emit(hook: 'afterStartPageLoadSpan', span: Span): void;\n\n  /**\n   * Emit a hook event for triggering right before a navigation span is started.\n   */\n  public emit(\n    hook: 'beforeStartNavigationSpan',\n    options: StartSpanOptions,\n    navigationOptions?: { isRedirect?: boolean },\n  ): void;\n\n  /**\n   * Emit a hook event for browser tracing integrations to trigger a span for a navigation.\n   */\n  public emit(\n    hook: 'startNavigationSpan',\n    options: StartSpanOptions,\n    navigationOptions?: { isRedirect?: boolean },\n  ): void;\n\n  /**\n   * Emit a hook event for GraphQL client integration to enhance a span with request data.\n   */\n  public emit(hook: 'beforeOutgoingRequestSpan', span: Span, hint: XhrBreadcrumbHint | FetchBreadcrumbHint): void;\n\n  /**\n   * Emit a hook event for GraphQL client integration to enhance a breadcrumb with request data.\n   */\n  public emit(\n    hook: 'beforeOutgoingRequestBreadcrumb',\n    breadcrumb: Breadcrumb,\n    hint: XhrBreadcrumbHint | FetchBreadcrumbHint,\n  ): void;\n\n  /**\n   * Emit a hook event for client flush\n   */\n  public emit(hook: 'flush'): void;\n\n  /**\n   * Emit a hook event for client close\n   */\n  public emit(hook: 'close'): void;\n\n  /**\n   * Emit a hook event for client before capturing a log. This hooks runs before `beforeSendLog` is fired.\n   */\n  public emit(hook: 'beforeCaptureLog', log: Log): void;\n\n  /**\n   * Emit a hook event for client after capturing a log.\n   */\n  public emit(hook: 'afterCaptureLog', log: Log): void;\n\n  /**\n   * Emit a hook event for client flush logs\n   */\n  public emit(hook: 'flushLogs'): void;\n\n  /**\n   * Emit a hook event for client after capturing a metric.\n   */\n  public emit(hook: 'afterCaptureMetric', metric: Metric): void;\n\n  /**\n   * Emit a hook event for client flush metrics\n   */\n  public emit(hook: 'flushMetrics'): void;\n\n  /**\n   *\n   * Emit a hook event for client to process a metric before it is captured.\n   * This hook is called before the `beforeSendMetric` callback is fired.\n   */\n  public emit(hook: 'processMetric', metric: Metric): void;\n\n  /**\n   * Emit a hook event for client when a http server request is started.\n   * This hook is called after request isolation, but before the request is processed.\n   */\n  public emit(\n    hook: 'httpServerRequest',\n    request: unknown,\n    response: unknown,\n    normalizedRequest: RequestEventData,\n  ): void;\n\n  /**\n   * Emit a hook that was previously registered via `on()`.\n   */\n  public emit(hook: string, ...rest: unknown[]): void {\n    const callbacks = this._hooks[hook];\n    if (callbacks) {\n      callbacks.forEach(callback => callback(...rest));\n    }\n  }\n\n  /**\n   * Send an envelope to Sentry.\n   */\n  // @ts-expect-error - PromiseLike is a subset of Promise\n  public async sendEnvelope(envelope: Envelope): PromiseLike<TransportMakeRequestResponse> {\n    this.emit('beforeEnvelope', envelope);\n\n    if (this._isEnabled() && this._transport) {\n      try {\n        return await this._transport.send(envelope);\n      } catch (reason) {\n        DEBUG_BUILD && debug.error('Error while sending envelope:', reason);\n        return {};\n      }\n    }\n\n    DEBUG_BUILD && debug.error('Transport disabled');\n    return {};\n  }\n\n  /* eslint-enable @typescript-eslint/unified-signatures */\n\n  /** Setup integrations for this client. */\n  protected _setupIntegrations(): void {\n    const { integrations } = this._options;\n    this._integrations = setupIntegrations(this, integrations);\n    afterSetupIntegrations(this, integrations);\n  }\n\n  /** Updates existing session based on the provided event */\n  protected _updateSessionFromEvent(session: Session, event: Event): void {\n    // initially, set `crashed` based on the event level and update from exceptions if there are any later on\n    let crashed = event.level === 'fatal';\n    let errored = false;\n    const exceptions = event.exception?.values;\n\n    if (exceptions) {\n      errored = true;\n      // reset crashed to false if there are exceptions, to ensure `mechanism.handled` is respected.\n      crashed = false;\n\n      for (const ex of exceptions) {\n        if (ex.mechanism?.handled === false) {\n          crashed = true;\n          break;\n        }\n      }\n    }\n\n    // A session is updated and that session update is sent in only one of the two following scenarios:\n    // 1. Session with non terminal status and 0 errors + an error occurred -> Will set error count to 1 and send update\n    // 2. Session with non terminal status and 1 error + a crash occurred -> Will set status crashed and send update\n    const sessionNonTerminal = session.status === 'ok';\n    const shouldUpdateAndSend = (sessionNonTerminal && session.errors === 0) || (sessionNonTerminal && crashed);\n\n    if (shouldUpdateAndSend) {\n      updateSession(session, {\n        ...(crashed && { status: 'crashed' }),\n        errors: session.errors || Number(errored || crashed),\n      });\n      this.captureSession(session);\n    }\n  }\n\n  /**\n   * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying\n   * \"no\" (resolving to `false`) in order to give the client a chance to potentially finish first.\n   *\n   * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not\n   * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to\n   * `true`.\n   * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and\n   * `false` otherwise\n   */\n  protected async _isClientDoneProcessing(timeout?: number): Promise<boolean> {\n    let ticked = 0;\n\n    // if no timeout is provided, we wait \"forever\" until everything is processed\n    while (!timeout || ticked < timeout) {\n      await new Promise(resolve => setTimeout(resolve, 1));\n\n      if (!this._numProcessing) {\n        return true;\n      }\n      ticked++;\n    }\n\n    return false;\n  }\n\n  /** Determines whether this SDK is enabled and a transport is present. */\n  protected _isEnabled(): boolean {\n    return this.getOptions().enabled !== false && this._transport !== undefined;\n  }\n\n  /**\n   * Adds common information to events.\n   *\n   * The information includes release and environment from `options`,\n   * breadcrumbs and context (extra, tags and user) from the scope.\n   *\n   * Information that is already present in the event is never overwritten. For\n   * nested objects, such as the context, keys are merged.\n   *\n   * @param event The original event.\n   * @param hint May contain additional information about the original exception.\n   * @param currentScope A scope containing event metadata.\n   * @returns A new event with more information.\n   */\n  protected _prepareEvent(\n    event: Event,\n    hint: EventHint,\n    currentScope: Scope,\n    isolationScope: Scope,\n  ): PromiseLike<Event | null> {\n    const options = this.getOptions();\n    const integrations = Object.keys(this._integrations);\n    if (!hint.integrations && integrations?.length) {\n      hint.integrations = integrations;\n    }\n\n    this.emit('preprocessEvent', event, hint);\n\n    if (!event.type) {\n      isolationScope.setLastEventId(event.event_id || hint.event_id);\n    }\n\n    return prepareEvent(options, event, hint, currentScope, this, isolationScope).then(evt => {\n      if (evt === null) {\n        return evt;\n      }\n\n      this.emit('postprocessEvent', evt, hint);\n\n      evt.contexts = {\n        trace: getTraceContextFromScope(currentScope),\n        ...evt.contexts,\n      };\n\n      const dynamicSamplingContext = getDynamicSamplingContextFromScope(this, currentScope);\n\n      evt.sdkProcessingMetadata = {\n        dynamicSamplingContext,\n        ...evt.sdkProcessingMetadata,\n      };\n\n      return evt;\n    });\n  }\n\n  /**\n   * Processes the event and logs an error in case of rejection\n   * @param event\n   * @param hint\n   * @param scope\n   */\n  protected _captureEvent(\n    event: Event,\n    hint: EventHint = {},\n    currentScope = getCurrentScope(),\n    isolationScope = getIsolationScope(),\n  ): PromiseLike<string | undefined> {\n    if (DEBUG_BUILD && isErrorEvent(event)) {\n      debug.log(`Captured error event \\`${getPossibleEventMessages(event)[0] || '<unknown>'}\\``);\n    }\n\n    return this._processEvent(event, hint, currentScope, isolationScope).then(\n      finalEvent => {\n        return finalEvent.event_id;\n      },\n      reason => {\n        if (DEBUG_BUILD) {\n          if (_isDoNotSendEventError(reason)) {\n            debug.log(reason.message);\n          } else if (_isInternalError(reason)) {\n            debug.warn(reason.message);\n          } else {\n            debug.warn(reason);\n          }\n        }\n        return undefined;\n      },\n    );\n  }\n\n  /**\n   * Processes an event (either error or message) and sends it to Sentry.\n   *\n   * This also adds breadcrumbs and context information to the event. However,\n   * platform specific meta data (such as the User's IP address) must be added\n   * by the SDK implementor.\n   *\n   *\n   * @param event The event to send to Sentry.\n   * @param hint May contain additional information about the original exception.\n   * @param currentScope A scope containing event metadata.\n   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.\n   */\n  protected _processEvent(\n    event: Event,\n    hint: EventHint,\n    currentScope: Scope,\n    isolationScope: Scope,\n  ): PromiseLike<Event> {\n    const options = this.getOptions();\n    const { sampleRate } = options;\n\n    const isTransaction = isTransactionEvent(event);\n    const isError = isErrorEvent(event);\n    const eventType = event.type || 'error';\n    const beforeSendLabel = `before send for type \\`${eventType}\\``;\n\n    // 1.0 === 100% events are sent\n    // 0.0 === 0% events are sent\n    // Sampling for transaction happens somewhere else\n    const parsedSampleRate = typeof sampleRate === 'undefined' ? undefined : parseSampleRate(sampleRate);\n    if (isError && typeof parsedSampleRate === 'number' && Math.random() > parsedSampleRate) {\n      this.recordDroppedEvent('sample_rate', 'error');\n      return rejectedSyncPromise(\n        _makeDoNotSendEventError(\n          `Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`,\n        ),\n      );\n    }\n\n    const dataCategory = (eventType === 'replay_event' ? 'replay' : eventType) satisfies DataCategory;\n\n    return this._prepareEvent(event, hint, currentScope, isolationScope)\n      .then(prepared => {\n        if (prepared === null) {\n          this.recordDroppedEvent('event_processor', dataCategory);\n          throw _makeDoNotSendEventError('An event processor returned `null`, will not send event.');\n        }\n\n        const isInternalException = hint.data && (hint.data as { __sentry__: boolean }).__sentry__ === true;\n        if (isInternalException) {\n          return prepared;\n        }\n\n        const result = processBeforeSend(this, options, prepared, hint);\n        return _validateBeforeSendResult(result, beforeSendLabel);\n      })\n      .then(processedEvent => {\n        if (processedEvent === null) {\n          this.recordDroppedEvent('before_send', dataCategory);\n          if (isTransaction) {\n            const spans = event.spans || [];\n            // the transaction itself counts as one span, plus all the child spans that are added\n            const spanCount = 1 + spans.length;\n            this.recordDroppedEvent('before_send', 'span', spanCount);\n          }\n          throw _makeDoNotSendEventError(`${beforeSendLabel} returned \\`null\\`, will not send event.`);\n        }\n\n        const session = currentScope.getSession() || isolationScope.getSession();\n        if (isError && session) {\n          this._updateSessionFromEvent(session, processedEvent);\n        }\n\n        if (isTransaction) {\n          const spanCountBefore = processedEvent.sdkProcessingMetadata?.spanCountBeforeProcessing || 0;\n          const spanCountAfter = processedEvent.spans ? processedEvent.spans.length : 0;\n\n          const droppedSpanCount = spanCountBefore - spanCountAfter;\n          if (droppedSpanCount > 0) {\n            this.recordDroppedEvent('before_send', 'span', droppedSpanCount);\n          }\n        }\n\n        // None of the Sentry built event processor will update transaction name,\n        // so if the transaction name has been changed by an event processor, we know\n        // it has to come from custom event processor added by a user\n        const transactionInfo = processedEvent.transaction_info;\n        if (isTransaction && transactionInfo && processedEvent.transaction !== event.transaction) {\n          const source = 'custom';\n          processedEvent.transaction_info = {\n            ...transactionInfo,\n            source,\n          };\n        }\n\n        this.sendEvent(processedEvent, hint);\n        return processedEvent;\n      })\n      .then(null, reason => {\n        if (_isDoNotSendEventError(reason) || _isInternalError(reason)) {\n          throw reason;\n        }\n\n        this.captureException(reason, {\n          mechanism: {\n            handled: false,\n            type: 'internal',\n          },\n          data: {\n            __sentry__: true,\n          },\n          originalException: reason,\n        });\n        throw _makeInternalError(\n          `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\\nReason: ${reason}`,\n        );\n      });\n  }\n\n  /**\n   * Occupies the client with processing and event\n   */\n  protected _process<T>(promise: PromiseLike<T>): void {\n    this._numProcessing++;\n    void promise.then(\n      value => {\n        this._numProcessing--;\n        return value;\n      },\n      reason => {\n        this._numProcessing--;\n        return reason;\n      },\n    );\n  }\n\n  /**\n   * Clears outcomes on this client and returns them.\n   */\n  protected _clearOutcomes(): Outcome[] {\n    const outcomes = this._outcomes;\n    this._outcomes = {};\n    return Object.entries(outcomes).map(([key, quantity]) => {\n      const [reason, category] = key.split(':') as [EventDropReason, DataCategory];\n      return {\n        reason,\n        category,\n        quantity,\n      };\n    });\n  }\n\n  /**\n   * Sends client reports as an envelope.\n   */\n  protected _flushOutcomes(): void {\n    DEBUG_BUILD && debug.log('Flushing outcomes...');\n\n    const outcomes = this._clearOutcomes();\n\n    if (outcomes.length === 0) {\n      DEBUG_BUILD && debug.log('No outcomes to send');\n      return;\n    }\n\n    // This is really the only place where we want to check for a DSN and only send outcomes then\n    if (!this._dsn) {\n      DEBUG_BUILD && debug.log('No dsn provided, will not send outcomes');\n      return;\n    }\n\n    DEBUG_BUILD && debug.log('Sending outcomes:', outcomes);\n\n    const envelope = createClientReportEnvelope(outcomes, this._options.tunnel && dsnToString(this._dsn));\n\n    // sendEnvelope should not throw\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.sendEnvelope(envelope);\n  }\n\n  /**\n   * Creates an {@link Event} from all inputs to `captureException` and non-primitive inputs to `captureMessage`.\n   */\n  public abstract eventFromException(_exception: unknown, _hint?: EventHint): PromiseLike<Event>;\n\n  /**\n   * Creates an {@link Event} from primitive inputs to `captureMessage`.\n   */\n  public abstract eventFromMessage(\n    _message: ParameterizedString,\n    _level?: SeverityLevel,\n    _hint?: EventHint,\n  ): PromiseLike<Event>;\n}\n\n/**\n * Verifies that return value of configured `beforeSend` or `beforeSendTransaction` is of expected type, and returns the value if so.\n */\nfunction _validateBeforeSendResult(\n  beforeSendResult: PromiseLike<Event | null> | Event | null,\n  beforeSendLabel: string,\n): PromiseLike<Event | null> | Event | null {\n  const invalidValueError = `${beforeSendLabel} must return \\`null\\` or a valid event.`;\n  if (isThenable(beforeSendResult)) {\n    return beforeSendResult.then(\n      event => {\n        if (!isPlainObject(event) && event !== null) {\n          throw _makeInternalError(invalidValueError);\n        }\n        return event;\n      },\n      e => {\n        throw _makeInternalError(`${beforeSendLabel} rejected with ${e}`);\n      },\n    );\n  } else if (!isPlainObject(beforeSendResult) && beforeSendResult !== null) {\n    throw _makeInternalError(invalidValueError);\n  }\n  return beforeSendResult;\n}\n\n/**\n * Process the matching `beforeSendXXX` callback.\n */\nfunction processBeforeSend(\n  client: Client,\n  options: ClientOptions,\n  event: Event,\n  hint: EventHint,\n): PromiseLike<Event | null> | Event | null {\n  const { beforeSend, beforeSendTransaction, beforeSendSpan, ignoreSpans } = options;\n  let processedEvent = event;\n\n  if (isErrorEvent(processedEvent) && beforeSend) {\n    return beforeSend(processedEvent, hint);\n  }\n\n  if (isTransactionEvent(processedEvent)) {\n    // Avoid processing if we don't have to\n    if (beforeSendSpan || ignoreSpans) {\n      // 1. Process root span\n      const rootSpanJson = convertTransactionEventToSpanJson(processedEvent);\n\n      // 1.1 If the root span should be ignored, drop the whole transaction\n      if (ignoreSpans?.length && shouldIgnoreSpan(rootSpanJson, ignoreSpans)) {\n        // dropping the whole transaction!\n        return null;\n      }\n\n      // 1.2 If a `beforeSendSpan` callback is defined, process the root span\n      if (beforeSendSpan) {\n        const processedRootSpanJson = beforeSendSpan(rootSpanJson);\n        if (!processedRootSpanJson) {\n          showSpanDropWarning();\n        } else {\n          // update event with processed root span values\n          processedEvent = merge(event, convertSpanJsonToTransactionEvent(processedRootSpanJson));\n        }\n      }\n\n      // 2. Process child spans\n      if (processedEvent.spans) {\n        const processedSpans: SpanJSON[] = [];\n\n        const initialSpans = processedEvent.spans;\n\n        for (const span of initialSpans) {\n          // 2.a If the child span should be ignored, reparent it to the root span\n          if (ignoreSpans?.length && shouldIgnoreSpan(span, ignoreSpans)) {\n            reparentChildSpans(initialSpans, span);\n            continue;\n          }\n\n          // 2.b If a `beforeSendSpan` callback is defined, process the child span\n          if (beforeSendSpan) {\n            const processedSpan = beforeSendSpan(span);\n            if (!processedSpan) {\n              showSpanDropWarning();\n              processedSpans.push(span);\n            } else {\n              processedSpans.push(processedSpan);\n            }\n          } else {\n            processedSpans.push(span);\n          }\n        }\n\n        const droppedSpans = processedEvent.spans.length - processedSpans.length;\n        if (droppedSpans) {\n          client.recordDroppedEvent('before_send', 'span', droppedSpans);\n        }\n\n        processedEvent.spans = processedSpans;\n      }\n    }\n\n    if (beforeSendTransaction) {\n      if (processedEvent.spans) {\n        // We store the # of spans before processing in SDK metadata,\n        // so we can compare it afterwards to determine how many spans were dropped\n        const spanCountBefore = processedEvent.spans.length;\n        processedEvent.sdkProcessingMetadata = {\n          ...event.sdkProcessingMetadata,\n          spanCountBeforeProcessing: spanCountBefore,\n        };\n      }\n      return beforeSendTransaction(processedEvent as TransactionEvent, hint);\n    }\n  }\n\n  return processedEvent;\n}\n\nfunction isErrorEvent(event: Event): event is ErrorEvent {\n  return event.type === undefined;\n}\n\nfunction isTransactionEvent(event: Event): event is TransactionEvent {\n  return event.type === 'transaction';\n}\n\n/**\n * Estimate the size of a metric in bytes.\n *\n * @param metric - The metric to estimate the size of.\n * @returns The estimated size of the metric in bytes.\n */\nfunction estimateMetricSizeInBytes(metric: Metric): number {\n  let weight = 0;\n\n  // Estimate byte size of 2 bytes per character. This is a rough estimate JS strings are stored as UTF-16.\n  if (metric.name) {\n    weight += metric.name.length * 2;\n  }\n\n  // Add weight for number\n  weight += 8;\n\n  return weight + estimateAttributesSizeInBytes(metric.attributes);\n}\n\n/**\n * Estimate the size of a log in bytes.\n *\n * @param log - The log to estimate the size of.\n * @returns The estimated size of the log in bytes.\n */\nfunction estimateLogSizeInBytes(log: Log): number {\n  let weight = 0;\n\n  // Estimate byte size of 2 bytes per character. This is a rough estimate JS strings are stored as UTF-16.\n  if (log.message) {\n    weight += log.message.length * 2;\n  }\n\n  return weight + estimateAttributesSizeInBytes(log.attributes);\n}\n\n/**\n * Estimate the size of attributes in bytes.\n *\n * @param attributes - The attributes object to estimate the size of.\n * @returns The estimated size of the attributes in bytes.\n */\nfunction estimateAttributesSizeInBytes(attributes: Record<string, unknown> | undefined): number {\n  if (!attributes) {\n    return 0;\n  }\n\n  let weight = 0;\n\n  Object.values(attributes).forEach(value => {\n    if (Array.isArray(value)) {\n      weight += value.length * estimatePrimitiveSizeInBytes(value[0]);\n    } else if (isPrimitive(value)) {\n      weight += estimatePrimitiveSizeInBytes(value);\n    } else {\n      // For objects values, we estimate the size of the object as 100 bytes\n      weight += 100;\n    }\n  });\n\n  return weight;\n}\n\nfunction estimatePrimitiveSizeInBytes(value: Primitive): number {\n  if (typeof value === 'string') {\n    return value.length * 2;\n  } else if (typeof value === 'number') {\n    return 8;\n  } else if (typeof value === 'boolean') {\n    return 4;\n  }\n\n  return 0;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 4239, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/server-runtime-client.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/server-runtime-client.ts"],"sourcesContent":["import { createCheckInEnvelope } from './checkin';\nimport { Client } from './client';\nimport { getIsolationScope } from './currentScopes';\nimport { DEBUG_BUILD } from './debug-build';\nimport type { Scope } from './scope';\nimport { registerSpanErrorInstrumentation } from './tracing';\nimport { addUserAgentToTransportHeaders } from './transports/userAgent';\nimport type { CheckIn, MonitorConfig, SerializedCheckIn } from './types-hoist/checkin';\nimport type { Event, EventHint } from './types-hoist/event';\nimport type { ClientOptions } from './types-hoist/options';\nimport type { ParameterizedString } from './types-hoist/parameterize';\nimport type { SeverityLevel } from './types-hoist/severity';\nimport type { BaseTransportOptions } from './types-hoist/transport';\nimport { debug } from './utils/debug-logger';\nimport { eventFromMessage, eventFromUnknownInput } from './utils/eventbuilder';\nimport { uuid4 } from './utils/misc';\nimport { resolvedSyncPromise } from './utils/syncpromise';\nimport { _getTraceInfoFromScope } from './utils/trace-info';\n\nexport interface ServerRuntimeClientOptions extends ClientOptions<BaseTransportOptions> {\n  platform?: string;\n  runtime?: { name: string; version?: string };\n  serverName?: string;\n}\n\n/**\n * The Sentry Server Runtime Client SDK.\n */\nexport class ServerRuntimeClient<\n  O extends ClientOptions & ServerRuntimeClientOptions = ServerRuntimeClientOptions,\n> extends Client<O> {\n  /**\n   * Creates a new Edge SDK instance.\n   * @param options Configuration options for this SDK.\n   */\n  public constructor(options: O) {\n    // Server clients always support tracing\n    registerSpanErrorInstrumentation();\n\n    addUserAgentToTransportHeaders(options);\n\n    super(options);\n\n    this._setUpMetricsProcessing();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public eventFromException(exception: unknown, hint?: EventHint): PromiseLike<Event> {\n    const event = eventFromUnknownInput(this, this._options.stackParser, exception, hint);\n    event.level = 'error';\n\n    return resolvedSyncPromise(event);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public eventFromMessage(\n    message: ParameterizedString,\n    level: SeverityLevel = 'info',\n    hint?: EventHint,\n  ): PromiseLike<Event> {\n    return resolvedSyncPromise(\n      eventFromMessage(this._options.stackParser, message, level, hint, this._options.attachStacktrace),\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureException(exception: unknown, hint?: EventHint, scope?: Scope): string {\n    setCurrentRequestSessionErroredOrCrashed(hint);\n    return super.captureException(exception, hint, scope);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureEvent(event: Event, hint?: EventHint, scope?: Scope): string {\n    // If the event is of type Exception, then a request session should be captured\n    const isException = !event.type && event.exception?.values && event.exception.values.length > 0;\n    if (isException) {\n      setCurrentRequestSessionErroredOrCrashed(hint);\n    }\n\n    return super.captureEvent(event, hint, scope);\n  }\n\n  /**\n   * Create a cron monitor check in and send it to Sentry.\n   *\n   * @param checkIn An object that describes a check in.\n   * @param upsertMonitorConfig An optional object that describes a monitor config. Use this if you want\n   * to create a monitor automatically when sending a check in.\n   */\n  public captureCheckIn(checkIn: CheckIn, monitorConfig?: MonitorConfig, scope?: Scope): string {\n    const id = 'checkInId' in checkIn && checkIn.checkInId ? checkIn.checkInId : uuid4();\n    if (!this._isEnabled()) {\n      DEBUG_BUILD && debug.warn('SDK not enabled, will not capture check-in.');\n      return id;\n    }\n\n    const options = this.getOptions();\n    const { release, environment, tunnel } = options;\n\n    const serializedCheckIn: SerializedCheckIn = {\n      check_in_id: id,\n      monitor_slug: checkIn.monitorSlug,\n      status: checkIn.status,\n      release,\n      environment,\n    };\n\n    if ('duration' in checkIn) {\n      serializedCheckIn.duration = checkIn.duration;\n    }\n\n    if (monitorConfig) {\n      serializedCheckIn.monitor_config = {\n        schedule: monitorConfig.schedule,\n        checkin_margin: monitorConfig.checkinMargin,\n        max_runtime: monitorConfig.maxRuntime,\n        timezone: monitorConfig.timezone,\n        failure_issue_threshold: monitorConfig.failureIssueThreshold,\n        recovery_threshold: monitorConfig.recoveryThreshold,\n      };\n    }\n\n    const [dynamicSamplingContext, traceContext] = _getTraceInfoFromScope(this, scope);\n    if (traceContext) {\n      serializedCheckIn.contexts = {\n        trace: traceContext,\n      };\n    }\n\n    const envelope = createCheckInEnvelope(\n      serializedCheckIn,\n      dynamicSamplingContext,\n      this.getSdkMetadata(),\n      tunnel,\n      this.getDsn(),\n    );\n\n    DEBUG_BUILD && debug.log('Sending checkin:', checkIn.monitorSlug, checkIn.status);\n\n    // sendEnvelope should not throw\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.sendEnvelope(envelope);\n\n    return id;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  protected _prepareEvent(\n    event: Event,\n    hint: EventHint,\n    currentScope: Scope,\n    isolationScope: Scope,\n  ): PromiseLike<Event | null> {\n    if (this._options.platform) {\n      event.platform = event.platform || this._options.platform;\n    }\n\n    if (this._options.runtime) {\n      event.contexts = {\n        ...event.contexts,\n        runtime: event.contexts?.runtime || this._options.runtime,\n      };\n    }\n\n    if (this._options.serverName) {\n      event.server_name = event.server_name || this._options.serverName;\n    }\n\n    return super._prepareEvent(event, hint, currentScope, isolationScope);\n  }\n\n  /**\n   * Process a server-side metric before it is captured.\n   */\n  private _setUpMetricsProcessing(): void {\n    this.on('processMetric', metric => {\n      if (this._options.serverName) {\n        metric.attributes = {\n          'server.address': this._options.serverName,\n          ...metric.attributes,\n        };\n      }\n    });\n  }\n}\n\nfunction setCurrentRequestSessionErroredOrCrashed(eventHint?: EventHint): void {\n  const requestSession = getIsolationScope().getScopeData().sdkProcessingMetadata.requestSession;\n  if (requestSession) {\n    // We mutate instead of doing `setSdkProcessingMetadata` because the http integration stores away a particular\n    // isolationScope. If that isolation scope is forked, setting the processing metadata here will not mutate the\n    // original isolation scope that the http integration stored away.\n    const isHandledException = eventHint?.mechanism?.handled ?? true;\n    // A request session can go from \"errored\" -> \"crashed\" but not \"crashed\" -> \"errored\".\n    // Crashed (unhandled exception) is worse than errored (handled exception).\n    if (isHandledException && requestSession.status !== 'crashed') {\n      requestSession.status = 'errored';\n    } else if (!isHandledException) {\n      requestSession.status = 'crashed';\n    }\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA;;CAEA,GACO,MAAM,4BAEH,sOAAM,CAAI;IACpB;;;GAGA,GACS,WAAW,CAAC,OAAO,CAAK;QACjC,wCAAA;YACI,2QAAgC,EAAE;YAElC,+QAA8B,EAAC,OAAO,CAAC;QAEvC,KAAK,CAAC,OAAO,CAAC;QAEd,IAAI,CAAC,uBAAuB,EAAE;IAChC;IAEF;;GAEA,GACS,kBAAkB,CAAC,SAAS,EAAW,IAAI,EAAkC;QAClF,MAAM,KAAA,OAAQ,oQAAqB,EAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,WAAW,EAAE,SAAS,EAAE,IAAI,CAAC;QACrF,KAAK,CAAC,KAAA,GAAQ,OAAO;QAErB,WAAO,iQAAmB,EAAC,KAAK,CAAC;IACnC;IAEF;;GAEA,GACS,gBAAgB,CACrB,OAAO,EACP,KAAK,GAAkB,MAAM,EAC7B,IAAI,EACgB;QACpB,WAAO,iQAAmB,MACxB,+PAAgB,EAAC,IAAI,CAAC,QAAQ,CAAC,WAAW,EAAE,OAAO,EAAE,KAAK,EAAE,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,gBAAgB,CAAC;IAErG;IAEF;;GAEA,GACS,gBAAgB,CAAC,SAAS,EAAW,IAAI,EAAc,KAAK,EAAkB;QACnF,wCAAwC,CAAC,IAAI,CAAC;QAC9C,OAAO,KAAK,CAAC,gBAAgB,CAAC,SAAS,EAAE,IAAI,EAAE,KAAK,CAAC;IACvD;IAEF;;GAEA,GACS,YAAY,CAAC,KAAK,EAAS,IAAI,EAAc,KAAK,EAAkB;QAC7E,+EAAA;QACI,MAAM,cAAc,CAAC,KAAK,CAAC,IAAA,IAAQ,KAAK,CAAC,SAAS,EAAE,MAAA,IAAU,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,MAAA,GAAS,CAAC;QAC/F,IAAI,WAAW,EAAE;YACf,wCAAwC,CAAC,IAAI,CAAC;QAChD;QAEA,OAAO,KAAK,CAAC,YAAY,CAAC,KAAK,EAAE,IAAI,EAAE,KAAK,CAAC;IAC/C;IAEF;;;;;;GAMA,GACS,cAAc,CAAC,OAAO,EAAW,aAAa,EAAkB,KAAK,EAAkB;QAC5F,MAAM,EAAA,GAAK,WAAA,IAAe,WAAW,OAAO,CAAC,SAAA,GAAY,OAAO,CAAC,SAAA,OAAY,4OAAK,EAAE;QACpF,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,EAAE;YACtB,mPAAA,IAAe,uPAAK,CAAC,IAAI,CAAC,6CAA6C,CAAC;YACxE,OAAO,EAAE;QACX;QAEA,MAAM,OAAA,GAAU,IAAI,CAAC,UAAU,EAAE;QACjC,MAAM,EAAE,OAAO,EAAE,WAAW,EAAE,MAAA,EAAO,GAAI,OAAO;QAEhD,MAAM,iBAAiB,GAAsB;YAC3C,WAAW,EAAE,EAAE;YACf,YAAY,EAAE,OAAO,CAAC,WAAW;YACjC,MAAM,EAAE,OAAO,CAAC,MAAM;YACtB,OAAO;YACP,WAAW;QACjB,CAAK;QAED,IAAI,UAAA,IAAc,OAAO,EAAE;YACzB,iBAAiB,CAAC,QAAA,GAAW,OAAO,CAAC,QAAQ;QAC/C;QAEA,IAAI,aAAa,EAAE;YACjB,iBAAiB,CAAC,cAAA,GAAiB;gBACjC,QAAQ,EAAE,aAAa,CAAC,QAAQ;gBAChC,cAAc,EAAE,aAAa,CAAC,aAAa;gBAC3C,WAAW,EAAE,aAAa,CAAC,UAAU;gBACrC,QAAQ,EAAE,aAAa,CAAC,QAAQ;gBAChC,uBAAuB,EAAE,aAAa,CAAC,qBAAqB;gBAC5D,kBAAkB,EAAE,aAAa,CAAC,iBAAiB;YAC3D,CAAO;QACH;QAEA,MAAM,CAAC,sBAAsB,EAAE,YAAY,CAAA,OAAI,sQAAsB,EAAC,IAAI,EAAE,KAAK,CAAC;QAClF,IAAI,YAAY,EAAE;YAChB,iBAAiB,CAAC,QAAA,GAAW;gBAC3B,KAAK,EAAE,YAAY;YAC3B,CAAO;QACH;QAEA,MAAM,QAAA,OAAW,sPAAqB,EACpC,iBAAiB,EACjB,sBAAsB,EACtB,IAAI,CAAC,cAAc,EAAE,EACrB,MAAM,EACN,IAAI,CAAC,MAAM,EAAE;QAGf,mPAAA,IAAe,uPAAK,CAAC,GAAG,CAAC,kBAAkB,EAAE,OAAO,CAAC,WAAW,EAAE,OAAO,CAAC,MAAM,CAAC;QAErF,gCAAA;QACA,mEAAA;QACI,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC;QAE3B,OAAO,EAAE;IACX;IAEF;;GAEA,GACY,aAAa,CACrB,KAAK,EACL,IAAI,EACJ,YAAY,EACZ,cAAc,EACa;QAC3B,IAAI,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAE;YAC1B,KAAK,CAAC,QAAA,GAAW,KAAK,CAAC,QAAA,IAAY,IAAI,CAAC,QAAQ,CAAC,QAAQ;QAC3D;QAEA,IAAI,IAAI,CAAC,QAAQ,CAAC,OAAO,EAAE;YACzB,KAAK,CAAC,QAAA,GAAW;gBACf,GAAG,KAAK,CAAC,QAAQ;gBACjB,OAAO,EAAE,KAAK,CAAC,QAAQ,EAAE,OAAA,IAAW,IAAI,CAAC,QAAQ,CAAC,OAAO;YACjE,CAAO;QACH;QAEA,IAAI,IAAI,CAAC,QAAQ,CAAC,UAAU,EAAE;YAC5B,KAAK,CAAC,WAAA,GAAc,KAAK,CAAC,WAAA,IAAe,IAAI,CAAC,QAAQ,CAAC,UAAU;QACnE;QAEA,OAAO,KAAK,CAAC,aAAa,CAAC,KAAK,EAAE,IAAI,EAAE,YAAY,EAAE,cAAc,CAAC;IACvE;IAEF;;GAEA,GACU,uBAAuB,GAAS;QACtC,IAAI,CAAC,EAAE,CAAC,eAAe,GAAE,UAAU;YACjC,IAAI,IAAI,CAAC,QAAQ,CAAC,UAAU,EAAE;gBAC5B,MAAM,CAAC,UAAA,GAAa;oBAClB,gBAAgB,EAAE,IAAI,CAAC,QAAQ,CAAC,UAAU;oBAC1C,GAAG,MAAM,CAAC,UAAU;gBAC9B,CAAS;YACH;QACF,CAAC,CAAC;IACJ;AACF;AAEA,SAAS,wCAAwC,CAAC,SAAS,EAAoB;IAC7E,MAAM,cAAA,OAAiB,wPAAiB,EAAE,EAAC,YAAY,EAAE,CAAC,qBAAqB,CAAC,cAAc;IAC9F,IAAI,cAAc,EAAE;QACtB,8GAAA;QACA,8GAAA;QACA,kEAAA;QACI,MAAM,qBAAqB,SAAS,EAAE,SAAS,EAAE,OAAA,IAAW,IAAI;QACpE,uFAAA;QACA,2EAAA;QACI,IAAI,kBAAA,IAAsB,cAAc,CAAC,MAAA,KAAW,SAAS,EAAE;YAC7D,cAAc,CAAC,MAAA,GAAS,SAAS;QACnC,OAAO,IAAI,CAAC,kBAAkB,EAAE;YAC9B,cAAc,CAAC,MAAA,GAAS,SAAS;QACnC;IACF;AACF"}},
    {"offset": {"line": 4405, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/feedback.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/feedback.ts"],"sourcesContent":["import { getClient, getCurrentScope } from './currentScopes';\nimport type { EventHint } from './types-hoist/event';\nimport type { FeedbackEvent, SendFeedbackParams } from './types-hoist/feedback';\n\n/**\n * Send user feedback to Sentry.\n */\nexport function captureFeedback(\n  params: SendFeedbackParams,\n  hint: EventHint & { includeReplay?: boolean } = {},\n  scope = getCurrentScope(),\n): string {\n  const { message, name, email, url, source, associatedEventId, tags } = params;\n\n  const feedbackEvent: FeedbackEvent = {\n    contexts: {\n      feedback: {\n        contact_email: email,\n        name,\n        message,\n        url,\n        source,\n        associated_event_id: associatedEventId,\n      },\n    },\n    type: 'feedback',\n    level: 'info',\n    tags,\n  };\n\n  const client = scope?.getClient() || getClient();\n\n  if (client) {\n    client.emit('beforeSendFeedback', feedbackEvent, hint);\n  }\n\n  const eventId = scope.captureEvent(feedbackEvent, hint);\n\n  return eventId;\n}\n"],"names":[],"mappings":";;;;;;AAIA;;CAEA,GACO,SAAS,eAAe,CAC7B,MAAM,EACN,IAAI,GAA4C,CAAA,CAAE,EAClD,KAAA,OAAQ,sPAAe,GAAE;IAEzB,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,EAAE,MAAM,EAAE,iBAAiB,EAAE,IAAA,EAAK,GAAI,MAAM;IAE7E,MAAM,aAAa,GAAkB;QACnC,QAAQ,EAAE;YACR,QAAQ,EAAE;gBACR,aAAa,EAAE,KAAK;gBACpB,IAAI;gBACJ,OAAO;gBACP,GAAG;gBACH,MAAM;gBACN,mBAAmB,EAAE,iBAAiB;YAC9C,CAAO;QACP,CAAK;QACD,IAAI,EAAE,UAAU;QAChB,KAAK,EAAE,MAAM;QACb,IAAI;IACR,CAAG;IAED,MAAM,MAAA,GAAS,KAAK,EAAE,SAAS,EAAC,QAAK,gPAAS,EAAE;IAEhD,IAAI,MAAM,EAAE;QACV,MAAM,CAAC,IAAI,CAAC,oBAAoB,EAAE,aAAa,EAAE,IAAI,CAAC;IACxD;IAEA,MAAM,OAAA,GAAU,KAAK,CAAC,YAAY,CAAC,aAAa,EAAE,IAAI,CAAC;IAEvD,OAAO,OAAO;AAChB"}},
    {"offset": {"line": 4443, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/profiling.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/profiling.ts"],"sourcesContent":["import { getClient } from './currentScopes';\nimport { DEBUG_BUILD } from './debug-build';\nimport type { Profiler, ProfilingIntegration } from './types-hoist/profiling';\nimport { debug } from './utils/debug-logger';\n\nfunction isProfilingIntegrationWithProfiler(\n  integration: ProfilingIntegration | undefined,\n): integration is ProfilingIntegration {\n  return (\n    !!integration &&\n    typeof integration['_profiler'] !== 'undefined' &&\n    typeof integration['_profiler']['start'] === 'function' &&\n    typeof integration['_profiler']['stop'] === 'function'\n  );\n}\n/**\n * Starts the Sentry continuous profiler.\n * This mode is exclusive with the transaction profiler and will only work if the profilesSampleRate is set to a falsy value.\n * In continuous profiling mode, the profiler will keep reporting profile chunks to Sentry until it is stopped, which allows for continuous profiling of the application.\n */\nfunction startProfiler(): void {\n  const client = getClient();\n  if (!client) {\n    DEBUG_BUILD && debug.warn('No Sentry client available, profiling is not started');\n    return;\n  }\n\n  const integration = client.getIntegrationByName<ProfilingIntegration>('ProfilingIntegration');\n\n  if (!integration) {\n    DEBUG_BUILD && debug.warn('ProfilingIntegration is not available');\n    return;\n  }\n\n  if (!isProfilingIntegrationWithProfiler(integration)) {\n    DEBUG_BUILD && debug.warn('Profiler is not available on profiling integration.');\n    return;\n  }\n\n  integration._profiler.start();\n}\n\n/**\n * Stops the Sentry continuous profiler.\n * Calls to stop will stop the profiler and flush the currently collected profile data to Sentry.\n */\nfunction stopProfiler(): void {\n  const client = getClient();\n  if (!client) {\n    DEBUG_BUILD && debug.warn('No Sentry client available, profiling is not started');\n    return;\n  }\n\n  const integration = client.getIntegrationByName<ProfilingIntegration>('ProfilingIntegration');\n  if (!integration) {\n    DEBUG_BUILD && debug.warn('ProfilingIntegration is not available');\n    return;\n  }\n\n  if (!isProfilingIntegrationWithProfiler(integration)) {\n    DEBUG_BUILD && debug.warn('Profiler is not available on profiling integration.');\n    return;\n  }\n\n  integration._profiler.stop();\n}\n\nexport const profiler: Profiler = {\n  startProfiler,\n  stopProfiler,\n};\n"],"names":[],"mappings":";;;;;;;;;;AAKA,SAAS,kCAAkC,CACzC,WAAW;IAEX,OACE,CAAC,CAAC,WAAA,IACF,OAAO,WAAW,CAAC,WAAW,CAAA,KAAM,WAAA,IACpC,OAAO,WAAW,CAAC,WAAW,CAAC,CAAC,OAAO,CAAA,KAAM,UAAA,IAC7C,OAAO,WAAW,CAAC,WAAW,CAAC,CAAC,MAAM,CAAA,KAAM;AAEhD;AACA;;;;CAIA,GACA,SAAS,aAAa,GAAS;IAC7B,MAAM,MAAA,OAAS,gPAAS,EAAE;IAC1B,IAAI,CAAC,MAAM,EAAE;QACX,mPAAA,IAAe,uPAAK,CAAC,IAAI,CAAC,sDAAsD,CAAC;QACjF;IACF;IAEA,MAAM,cAAc,MAAM,CAAC,oBAAoB,CAAuB,sBAAsB,CAAC;IAE7F,IAAI,CAAC,WAAW,EAAE;QAChB,mPAAA,IAAe,uPAAK,CAAC,IAAI,CAAC,uCAAuC,CAAC;QAClE;IACF;IAEA,IAAI,CAAC,kCAAkC,CAAC,WAAW,CAAC,EAAE;QACpD,mPAAA,IAAe,uPAAK,CAAC,IAAI,CAAC,qDAAqD,CAAC;QAChF;IACF;IAEA,WAAW,CAAC,SAAS,CAAC,KAAK,EAAE;AAC/B;AAEA;;;CAGA,GACA,SAAS,YAAY,GAAS;IAC5B,MAAM,MAAA,OAAS,gPAAS,EAAE;IAC1B,IAAI,CAAC,MAAM,EAAE;QACX,mPAAA,IAAe,uPAAK,CAAC,IAAI,CAAC,sDAAsD,CAAC;QACjF;IACF;IAEA,MAAM,cAAc,MAAM,CAAC,oBAAoB,CAAuB,sBAAsB,CAAC;IAC7F,IAAI,CAAC,WAAW,EAAE;QAChB,mPAAA,IAAe,uPAAK,CAAC,IAAI,CAAC,uCAAuC,CAAC;QAClE;IACF;IAEA,IAAI,CAAC,kCAAkC,CAAC,WAAW,CAAC,EAAE;QACpD,mPAAA,IAAe,uPAAK,CAAC,IAAI,CAAC,qDAAqD,CAAC;QAChF;IACF;IAEA,WAAW,CAAC,SAAS,CAAC,IAAI,EAAE;AAC9B;AAEO,MAAM,QAAQ,GAAa;IAChC,aAAa;IACb,YAAY;AACd"}},
    {"offset": {"line": 4507, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/sdk.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/sdk.ts"],"sourcesContent":["import type { Client } from './client';\nimport { getCurrentScope } from './currentScopes';\nimport { DEBUG_BUILD } from './debug-build';\nimport type { ClientOptions } from './types-hoist/options';\nimport { consoleSandbox, debug } from './utils/debug-logger';\n\n/** A class object that can instantiate Client objects. */\nexport type ClientClass<F extends Client, O extends ClientOptions> = new (options: O) => F;\n\n/**\n * Internal function to create a new SDK client instance. The client is\n * installed and then bound to the current scope.\n *\n * @param clientClass The client class to instantiate.\n * @param options Options to pass to the client.\n */\nexport function initAndBind<F extends Client, O extends ClientOptions>(\n  clientClass: ClientClass<F, O>,\n  options: O,\n): Client {\n  if (options.debug === true) {\n    if (DEBUG_BUILD) {\n      debug.enable();\n    } else {\n      // use `console.warn` rather than `debug.warn` since by non-debug bundles have all `debug.x` statements stripped\n      consoleSandbox(() => {\n        // eslint-disable-next-line no-console\n        console.warn('[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.');\n      });\n    }\n  }\n  const scope = getCurrentScope();\n  scope.update(options.initialScope);\n\n  const client = new clientClass(options);\n  setCurrentClient(client);\n  client.init();\n  return client;\n}\n\n/**\n * Make the given client the current client.\n */\nexport function setCurrentClient(client: Client): void {\n  getCurrentScope().setClient(client);\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAMA,wDAAA,GAGA;;;;;;CAMA,GACO,SAAS,WAAW,CACzB,WAAW,EACX,OAAO;IAEP,IAAI,OAAO,CAAC,KAAA,KAAU,IAAI,EAAE;QAC1B,IAAI,mPAAW,EAAE;YACf,uPAAK,CAAC,MAAM,EAAE;QAChB,OAAO;YACX,gHAAA;gBACM,gQAAc,EAAC,MAAM;gBAC3B,sCAAA;gBACQ,OAAO,CAAC,IAAI,CAAC,8EAA8E,CAAC;YAC9F,CAAC,CAAC;QACJ;IACF;IACA,MAAM,KAAA,OAAQ,sPAAe,EAAE;IAC/B,KAAK,CAAC,MAAM,CAAC,OAAO,CAAC,YAAY,CAAC;IAElC,MAAM,MAAA,GAAS,IAAI,WAAW,CAAC,OAAO,CAAC;IACvC,gBAAgB,CAAC,MAAM,CAAC;IACxB,MAAM,CAAC,IAAI,EAAE;IACb,OAAO,MAAM;AACf;AAEA;;CAEA,GACO,SAAS,gBAAgB,CAAC,MAAM,EAAgB;QACrD,sPAAe,EAAE,EAAC,SAAS,CAAC,MAAM,CAAC;AACrC"}},
    {"offset": {"line": 4555, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/@sentry/core/build/esm/trpc.js","sources":["file:///Users/crischimiadao/ETHGlobalBuenosAires/blockchain-status-plotter-new/node_modules/%40sentry/core/src/trpc.ts"],"sourcesContent":["import { getClient, withIsolationScope } from './currentScopes';\nimport { captureException } from './exports';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE } from './semanticAttributes';\nimport { startSpanManual } from './tracing';\nimport { normalize } from './utils/normalize';\nimport { addNonEnumerableProperty } from './utils/object';\n\ninterface SentryTrpcMiddlewareOptions {\n  /** Whether to include procedure inputs in reported events. Defaults to `false`. */\n  attachRpcInput?: boolean;\n  forceTransaction?: boolean;\n}\n\nexport interface SentryTrpcMiddlewareArguments<T> {\n  path?: unknown;\n  type?: unknown;\n  next: () => T;\n  rawInput?: unknown;\n  getRawInput?: () => Promise<unknown>;\n}\n\nconst trpcCaptureContext = { mechanism: { handled: false, type: 'auto.rpc.trpc.middleware' } };\n\nfunction captureIfError(nextResult: unknown): void {\n  // TODO: Set span status based on what TRPCError was encountered\n  if (\n    typeof nextResult === 'object' &&\n    nextResult !== null &&\n    'ok' in nextResult &&\n    !nextResult.ok &&\n    'error' in nextResult\n  ) {\n    captureException(nextResult.error, trpcCaptureContext);\n  }\n}\n\ntype SentryTrpcMiddleware<T> = T extends Promise<unknown> ? T : Promise<T>;\n\n/**\n * Sentry tRPC middleware that captures errors and creates spans for tRPC procedures.\n */\nexport function trpcMiddleware(options: SentryTrpcMiddlewareOptions = {}) {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return async function <T>(opts: SentryTrpcMiddlewareArguments<T>): SentryTrpcMiddleware<T> {\n    const { path, type, next, rawInput, getRawInput } = opts;\n\n    const client = getClient();\n    const clientOptions = client?.getOptions();\n\n    const trpcContext: Record<string, unknown> = {\n      procedure_path: path,\n      procedure_type: type,\n    };\n\n    addNonEnumerableProperty(\n      trpcContext,\n      '__sentry_override_normalization_depth__',\n      1 + // 1 for context.input + the normal normalization depth\n        (clientOptions?.normalizeDepth ?? 5), // 5 is a sane depth\n    );\n\n    if (options.attachRpcInput !== undefined ? options.attachRpcInput : clientOptions?.sendDefaultPii) {\n      if (rawInput !== undefined) {\n        trpcContext.input = normalize(rawInput);\n      }\n\n      if (getRawInput !== undefined && typeof getRawInput === 'function') {\n        try {\n          const rawRes = await getRawInput();\n\n          trpcContext.input = normalize(rawRes);\n        } catch {\n          // noop\n        }\n      }\n    }\n\n    return withIsolationScope(scope => {\n      scope.setContext('trpc', trpcContext);\n      return startSpanManual(\n        {\n          name: `trpc/${path}`,\n          op: 'rpc.server',\n          attributes: {\n            [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.rpc.trpc',\n          },\n          forceTransaction: !!options.forceTransaction,\n        },\n        async span => {\n          try {\n            const nextResult = await next();\n            captureIfError(nextResult);\n            span.end();\n            return nextResult;\n          } catch (e) {\n            captureException(e, trpcCaptureContext);\n            span.end();\n            throw e;\n          }\n        },\n      ) as SentryTrpcMiddleware<T>;\n    });\n  };\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAqBA,MAAM,kBAAA,GAAqB;IAAE,SAAS,EAAE;QAAE,OAAO,EAAE,KAAK;QAAE,IAAI,EAAE,0BAAA;IAAA;AAAA,CAA8B;AAE9F,SAAS,cAAc,CAAC,UAAU,EAAiB;IACnD,gEAAA;IACE,IACE,OAAO,UAAA,KAAe,QAAA,IACtB,UAAA,KAAe,IAAA,IACf,IAAA,IAAQ,UAAA,IACR,CAAC,UAAU,CAAC,EAAA,IACZ,WAAW,YACX;YACA,iPAAgB,EAAC,UAAU,CAAC,KAAK,EAAE,kBAAkB,CAAC;IACxD;AACF;AAIA;;CAEA,GACO,SAAS,cAAc,CAAC,OAAO,GAAgC,CAAA,CAAE,EAAE;IAC1E,6DAAA;IACA,aAAA;IACE,OAAO,eAAmB,IAAI,EAA6D;QACzF,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,QAAQ,EAAE,WAAA,EAAY,GAAI,IAAI;QAExD,MAAM,MAAA,OAAS,gPAAS,EAAE;QAC1B,MAAM,aAAA,GAAgB,MAAM,EAAE,UAAU,EAAE;QAE1C,MAAM,WAAW,GAA4B;YAC3C,cAAc,EAAE,IAAI;YACpB,cAAc,EAAE,IAAI;QAC1B,CAAK;YAED,iQAAwB,EACtB,WAAW,EACX,yCAAyC,EACzC,CAAA,GAAA,uDAAA;QACN,CAAS,aAAa,EAAE,cAAA,IAAkB,CAAC,CAAC;QAGxC,IAAI,OAAO,CAAC,cAAA,KAAmB,SAAA,GAAY,OAAO,CAAC,cAAA,GAAiB,aAAa,EAAE,cAAc,EAAE;YACjG,IAAI,QAAA,KAAa,SAAS,EAAE;gBAC1B,WAAW,CAAC,KAAA,OAAQ,qPAAS,EAAC,QAAQ,CAAC;YACzC;YAEA,IAAI,WAAA,KAAgB,SAAA,IAAa,OAAO,WAAA,KAAgB,UAAU,EAAE;gBAClE,IAAI;oBACF,MAAM,MAAA,GAAS,MAAM,WAAW,EAAE;oBAElC,WAAW,CAAC,KAAA,OAAQ,qPAAS,EAAC,MAAM,CAAC;gBACvC,EAAE,OAAM;gBAChB,OAAA;gBACQ;YACF;QACF;QAEA,WAAO,yPAAkB,GAAC,KAAA,IAAS;YACjC,KAAK,CAAC,UAAU,CAAC,MAAM,EAAE,WAAW,CAAC;YACrC,WAAO,yPAAe,EACpB;gBACE,IAAI,EAAE,CAAC,KAAK,EAAE,IAAI,CAAC,CAAA;gBACA,EAAA,EAAA,YAAA;gBACA,UAAA,EAAA;oBACA,CAAA,4QAAA,CAAA,EAAA,OAAA;oBACA,CAAA,4QAAA,CAAA,EAAA,eAAA;gBACA,CAAA;gBACA,gBAAA,EAAA,CAAA,CAAA,OAAA,CAAA,gBAAA;YACA,CAAA,EACA,OAAA,IAAA,IAAA;gBACA,IAAA;oBACA,MAAA,UAAA,GAAA,MAAA,IAAA,EAAA;oBACA,cAAA,CAAA,UAAA,CAAA;oBACA,IAAA,CAAA,GAAA,EAAA;oBACA,OAAA,UAAA;gBACA,CAAA,CAAA,OAAA,CAAA,EAAA;wBACA,iPAAA,EAAA,CAAA,EAAA,kBAAA,CAAA;oBACA,IAAA,CAAA,GAAA,EAAA;oBACA,MAAA,CAAA;gBACA;YACA,CAAA;QAEA,CAAA,CAAA;IACA,CAAA;AACA"}}]
}